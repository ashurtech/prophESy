"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@elastic/transport/lib/security.js
var require_security = __commonJS({
  "node_modules/@elastic/transport/lib/security.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redactObject = redactObject;
    exports2.redactDiagnostic = redactDiagnostic;
    var secretKeys = [
      "authorization",
      "password",
      "apikey",
      "x-elastic-app-auth"
    ];
    function redactObject(obj, additionalKeys = []) {
      const toRedact = [...secretKeys, ...additionalKeys].map((key) => key.toLowerCase());
      const seen = /* @__PURE__ */ new Map();
      return doRedact(obj);
      function doRedact(obj2) {
        if (typeof obj2 !== "object" || obj2 == null)
          return obj2;
        const newObj = {};
        Object.entries(obj2).forEach(([key, value]) => {
          if (value instanceof URL) {
            value = `${value.origin}${value.pathname}${value.search}`;
          } else if (typeof value === "object" && value !== null) {
            if (Array.isArray(value)) {
              value = value.map((v) => doRedact(v));
            } else {
              if (seen.get(value) !== true) {
                seen.set(value, true);
                value = doRedact(value);
              } else {
                value = null;
              }
            }
          }
          if (toRedact.includes(key.toLowerCase())) {
            newObj[key] = "[redacted]";
          } else {
            newObj[key] = value;
          }
        });
        return newObj;
      }
    }
    function redactDiagnostic(diag3, options) {
      var _a;
      switch (options.type) {
        case "off":
          break;
        case "remove":
          delete diag3.headers;
          delete diag3.meta.sniff;
          delete diag3.meta.request.params.headers;
          diag3.meta.request.options = {};
          diag3.meta.connection = null;
          break;
        case "replace":
          diag3 = redactObject(diag3, (_a = options.additionalKeys) !== null && _a !== void 0 ? _a : []);
          break;
      }
      return diag3;
    }
  }
});

// node_modules/@elastic/transport/lib/errors.js
var require_errors = __commonJS({
  "node_modules/@elastic/transport/lib/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProductNotSupportedError = exports2.RequestAbortedError = exports2.ResponseError = exports2.ConfigurationError = exports2.DeserializationError = exports2.SerializationError = exports2.NoLivingConnectionsError = exports2.ConnectionError = exports2.TimeoutError = exports2.ElasticsearchClientError = void 0;
    var security_1 = require_security();
    var ElasticsearchClientError = class extends Error {
      constructor(message, options) {
        super(message);
        Object.defineProperty(this, "options", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = "ElasticsearchClientError";
        this.options = {
          redaction: {
            type: "replace",
            additionalKeys: []
          }
        };
        if (isObject(options)) {
          this.options.redaction = { ...this.options.redaction, ...options.redaction };
        }
      }
    };
    exports2.ElasticsearchClientError = ElasticsearchClientError;
    var TimeoutError = class _TimeoutError extends ElasticsearchClientError {
      constructor(message, meta, options) {
        super(message, options);
        Object.defineProperty(this, "meta", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _TimeoutError);
        this.name = "TimeoutError";
        this.message = message !== null && message !== void 0 ? message : "Timeout Error";
        if (isObject(meta))
          meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
      }
    };
    exports2.TimeoutError = TimeoutError;
    var ConnectionError = class _ConnectionError extends ElasticsearchClientError {
      constructor(message, meta, options) {
        super(message, options);
        Object.defineProperty(this, "meta", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _ConnectionError);
        this.name = "ConnectionError";
        this.message = message !== null && message !== void 0 ? message : "Connection Error";
        if (isObject(meta))
          meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
      }
    };
    exports2.ConnectionError = ConnectionError;
    var NoLivingConnectionsError = class _NoLivingConnectionsError extends ElasticsearchClientError {
      constructor(message, meta, options) {
        super(message, options);
        Object.defineProperty(this, "meta", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _NoLivingConnectionsError);
        this.name = "NoLivingConnectionsError";
        this.message = message !== null && message !== void 0 ? message : "Given the configuration, the ConnectionPool was not able to find a usable Connection for this request.";
        this.meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
      }
    };
    exports2.NoLivingConnectionsError = NoLivingConnectionsError;
    var SerializationError = class _SerializationError extends ElasticsearchClientError {
      constructor(message, data) {
        super(message);
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _SerializationError);
        this.name = "SerializationError";
        this.message = message !== null && message !== void 0 ? message : "Serialization Error";
        this.data = data;
      }
    };
    exports2.SerializationError = SerializationError;
    var DeserializationError = class _DeserializationError extends ElasticsearchClientError {
      constructor(message, data) {
        super(message);
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _DeserializationError);
        this.name = "DeserializationError";
        this.message = message !== null && message !== void 0 ? message : "Deserialization Error";
        this.data = data;
      }
    };
    exports2.DeserializationError = DeserializationError;
    var ConfigurationError = class _ConfigurationError extends ElasticsearchClientError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConfigurationError);
        this.name = "ConfigurationError";
        this.message = message !== null && message !== void 0 ? message : "Configuration Error";
      }
    };
    exports2.ConfigurationError = ConfigurationError;
    var ResponseError = class _ResponseError extends ElasticsearchClientError {
      constructor(meta, options) {
        var _a;
        super("Response Error", options);
        Object.defineProperty(this, "meta", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _ResponseError);
        this.name = "ResponseError";
        if (meta.statusCode === 410) {
          this.message = "This API is unavailable in the version of Elasticsearch you are using.";
        } else if (isObject(meta.body) && meta.body.error != null && meta.body.error.type != null) {
          this.message = meta.body.error.type;
          if (isObject(meta.body.error.caused_by)) {
            const { type, reason } = meta.body.error.caused_by;
            const causedBy = [
              "	Caused by:",
              `		${type}: ${reason}`
            ].join("\n");
            this.message += `
${causedBy}`;
          }
          if (Array.isArray(meta.body.error.root_cause) && meta.body.error.root_cause.length !== 0) {
            const formatRootCause = (entry) => `		${entry.type}: ${entry.reason}`;
            const rootCauses = [
              "	Root causes:",
              ...meta.body.error.root_cause.map(formatRootCause)
            ].join("\n");
            this.message += `
${rootCauses}`;
          }
        } else if (typeof meta.body === "object" && meta.body != null) {
          this.message = JSON.stringify(meta.body);
        } else {
          this.message = (_a = meta.body) !== null && _a !== void 0 ? _a : "Response Error";
        }
        this.meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
      }
      get body() {
        return this.meta.body;
      }
      get statusCode() {
        if (isObject(this.meta.body) && typeof this.meta.body.status === "number") {
          return this.meta.body.status;
        }
        return this.meta.statusCode;
      }
      get headers() {
        return this.meta.headers;
      }
    };
    exports2.ResponseError = ResponseError;
    var RequestAbortedError = class _RequestAbortedError extends ElasticsearchClientError {
      constructor(message, meta, options) {
        super(message, options);
        Object.defineProperty(this, "meta", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "RequestAbortedError";
        this.message = message !== null && message !== void 0 ? message : "Request aborted";
        if (isObject(meta))
          meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
      }
    };
    exports2.RequestAbortedError = RequestAbortedError;
    var ProductNotSupportedError = class _ProductNotSupportedError extends ElasticsearchClientError {
      constructor(product, meta, options) {
        super("Product Not Supported Error", options);
        Object.defineProperty(this, "meta", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Error.captureStackTrace(this, _ProductNotSupportedError);
        this.name = "ProductNotSupportedError";
        this.message = `The client noticed that the server is not ${product} and we do not support this unknown product.`;
        if (isObject(meta))
          meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);
        this.meta = meta;
      }
    };
    exports2.ProductNotSupportedError = ProductNotSupportedError;
    function isObject(obj) {
      return typeof obj === "object" && obj !== null;
    }
  }
});

// node_modules/@elastic/transport/lib/Diagnostic.js
var require_Diagnostic = __commonJS({
  "node_modules/@elastic/transport/lib/Diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.events = void 0;
    var node_events_1 = require("node:events");
    var errors_1 = require_errors();
    var events;
    (function(events2) {
      events2["RESPONSE"] = "response";
      events2["REQUEST"] = "request";
      events2["SNIFF"] = "sniff";
      events2["RESURRECT"] = "resurrect";
      events2["SERIALIZATION"] = "serialization";
      events2["DESERIALIZATION"] = "deserialization";
    })(events || (exports2.events = events = {}));
    var Diagnostic = class extends node_events_1.EventEmitter {
      on(event, listener) {
        assertSupportedEvent(event);
        super.on(event, listener);
        return this;
      }
      once(event, listener) {
        assertSupportedEvent(event);
        super.once(event, listener);
        return this;
      }
      off(event, listener) {
        assertSupportedEvent(event);
        super.off(event, listener);
        return this;
      }
    };
    exports2.default = Diagnostic;
    function assertSupportedEvent(event) {
      if (!supportedEvents.includes(event)) {
        throw new errors_1.ConfigurationError(`The event '${event}' is not supported.`);
      }
    }
    var supportedEvents = Object.keys(events).map((key) => events[key]);
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p in contextIn) context2[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context2.access[p] = contextIn.access[p];
    context2.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env2) {
  function fail(e) {
    env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
    env2.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env2.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
    if (env2.hasError) throw env2.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/@elastic/transport/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/@elastic/transport/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/@elastic/transport/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/@elastic/transport/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/@elastic/transport/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/@elastic/transport/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env2 = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@elastic/transport/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/@elastic/transport/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/@elastic/transport/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/@elastic/transport/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@elastic/transport/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/@elastic/transport/lib/symbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kOtelTracer = exports2.kRetryBackoff = exports2.kRedaction = exports2.kAcceptHeader = exports2.kNdjsonContentType = exports2.kJsonContentType = exports2.kMaxCompressedResponseSize = exports2.kMaxResponseSize = exports2.kCaFingerprint = exports2.kProductCheck = exports2.kStatus = exports2.kJsonOptions = exports2.kNodeSelector = exports2.kNodeFilter = exports2.kHeaders = exports2.kDiagnostic = exports2.kSerializer = exports2.kConnectionPool = exports2.kContext = exports2.kGenerateRequestId = exports2.kOpaqueIdPrefix = exports2.kName = exports2.kMaxRetries = exports2.kCompression = exports2.kRetryOnTimeout = exports2.kRequestTimeout = exports2.kSniffEndpoint = exports2.kSniffOnConnectionFault = exports2.kSniffInterval = exports2.kIsSniffing = exports2.kNextSniff = exports2.kSniffEnabled = void 0;
    exports2.kSniffEnabled = Symbol("sniff enabled");
    exports2.kNextSniff = Symbol("next sniff");
    exports2.kIsSniffing = Symbol("is sniffing");
    exports2.kSniffInterval = Symbol("sniff interval");
    exports2.kSniffOnConnectionFault = Symbol("sniff on connection fault");
    exports2.kSniffEndpoint = Symbol("sniff endpoint");
    exports2.kRequestTimeout = Symbol("request timeout");
    exports2.kRetryOnTimeout = Symbol("retry on timeout");
    exports2.kCompression = Symbol("compression");
    exports2.kMaxRetries = Symbol("max retries");
    exports2.kName = Symbol("name");
    exports2.kOpaqueIdPrefix = Symbol("opaque id prefix");
    exports2.kGenerateRequestId = Symbol("generate request id");
    exports2.kContext = Symbol("context");
    exports2.kConnectionPool = Symbol("connection pool");
    exports2.kSerializer = Symbol("serializer");
    exports2.kDiagnostic = Symbol("diagnostics");
    exports2.kHeaders = Symbol("headers");
    exports2.kNodeFilter = Symbol("node filter");
    exports2.kNodeSelector = Symbol("node selector");
    exports2.kJsonOptions = Symbol("secure json parse options");
    exports2.kStatus = Symbol("status");
    exports2.kProductCheck = Symbol("product check");
    exports2.kCaFingerprint = Symbol("ca fingerprint");
    exports2.kMaxResponseSize = Symbol("max response size");
    exports2.kMaxCompressedResponseSize = Symbol("max compressed response size");
    exports2.kJsonContentType = Symbol("json content type");
    exports2.kNdjsonContentType = Symbol("ndjson content type");
    exports2.kAcceptHeader = Symbol("accept header");
    exports2.kRedaction = Symbol("redaction");
    exports2.kRetryBackoff = Symbol("retry backoff");
    exports2.kOtelTracer = Symbol("opentelemetry tracer");
  }
});

// node_modules/@elastic/transport/lib/connection/BaseConnection.js
var require_BaseConnection = __commonJS({
  "node_modules/@elastic/transport/lib/connection/BaseConnection.js"(exports2) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareHeaders = prepareHeaders;
    exports2.getIssuerCertificate = getIssuerCertificate;
    exports2.isCaFingerprintMatch = isCaFingerprintMatch;
    exports2.isBinary = isBinary;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_util_1 = require("node:util");
    var Diagnostic_1 = tslib_1.__importDefault(require_Diagnostic());
    var errors_1 = require_errors();
    var symbols_1 = require_symbols();
    var BaseConnection = class _BaseConnection {
      constructor(opts) {
        var _d, _e, _f, _g, _h, _j, _k;
        Object.defineProperty(this, "url", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tls", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "id", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "timeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "deadCount", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "resurrectTimeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_openRequests", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "weight", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "maxEventListeners", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "roles", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _a, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _b, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _c, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.url = opts.url;
        this.tls = (_d = opts.tls) !== null && _d !== void 0 ? _d : null;
        this.id = (_e = opts.id) !== null && _e !== void 0 ? _e : stripAuth(opts.url.href);
        this.headers = prepareHeaders(opts.headers, opts.auth);
        this.timeout = (_f = opts.timeout) !== null && _f !== void 0 ? _f : null;
        this.deadCount = 0;
        this.resurrectTimeout = 0;
        this.weight = 0;
        this._openRequests = 0;
        this.maxEventListeners = (_g = opts.maxEventListeners) !== null && _g !== void 0 ? _g : 100;
        if (opts.roles != null)
          this.roles = opts.roles;
        this[symbols_1.kStatus] = (_h = opts.status) !== null && _h !== void 0 ? _h : _BaseConnection.statuses.ALIVE;
        this[symbols_1.kDiagnostic] = (_j = opts.diagnostic) !== null && _j !== void 0 ? _j : new Diagnostic_1.default();
        this[symbols_1.kCaFingerprint] = (_k = opts.caFingerprint) !== null && _k !== void 0 ? _k : null;
        if (!["http:", "https:"].includes(this.url.protocol)) {
          throw new errors_1.ConfigurationError(`Invalid protocol: '${this.url.protocol}'`);
        }
      }
      get status() {
        return this[symbols_1.kStatus];
      }
      set status(status) {
        if (!validStatuses.includes(status)) {
          throw new errors_1.ConfigurationError(`Unsupported status: '${status}'`);
        }
        this[symbols_1.kStatus] = status;
      }
      get diagnostic() {
        return this[symbols_1.kDiagnostic];
      }
      async request(params, options) {
        throw new errors_1.ConfigurationError("The request method should be implemented by extended classes");
      }
      /* istanbul ignore next */
      async close() {
        throw new errors_1.ConfigurationError("The close method should be implemented by extended classes");
      }
      // Handles console.log and utils.inspect invocations.
      // We want to hide `auth`, `agent` and `tls` since they made
      // the logs very hard to read. The user can still
      // access them with `instance.agent` and `instance.tls`.
      [(_a = symbols_1.kStatus, _b = symbols_1.kCaFingerprint, _c = symbols_1.kDiagnostic, node_util_1.inspect.custom)](depth, options) {
        const { authorization, ...headers } = this.headers;
        return {
          url: stripAuth(this.url.toString()),
          id: this.id,
          headers,
          status: this.status
        };
      }
      toJSON() {
        const { authorization, ...headers } = this.headers;
        return {
          url: stripAuth(this.url.toString()),
          id: this.id,
          headers,
          status: this.status
        };
      }
    };
    Object.defineProperty(BaseConnection, "statuses", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        ALIVE: "alive",
        DEAD: "dead"
      }
    });
    exports2.default = BaseConnection;
    var validStatuses = Object.keys(BaseConnection.statuses).map((k) => BaseConnection.statuses[k]);
    function stripAuth(url) {
      if (!url.includes("@"))
        return url;
      return url.slice(0, url.indexOf("//") + 2) + url.slice(url.indexOf("@") + 1);
    }
    function prepareHeaders(headers = {}, auth) {
      if (auth != null && headers.authorization == null) {
        if (isApiKeyAuth(auth)) {
          if (typeof auth.apiKey === "object") {
            headers.authorization = "ApiKey " + Buffer.from(`${auth.apiKey.id}:${auth.apiKey.api_key}`).toString("base64");
          } else {
            headers.authorization = `ApiKey ${auth.apiKey}`;
          }
        } else if (isBearerAuth(auth)) {
          headers.authorization = `Bearer ${auth.bearer}`;
        } else if (auth.username != null && auth.password != null) {
          headers.authorization = "Basic " + Buffer.from(`${auth.username}:${auth.password}`).toString("base64");
        }
      }
      return headers;
    }
    function isApiKeyAuth(auth) {
      return auth.apiKey != null;
    }
    function isBearerAuth(auth) {
      return auth.bearer != null;
    }
    function getIssuerCertificate(socket) {
      let certificate = socket.getPeerCertificate(true);
      while (certificate !== null && Object.keys(certificate).length > 0) {
        if (certificate.issuerCertificate == null) {
          return null;
        }
        if (certificate.fingerprint256 === certificate.issuerCertificate.fingerprint256) {
          break;
        }
        certificate = certificate.issuerCertificate;
      }
      return certificate;
    }
    function isCaFingerprintMatch(cert1, cert2) {
      if (typeof cert1 === "string" && typeof cert2 === "string") {
        const c1 = cert1.toLowerCase().replace(/:/g, "");
        const c2 = cert2.toLowerCase().replace(/:/g, "");
        return c1 === c2;
      }
      return cert1 === cert2;
    }
    function isBinary(contentType) {
      const binaryTypes = [
        "application/vnd.mapbox-vector-tile",
        "application/vnd.apache.arrow.stream",
        "application/vnd.elasticsearch+arrow+stream",
        "application/smile",
        "application/vnd.elasticsearch+smile",
        "application/cbor",
        "application/vnd.elasticsearch+cbor"
      ];
      return binaryTypes.map((type) => contentType.includes(type)).includes(true);
    }
  }
});

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "node_modules/secure-json-parse/index.js"(exports2, module2) {
    "use strict";
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text, reviver, options) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text, reviver) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, { safe: true });
      } catch (_e) {
        return null;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module2.exports = parse;
    module2.exports.default = parse;
    module2.exports.parse = parse;
    module2.exports.safeParse = safeParse;
    module2.exports.scan = filter;
  }
});

// node_modules/@elastic/transport/lib/Serializer.js
var require_Serializer = __commonJS({
  "node_modules/@elastic/transport/lib/Serializer.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_querystring_1 = require("node:querystring");
    var debug_1 = tslib_1.__importDefault(require_src());
    var secure_json_parse_1 = tslib_1.__importDefault(require_secure_json_parse());
    var errors_1 = require_errors();
    var symbols_1 = require_symbols();
    var debug = (0, debug_1.default)("elasticsearch");
    var Serializer = class {
      constructor(opts = {}) {
        var _b;
        Object.defineProperty(this, _a, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        const enabled = (_b = opts.enablePrototypePoisoningProtection) !== null && _b !== void 0 ? _b : false;
        this[symbols_1.kJsonOptions] = {
          protoAction: enabled === true || enabled === "proto" ? "error" : "ignore",
          constructorAction: enabled === true || enabled === "constructor" ? "error" : "ignore"
        };
      }
      /**
       * Serializes a record into a JSON string
       */
      serialize(object) {
        debug("Serializing", object);
        try {
          return JSON.stringify(object);
        } catch (err) {
          throw new errors_1.SerializationError(err.message, object);
        }
      }
      /**
       * Given a string, attempts to parse it from raw JSON into an object
       */
      deserialize(json) {
        debug("Deserializing", json);
        try {
          return secure_json_parse_1.default.parse(json, this[symbols_1.kJsonOptions]);
        } catch (err) {
          throw new errors_1.DeserializationError(err.message, json);
        }
      }
      /**
       * Serializes an array of records into a ndjson string
       */
      ndserialize(array) {
        debug("ndserialize", array);
        if (!Array.isArray(array)) {
          throw new errors_1.SerializationError("The argument provided is not an array", array);
        }
        let ndjson = "";
        for (let i = 0, len = array.length; i < len; i++) {
          if (typeof array[i] === "string") {
            ndjson += array[i] + "\n";
          } else {
            ndjson += this.serialize(array[i]) + "\n";
          }
        }
        return ndjson;
      }
      qserialize(object) {
        debug("qserialize", object);
        if (object == null)
          return "";
        if (typeof object === "string")
          return object;
        const keys = Object.keys(object);
        for (let i = 0, len = keys.length; i < len; i++) {
          const key = keys[i];
          if (object[key] === void 0) {
            delete object[key];
          } else if (Array.isArray(object[key])) {
            object[key] = object[key].join(",");
          }
        }
        return (0, node_querystring_1.stringify)(object);
      }
    };
    _a = symbols_1.kJsonOptions;
    exports2.default = Serializer;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_node();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.9.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
}
var __read2, __spreadArray2, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read3, __spreadArray3, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray3([], __read3(args), false));
          };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read4, __values2, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __values2 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
          var _b = __read4(_a, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values2(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag;
var init_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.set(key, value);
          return context2;
        };
        self.deleteValue = function(key) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends2, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends2 = /* @__PURE__ */ function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    /* @__PURE__ */ function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends2(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends2(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopGaugeMetric = /** @class */
    function(_super) {
      __extends2(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends2(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends2(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends2(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends2(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read5, __spreadArray4, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray4([thisArg], __read5(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read6, __spreadArray5, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read6 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray5 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray5([context2, fn, thisArg], __read6(args), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context2) {
        return this._getTracer().startSpan(name, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_tracestate_impl();
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
        return context2;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context2, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context2, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default;
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// node_modules/@elastic/transport/package.json
var require_package = __commonJS({
  "node_modules/@elastic/transport/package.json"(exports2, module2) {
    module2.exports = {
      name: "@elastic/transport",
      version: "9.0.1",
      description: "Transport classes and utilities shared among Node.js Elastic client libraries",
      main: "./index.js",
      types: "index.d.ts",
      exports: {
        ".": "./index.js",
        "./package.json": "./package.json",
        "./connection/BaseConnection": "./lib/connection/BaseConnection.js",
        "./lib/connection/BaseConnection": "./lib/connection/BaseConnection.js",
        "./pool/BaseConnectionPool": "./lib/pool/BaseConnectionPool.js",
        "./lib/pool/BaseConnectionPool": "./lib/pool/BaseConnectionPool.js",
        "./pool/CloudConnectionPool": "./lib/pool/CloudConnectionPool.js",
        "./lib/pool/CloudConnectionPool": "./lib/pool/CloudConnectionPool.js",
        "./pool/ClusterConnectionPool": "./lib/pool/ClusterConnectionPool.js",
        "./lib/pool/ClusterConnectionPool": "./lib/pool/ClusterConnectionPool.js",
        "./Diagnostic": "./lib/Diagnostic.js",
        "./lib/Diagnostic": "./lib/Diagnostic.js",
        "./errors": "./lib/errors.js",
        "./lib/errors": "./lib/errors.js",
        "./connection/HttpConnection": "./lib/connection/HttpConnection.js",
        "./lib/connection/HttpConnection": "./lib/connection/HttpConnection.js",
        "./connection": "./lib/connection/index.js",
        "./lib/connection": "./lib/connection/index.js",
        "./pool": "./lib/pool/index.js",
        "./lib/pool": "./lib/pool/index.js",
        "./security": "./lib/security.js",
        "./lib/security": "./lib/security.js",
        "./Serializer": "./lib/Serializer.js",
        "./lib/Serializer": "./lib/Serializer.js",
        "./symbols": "./lib/symbols.js",
        "./lib/symbols": "./lib/symbols.js",
        "./Transport": "./lib/Transport.js",
        "./lib/Transport": "./lib/Transport.js",
        "./types": "./lib/types.js",
        "./lib/types": "./lib/types.js",
        "./connection/UndiciConnection": "./lib/connection/UndiciConnection.js",
        "./lib/connection/UndiciConnection": "./lib/connection/UndiciConnection.js",
        "./pool/WeightedConnectionPool": "./lib/pool/WeightedConnectionPool.js",
        "./lib/pool/WeightedConnectionPool": "./lib/pool/WeightedConnectionPool.js"
      },
      scripts: {
        test: "npm run build && npm run lint && tap",
        "test:unit": "npm run build && tap test/unit/**/*.test.ts --disable-coverage",
        "test:unit-bun": "bun run build && bunx tap test/unit/**/*.test.ts --disable-coverage",
        "test:acceptance": "npm run build && tap test/acceptance/**/*.test.ts --disable-coverage",
        "test:coverage-100": "npm run build && tap --show-full-coverage",
        "test:coverage-report": "npm test && tap report --coverage-report=lcov",
        "test:coverage-ui": "npm run build && tap --coverage-report=html",
        lint: "ts-standard src",
        "lint:fix": "ts-standard --fix src",
        "license-checker": "license-checker --production --onlyAllow='MIT;Apache-2.0;Apache1.1;ISC;BSD-3-Clause;BSD-2-Clause;0BSD'",
        "license-header": "./scripts/check-spdx",
        prebuild: "npm run clean-build && npm run lint",
        build: "tsc",
        "clean-build": "rimraf ./lib && mkdir lib",
        prepublishOnly: "npm run build"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/elastic/elastic-transport-js.git"
      },
      keywords: [],
      author: {
        name: "Elastic Client Library Maintainers",
        company: "Elastic BV"
      },
      license: "Apache-2.0",
      bugs: {
        url: "https://github.com/elastic/elastic-transport-js/issues"
      },
      homepage: "https://github.com/elastic/elastic-transport-js#readme",
      engines: {
        node: ">=18"
      },
      devDependencies: {
        "@opentelemetry/sdk-trace-base": "1.30.1",
        "@sinonjs/fake-timers": "14.0.0",
        "@tapjs/clock": "3.0.1",
        "@types/debug": "4.1.12",
        "@types/ms": "2.1.0",
        "@types/node": "22.14.1",
        "@types/sinonjs__fake-timers": "8.1.5",
        "@types/stoppable": "1.1.3",
        "into-stream": "6.0.0",
        "license-checker": "25.0.1",
        "node-abort-controller": "3.1.1",
        proxy: "2.2.0",
        rimraf: "6.0.1",
        stoppable: "1.1.0",
        tap: "21.1.0",
        "ts-node": "10.9.2",
        "ts-standard": "12.0.2",
        typescript: "5.8.3",
        workq: "3.0.0"
      },
      dependencies: {
        "@opentelemetry/api": "1.x",
        debug: "^4.4.0",
        hpagent: "^1.2.0",
        ms: "^2.1.3",
        "secure-json-parse": "^3.0.2",
        tslib: "^2.8.1",
        undici: "^7.2.3"
      },
      tap: {
        files: [
          "test/unit/**/*.test.ts",
          "test/acceptance/**/*.test.ts"
        ],
        "allow-incomplete-coverage": true,
        plugin: [
          "@tapjs/clock",
          "@tapjs/before"
        ]
      }
    };
  }
});

// node_modules/@elastic/transport/lib/Transport.js
var require_Transport = __commonJS({
  "node_modules/@elastic/transport/lib/Transport.js"(exports2) {
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    var _e;
    var _f;
    var _g;
    var _h;
    var _j;
    var _k;
    var _l;
    var _m;
    var _o;
    var _p;
    var _q;
    var _r;
    var _s;
    var _t;
    var _u;
    var _v;
    var _w;
    var _x;
    var _y;
    var _z;
    var _0;
    var _1;
    var _2;
    var _3;
    var _4;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateRequestId = generateRequestId;
    exports2.lowerCaseHeaders = lowerCaseHeaders;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var debug_1 = tslib_1.__importDefault(require_src());
    var node_os_1 = tslib_1.__importDefault(require("node:os"));
    var node_zlib_1 = tslib_1.__importDefault(require("node:zlib"));
    var node_buffer_1 = tslib_1.__importDefault(require("node:buffer"));
    var node_util_1 = require("node:util");
    var node_process_1 = tslib_1.__importDefault(require("node:process"));
    var ms_1 = tslib_1.__importDefault(require_ms());
    var errors_1 = require_errors();
    var BaseConnection_1 = require_BaseConnection();
    var Diagnostic_1 = tslib_1.__importDefault(require_Diagnostic());
    var Serializer_1 = tslib_1.__importDefault(require_Serializer());
    var symbols_1 = require_symbols();
    var promises_1 = require("node:timers/promises");
    var api_1 = tslib_1.__importStar((init_esm(), __toCommonJS(esm_exports)));
    var { version: clientVersion } = require_package();
    var debug = (0, debug_1.default)("elasticsearch");
    var gzip = (0, node_util_1.promisify)(node_zlib_1.default.gzip);
    var unzip = (0, node_util_1.promisify)(node_zlib_1.default.unzip);
    var { createGzip } = node_zlib_1.default;
    var userAgent = `elastic-transport-js/${clientVersion} (${node_os_1.default.platform()} ${node_os_1.default.release()}-${node_os_1.default.arch()}; Node.js ${node_process_1.default.version})`;
    var Transport = class _Transport {
      constructor(opts) {
        var _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26;
        Object.defineProperty(this, _a, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _b, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _c, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _d, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _e, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _f, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _g, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _h, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _j, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _k, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _l, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _m, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _o, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _p, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _q, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _r, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _s, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _t, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _u, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _v, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _w, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _x, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _y, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _z, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _0, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _1, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _2, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _3, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _4, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        if (opts.connectionPool == null) {
          throw new errors_1.ConfigurationError("The Connection Pool option is not defined");
        }
        if (typeof opts.maxRetries === "number" && opts.maxRetries < 0 && Number.isInteger(opts.maxRetries)) {
          throw new errors_1.ConfigurationError("The maxRetries option must be a positive integer or zero");
        }
        if (opts.sniffInterval === true || typeof opts.sniffInterval === "number" && opts.sniffInterval < 0 && Number.isInteger(opts.sniffInterval)) {
          throw new errors_1.ConfigurationError("The sniffInterval option must be false or a positive integer");
        }
        if (opts.maxResponseSize != null && opts.maxResponseSize > node_buffer_1.default.constants.MAX_STRING_LENGTH) {
          throw new errors_1.ConfigurationError(`The maxResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_STRING_LENGTH}`);
        }
        if (opts.maxCompressedResponseSize != null && opts.maxCompressedResponseSize > node_buffer_1.default.constants.MAX_LENGTH) {
          throw new errors_1.ConfigurationError(`The maxCompressedResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_LENGTH}`);
        }
        this[symbols_1.kNodeFilter] = (_5 = opts.nodeFilter) !== null && _5 !== void 0 ? _5 : defaultNodeFilter;
        this[symbols_1.kNodeSelector] = (_6 = opts.nodeSelector) !== null && _6 !== void 0 ? _6 : roundRobinSelector();
        this[symbols_1.kHeaders] = Object.assign({}, { "user-agent": userAgent }, opts.compression === true ? { "accept-encoding": "gzip,deflate" } : null, lowerCaseHeaders(opts.headers));
        this[symbols_1.kDiagnostic] = (_7 = opts.diagnostic) !== null && _7 !== void 0 ? _7 : new Diagnostic_1.default();
        this[symbols_1.kConnectionPool] = opts.connectionPool;
        this[symbols_1.kSerializer] = (_8 = opts.serializer) !== null && _8 !== void 0 ? _8 : new Serializer_1.default();
        this[symbols_1.kContext] = (_9 = opts.context) !== null && _9 !== void 0 ? _9 : null;
        this[symbols_1.kGenerateRequestId] = (_10 = opts.generateRequestId) !== null && _10 !== void 0 ? _10 : generateRequestId();
        this[symbols_1.kOpaqueIdPrefix] = (_11 = opts.opaqueIdPrefix) !== null && _11 !== void 0 ? _11 : null;
        this[symbols_1.kName] = (_12 = opts.name) !== null && _12 !== void 0 ? _12 : "elastic-transport-js";
        this[symbols_1.kMaxRetries] = typeof opts.maxRetries === "number" ? opts.maxRetries : 3;
        this[symbols_1.kCompression] = opts.compression === true;
        this[symbols_1.kRequestTimeout] = opts.requestTimeout != null ? toMs(opts.requestTimeout) : null;
        this[symbols_1.kRetryOnTimeout] = opts.retryOnTimeout != null ? opts.retryOnTimeout : false;
        this[symbols_1.kSniffInterval] = (_13 = opts.sniffInterval) !== null && _13 !== void 0 ? _13 : false;
        this[symbols_1.kSniffEnabled] = typeof this[symbols_1.kSniffInterval] === "number";
        this[symbols_1.kNextSniff] = this[symbols_1.kSniffEnabled] ? Date.now() + this[symbols_1.kSniffInterval] : 0;
        this[symbols_1.kIsSniffing] = false;
        this[symbols_1.kSniffOnConnectionFault] = (_14 = opts.sniffOnConnectionFault) !== null && _14 !== void 0 ? _14 : false;
        this[symbols_1.kSniffEndpoint] = (_15 = opts.sniffEndpoint) !== null && _15 !== void 0 ? _15 : null;
        this[symbols_1.kProductCheck] = (_16 = opts.productCheck) !== null && _16 !== void 0 ? _16 : null;
        this[symbols_1.kMaxResponseSize] = (_17 = opts.maxResponseSize) !== null && _17 !== void 0 ? _17 : node_buffer_1.default.constants.MAX_STRING_LENGTH;
        this[symbols_1.kMaxCompressedResponseSize] = (_18 = opts.maxCompressedResponseSize) !== null && _18 !== void 0 ? _18 : node_buffer_1.default.constants.MAX_LENGTH;
        this[symbols_1.kJsonContentType] = (_20 = (_19 = opts.vendoredHeaders) === null || _19 === void 0 ? void 0 : _19.jsonContentType) !== null && _20 !== void 0 ? _20 : "application/json";
        this[symbols_1.kNdjsonContentType] = (_22 = (_21 = opts.vendoredHeaders) === null || _21 === void 0 ? void 0 : _21.ndjsonContentType) !== null && _22 !== void 0 ? _22 : "application/x-ndjson";
        this[symbols_1.kAcceptHeader] = (_24 = (_23 = opts.vendoredHeaders) === null || _23 === void 0 ? void 0 : _23.accept) !== null && _24 !== void 0 ? _24 : "application/json, text/plain";
        this[symbols_1.kRedaction] = (_25 = opts.redaction) !== null && _25 !== void 0 ? _25 : { type: "replace", additionalKeys: [] };
        this[symbols_1.kRetryBackoff] = (_26 = opts.retryBackoff) !== null && _26 !== void 0 ? _26 : retryBackoff;
        this[symbols_1.kOtelTracer] = api_1.default.trace.getTracer("@elastic/transport", clientVersion);
        if (opts.sniffOnStart === true) {
          this.sniff({
            reason: _Transport.sniffReasons.SNIFF_ON_START,
            requestId: this[symbols_1.kGenerateRequestId]({ method: "GET", path: this[symbols_1.kSniffEndpoint] }, { context: this[symbols_1.kContext] }),
            context: this[symbols_1.kContext]
          });
        }
      }
      get connectionPool() {
        return this[symbols_1.kConnectionPool];
      }
      get sniffEnabled() {
        return this[symbols_1.kSniffEnabled];
      }
      get nextSniff() {
        return this[symbols_1.kNextSniff];
      }
      get sniffEndpoint() {
        return this[symbols_1.kSniffEndpoint];
      }
      get isSniffing() {
        return this[symbols_1.kIsSniffing];
      }
      set isSniffing(val) {
        if (typeof val !== "boolean") {
          throw new errors_1.ConfigurationError(`isSniffing must be a boolean, instead got ${typeof val}`);
        }
        this[symbols_1.kIsSniffing] = val;
      }
      get diagnostic() {
        return this[symbols_1.kDiagnostic];
      }
      async _request(params, options = {}, otelSpan) {
        var _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23;
        const connectionParams = {
          method: params.method,
          path: params.path
        };
        const meta = {
          context: null,
          request: {
            params: connectionParams,
            options,
            id: (_5 = options.id) !== null && _5 !== void 0 ? _5 : this[symbols_1.kGenerateRequestId](params, options)
          },
          name: this[symbols_1.kName],
          connection: null,
          attempts: 0,
          aborted: false
        };
        const returnMeta = (_6 = options.meta) !== null && _6 !== void 0 ? _6 : false;
        if (this[symbols_1.kContext] != null && options.context != null) {
          meta.context = Object.assign({}, this[symbols_1.kContext], options.context);
        } else if (this[symbols_1.kContext] !== null) {
          meta.context = this[symbols_1.kContext];
        } else if (options.context != null) {
          meta.context = options.context;
        }
        const result = {
          // the default body value can't be `null`
          // as it's a valid JSON value
          body: void 0,
          statusCode: 0,
          headers: {},
          meta,
          get warnings() {
            var _52;
            if (((_52 = this.headers) === null || _52 === void 0 ? void 0 : _52.warning) == null) {
              return null;
            }
            const { warning } = this.headers;
            const warnings = Array.isArray(warning) ? warning : [warning];
            return warnings.flatMap((w) => w.split(/(?!\B"[^"]*),(?![^"]*"\B)/)).filter((warning2) => warning2.match(/^\d\d\d Elasticsearch-/));
          }
        };
        const maxRetries = isStream((_7 = params.body) !== null && _7 !== void 0 ? _7 : params.bulkBody) ? 0 : typeof options.maxRetries === "number" ? options.maxRetries : this[symbols_1.kMaxRetries];
        const compression = typeof options.compression === "boolean" ? options.compression : this[symbols_1.kCompression];
        const signal = options.signal;
        const maxResponseSize = (_8 = options.maxResponseSize) !== null && _8 !== void 0 ? _8 : this[symbols_1.kMaxResponseSize];
        const maxCompressedResponseSize = (_9 = options.maxCompressedResponseSize) !== null && _9 !== void 0 ? _9 : this[symbols_1.kMaxCompressedResponseSize];
        const errorOptions = {
          redaction: typeof options.redaction === "object" ? options.redaction : this[symbols_1.kRedaction]
        };
        this[symbols_1.kDiagnostic].emit("serialization", null, result);
        const headers = Object.assign({}, this[symbols_1.kHeaders], lowerCaseHeaders(options.headers));
        if (options.opaqueId !== void 0) {
          headers["x-opaque-id"] = typeof this[symbols_1.kOpaqueIdPrefix] === "string" ? this[symbols_1.kOpaqueIdPrefix] + options.opaqueId : options.opaqueId;
        }
        if (params.body != null) {
          if (shouldSerialize(params.body)) {
            try {
              connectionParams.body = this[symbols_1.kSerializer].serialize(params.body);
            } catch (err) {
              this[symbols_1.kDiagnostic].emit("request", err, result);
              throw err;
            }
            headers["content-type"] = (_10 = headers["content-type"]) !== null && _10 !== void 0 ? _10 : this[symbols_1.kJsonContentType];
            headers.accept = (_11 = headers.accept) !== null && _11 !== void 0 ? _11 : this[symbols_1.kJsonContentType];
          } else {
            if (params.body !== "") {
              headers["content-type"] = (_12 = headers["content-type"]) !== null && _12 !== void 0 ? _12 : "text/plain";
              headers.accept = (_13 = headers.accept) !== null && _13 !== void 0 ? _13 : this[symbols_1.kAcceptHeader];
            }
            connectionParams.body = params.body;
          }
        } else if (params.bulkBody != null) {
          if (shouldSerialize(params.bulkBody)) {
            try {
              connectionParams.body = this[symbols_1.kSerializer].ndserialize(params.bulkBody);
            } catch (err) {
              this[symbols_1.kDiagnostic].emit("request", err, result);
              throw err;
            }
          } else {
            connectionParams.body = params.bulkBody;
          }
          if (connectionParams.body !== "") {
            headers["content-type"] = (_14 = headers["content-type"]) !== null && _14 !== void 0 ? _14 : this[symbols_1.kNdjsonContentType];
            headers.accept = (_15 = headers.accept) !== null && _15 !== void 0 ? _15 : this[symbols_1.kJsonContentType];
          }
        }
        if (options.querystring == null) {
          connectionParams.querystring = this[symbols_1.kSerializer].qserialize(params.querystring);
        } else {
          connectionParams.querystring = this[symbols_1.kSerializer].qserialize(Object.assign({}, params.querystring, options.querystring));
        }
        if (connectionParams.body !== "" && connectionParams.body != null) {
          if (isStream(connectionParams.body)) {
            if (compression) {
              headers["content-encoding"] = "gzip";
              connectionParams.body = connectionParams.body.pipe(createGzip());
            }
          } else if (compression) {
            try {
              connectionParams.body = await gzip(connectionParams.body);
            } catch (err) {
              this[symbols_1.kDiagnostic].emit("request", err, result);
              throw err;
            }
            headers["content-encoding"] = "gzip";
            headers["content-length"] = "" + Buffer.byteLength(connectionParams.body);
          } else {
            headers["content-length"] = "" + Buffer.byteLength(connectionParams.body);
          }
        }
        headers.accept = (_16 = headers.accept) !== null && _16 !== void 0 ? _16 : this[symbols_1.kAcceptHeader];
        connectionParams.headers = headers;
        while (meta.attempts <= maxRetries) {
          try {
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
              throw new errors_1.RequestAbortedError("Request has been aborted by the user", result, errorOptions);
            }
            meta.connection = this.getConnection({
              requestId: meta.request.id,
              context: meta.context
            });
            if (meta.connection === null) {
              throw new errors_1.NoLivingConnectionsError("There are no living connections", result, errorOptions);
            }
            const requestUrl = meta.connection.url;
            otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttributes({
              "url.full": requestUrl.toString(),
              "server.address": requestUrl.hostname
            });
            if (requestUrl.port === "") {
              if (requestUrl.protocol === "https:") {
                otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute("server.port", 443);
              } else if (requestUrl.protocol === "http:") {
                otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute("server.port", 80);
              }
            } else if (requestUrl.port !== "9200") {
              otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute("server.port", parseInt(requestUrl.port, 10));
            }
            this[symbols_1.kDiagnostic].emit("request", null, result);
            let timeout = (_18 = (_17 = options.requestTimeout) !== null && _17 !== void 0 ? _17 : this[symbols_1.kRequestTimeout]) !== null && _18 !== void 0 ? _18 : void 0;
            if (timeout != null)
              timeout = toMs(timeout);
            let { statusCode, headers: headers2, body } = await meta.connection.request(connectionParams, {
              requestId: meta.request.id,
              name: this[symbols_1.kName],
              context: meta.context,
              maxResponseSize,
              maxCompressedResponseSize,
              signal,
              timeout,
              ...options.asStream === true ? { asStream: true } : null
            });
            result.statusCode = statusCode;
            result.headers = headers2;
            if (headers2["x-found-handling-cluster"] != null) {
              otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute("db.elasticsearch.cluster.name", headers2["x-found-handling-cluster"]);
            }
            if (headers2["x-found-handling-instance"] != null) {
              otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute("db.elasticsearch.node.name", headers2["x-found-handling-instance"]);
            }
            if (this[symbols_1.kProductCheck] != null && headers2["x-elastic-product"] !== this[symbols_1.kProductCheck] && statusCode >= 200 && statusCode < 300) {
              throw new errors_1.ProductNotSupportedError(this[symbols_1.kProductCheck], result, errorOptions);
            }
            if (options.asStream === true) {
              result.body = body;
              this[symbols_1.kDiagnostic].emit("response", null, result);
              return returnMeta ? result : body;
            }
            const contentEncoding = ((_19 = headers2["content-encoding"]) !== null && _19 !== void 0 ? _19 : "").toLowerCase();
            if (contentEncoding.includes("gzip") || contentEncoding.includes("deflate")) {
              body = await unzip(body);
            }
            if (Buffer.isBuffer(body) && !(0, BaseConnection_1.isBinary)((_20 = headers2["content-type"]) !== null && _20 !== void 0 ? _20 : "")) {
              body = body.toString();
            }
            const isHead = params.method === "HEAD";
            if (headers2["content-type"] !== void 0 && (((_21 = headers2["content-type"]) === null || _21 === void 0 ? void 0 : _21.includes("application/json")) || ((_22 = headers2["content-type"]) === null || _22 === void 0 ? void 0 : _22.includes("application/vnd.elasticsearch+json"))) && !isHead && body !== "") {
              result.body = this[symbols_1.kSerializer].deserialize(body);
            } else {
              result.body = isHead && statusCode < 400 ? true : body;
            }
            const ignoreStatusCode = Array.isArray(options.ignore) && options.ignore.includes(statusCode) || isHead && statusCode === 404;
            if (!ignoreStatusCode && (statusCode === 502 || statusCode === 503 || statusCode === 504)) {
              this[symbols_1.kConnectionPool].markDead(meta.connection);
              if (meta.attempts < maxRetries) {
                meta.attempts++;
                debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);
                continue;
              }
            } else {
              this[symbols_1.kConnectionPool].markAlive(meta.connection);
            }
            if (!ignoreStatusCode && statusCode >= 400) {
              throw new errors_1.ResponseError(result, errorOptions);
            } else {
              if (isHead && statusCode === 404) {
                result.body = false;
              }
              this[symbols_1.kDiagnostic].emit("response", null, result);
              return returnMeta ? result : result.body;
            }
          } catch (error) {
            switch (error.name) {
              // should not retry
              case "ProductNotSupportedError":
              case "NoLivingConnectionsError":
              case "DeserializationError":
              case "ResponseError":
                this[symbols_1.kDiagnostic].emit("response", error, result);
                throw error;
              case "RequestAbortedError": {
                meta.aborted = true;
                const wrappedError = new errors_1.RequestAbortedError(error.message, result, errorOptions);
                this[symbols_1.kDiagnostic].emit("response", wrappedError, result);
                throw wrappedError;
              }
              // should maybe retry
              // @ts-expect-error `case` fallthrough is intentional: should retry if retryOnTimeout is true
              case "TimeoutError":
                if (!this[symbols_1.kRetryOnTimeout]) {
                  const wrappedError = new errors_1.TimeoutError(error.message, result, errorOptions);
                  this[symbols_1.kDiagnostic].emit("response", wrappedError, result);
                  throw wrappedError;
                }
              // should retry
              // eslint-disable-next-line no-fallthrough
              case "ConnectionError": {
                this[symbols_1.kConnectionPool].markDead(meta.connection);
                if (this[symbols_1.kSniffOnConnectionFault]) {
                  this.sniff({
                    reason: _Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,
                    requestId: meta.request.id,
                    context: meta.context
                  });
                }
                if (meta.attempts < maxRetries) {
                  meta.attempts++;
                  debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);
                  if (meta.attempts >= this[symbols_1.kConnectionPool].size) {
                    const backoff = (_23 = options.retryBackoff) !== null && _23 !== void 0 ? _23 : this[symbols_1.kRetryBackoff];
                    const backoffWait = backoff(0, 4, meta.attempts);
                    if (backoffWait > 0) {
                      await (0, promises_1.setTimeout)(backoffWait * 1e3);
                    }
                  }
                  continue;
                }
                const wrappedError = error.name === "TimeoutError" ? new errors_1.TimeoutError(error.message, result, errorOptions) : new errors_1.ConnectionError(error.message, result, errorOptions);
                this[symbols_1.kDiagnostic].emit("response", wrappedError, result);
                throw wrappedError;
              }
              // edge cases, such as bad compression
              default:
                this[symbols_1.kDiagnostic].emit("response", error, result);
                throw error;
            }
          }
        }
        return returnMeta ? result : result.body;
      }
      async request(params, options = {}) {
        var _5, _6, _7;
        if (((_5 = params.meta) === null || _5 === void 0 ? void 0 : _5.name) != null) {
          const attributes = {
            "db.system": "elasticsearch",
            "http.request.method": params.method,
            "db.operation.name": (_6 = params.meta) === null || _6 === void 0 ? void 0 : _6.name
          };
          if (((_7 = params.meta) === null || _7 === void 0 ? void 0 : _7.pathParts) != null) {
            for (const key of Object.keys(params.meta.pathParts)) {
              attributes[`db.elasticsearch.path_parts.${key}`] = params.meta.pathParts[key];
            }
          }
          return await this[symbols_1.kOtelTracer].startActiveSpan(params.meta.name, { attributes, kind: api_1.SpanKind.CLIENT }, async (otelSpan) => {
            var _52;
            let response;
            try {
              response = await this._request(params, options, otelSpan);
            } catch (err) {
              otelSpan.recordException(err);
              otelSpan.setStatus({ code: api_1.SpanStatusCode.ERROR });
              otelSpan.setAttribute("error.type", (_52 = err.name) !== null && _52 !== void 0 ? _52 : "Error");
              throw err;
            } finally {
              otelSpan.end();
            }
            return response;
          });
        } else {
          return await this._request(params, options);
        }
      }
      getConnection(opts) {
        const now = Date.now();
        if (this[symbols_1.kSniffEnabled] && now > this[symbols_1.kNextSniff]) {
          this[symbols_1.kNextSniff] = now + this[symbols_1.kSniffInterval];
          this.sniff({
            reason: _Transport.sniffReasons.SNIFF_INTERVAL,
            requestId: opts.requestId,
            context: opts.context
          });
        }
        return this[symbols_1.kConnectionPool].getConnection({
          filter: this[symbols_1.kNodeFilter],
          selector: this[symbols_1.kNodeSelector],
          requestId: opts.requestId,
          name: this[symbols_1.kName],
          context: opts.context,
          now
        });
      }
      /* istanbul ignore next */
      sniff(opts) {
      }
    };
    _a = symbols_1.kNodeFilter, _b = symbols_1.kNodeSelector, _c = symbols_1.kHeaders, _d = symbols_1.kDiagnostic, _e = symbols_1.kConnectionPool, _f = symbols_1.kSerializer, _g = symbols_1.kContext, _h = symbols_1.kGenerateRequestId, _j = symbols_1.kOpaqueIdPrefix, _k = symbols_1.kName, _l = symbols_1.kMaxRetries, _m = symbols_1.kCompression, _o = symbols_1.kRequestTimeout, _p = symbols_1.kRetryOnTimeout, _q = symbols_1.kSniffEnabled, _r = symbols_1.kNextSniff, _s = symbols_1.kIsSniffing, _t = symbols_1.kSniffInterval, _u = symbols_1.kSniffOnConnectionFault, _v = symbols_1.kSniffEndpoint, _w = symbols_1.kProductCheck, _x = symbols_1.kMaxResponseSize, _y = symbols_1.kMaxCompressedResponseSize, _z = symbols_1.kJsonContentType, _0 = symbols_1.kNdjsonContentType, _1 = symbols_1.kAcceptHeader, _2 = symbols_1.kRedaction, _3 = symbols_1.kRetryBackoff, _4 = symbols_1.kOtelTracer;
    Object.defineProperty(Transport, "sniffReasons", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        SNIFF_ON_START: "sniff-on-start",
        SNIFF_INTERVAL: "sniff-interval",
        SNIFF_ON_CONNECTION_FAULT: "sniff-on-connection-fault",
        DEFAULT: "default"
      }
    });
    exports2.default = Transport;
    function toMs(time) {
      if (typeof time === "string") {
        return (0, ms_1.default)(time);
      }
      return time;
    }
    function shouldSerialize(obj) {
      return typeof obj !== "string" && typeof obj.pipe !== "function" && !Buffer.isBuffer(obj);
    }
    function isStream(obj) {
      return obj != null && typeof obj.pipe === "function";
    }
    function defaultNodeFilter(node) {
      return true;
    }
    function roundRobinSelector() {
      let current = -1;
      return function _roundRobinSelector(connections) {
        if (++current >= connections.length) {
          current = 0;
        }
        return connections[current];
      };
    }
    function generateRequestId() {
      const maxInt = 2147483647;
      let nextReqId = 0;
      return function genReqId(params, options) {
        return nextReqId = nextReqId + 1 & maxInt;
      };
    }
    function lowerCaseHeaders(oldHeaders) {
      if (oldHeaders == null)
        return null;
      const newHeaders = {};
      for (const header in oldHeaders) {
        newHeaders[header.toLowerCase()] = oldHeaders[header];
      }
      return newHeaders;
    }
    function retryBackoff(min, max, attempt) {
      const ceiling = Math.min(max, 2 ** attempt) / 2;
      return ceiling + (Math.random() * (ceiling - min) + min);
    }
  }
});

// node_modules/hpagent/index.js
var require_hpagent = __commonJS({
  "node_modules/hpagent/index.js"(exports2, module2) {
    "use strict";
    var https = require("https");
    var http = require("http");
    var { URL: URL2 } = require("url");
    var HttpProxyAgent = class extends http.Agent {
      constructor(options) {
        const { proxy, proxyRequestOptions, ...opts } = options;
        super(opts);
        this.proxy = typeof proxy === "string" ? new URL2(proxy) : proxy;
        this.proxyRequestOptions = proxyRequestOptions || {};
      }
      createConnection(options, callback) {
        const requestOptions = {
          ...this.proxyRequestOptions,
          method: "CONNECT",
          host: this.proxy.hostname,
          port: this.proxy.port,
          path: `${options.host}:${options.port}`,
          setHost: false,
          headers: { ...this.proxyRequestOptions.headers, connection: this.keepAlive ? "keep-alive" : "close", host: `${options.host}:${options.port}` },
          agent: false,
          timeout: options.timeout || 0
        };
        if (this.proxy.username || this.proxy.password) {
          const base64 = Buffer.from(`${decodeURIComponent(this.proxy.username || "")}:${decodeURIComponent(this.proxy.password || "")}`).toString("base64");
          requestOptions.headers["proxy-authorization"] = `Basic ${base64}`;
        }
        if (this.proxy.protocol === "https:") {
          requestOptions.servername = this.proxy.hostname;
        }
        const request = (this.proxy.protocol === "http:" ? http : https).request(requestOptions);
        request.once("connect", (response, socket, head) => {
          request.removeAllListeners();
          socket.removeAllListeners();
          if (response.statusCode === 200) {
            callback(null, socket);
          } else {
            socket.destroy();
            callback(new Error(`Bad response: ${response.statusCode}`), null);
          }
        });
        request.once("timeout", () => {
          request.destroy(new Error("Proxy timeout"));
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          callback(err, null);
        });
        request.end();
      }
    };
    var HttpsProxyAgent = class extends https.Agent {
      constructor(options) {
        const { proxy, proxyRequestOptions, ...opts } = options;
        super(opts);
        this.proxy = typeof proxy === "string" ? new URL2(proxy) : proxy;
        this.proxyRequestOptions = proxyRequestOptions || {};
      }
      createConnection(options, callback) {
        const requestOptions = {
          ...this.proxyRequestOptions,
          method: "CONNECT",
          host: this.proxy.hostname,
          port: this.proxy.port,
          path: `${options.host}:${options.port}`,
          setHost: false,
          headers: { ...this.proxyRequestOptions.headers, connection: this.keepAlive ? "keep-alive" : "close", host: `${options.host}:${options.port}` },
          agent: false,
          timeout: options.timeout || 0
        };
        if (this.proxy.username || this.proxy.password) {
          const base64 = Buffer.from(`${decodeURIComponent(this.proxy.username || "")}:${decodeURIComponent(this.proxy.password || "")}`).toString("base64");
          requestOptions.headers["proxy-authorization"] = `Basic ${base64}`;
        }
        if (this.proxy.protocol === "https:") {
          requestOptions.servername = this.proxy.hostname;
        }
        const request = (this.proxy.protocol === "http:" ? http : https).request(requestOptions);
        request.once("connect", (response, socket, head) => {
          request.removeAllListeners();
          socket.removeAllListeners();
          if (response.statusCode === 200) {
            const secureSocket = super.createConnection({ ...options, socket });
            callback(null, secureSocket);
          } else {
            socket.destroy();
            callback(new Error(`Bad response: ${response.statusCode}`), null);
          }
        });
        request.once("timeout", () => {
          request.destroy(new Error("Proxy timeout"));
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          callback(err, null);
        });
        request.end();
      }
    };
    module2.exports = {
      HttpProxyAgent,
      HttpsProxyAgent
    };
  }
});

// node_modules/@elastic/transport/lib/connection/HttpConnection.js
var require_HttpConnection = __commonJS({
  "node_modules/@elastic/transport/lib/connection/HttpConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var hpagent_1 = tslib_1.__importDefault(require_hpagent());
    var node_http_1 = tslib_1.__importDefault(require("node:http"));
    var node_https_1 = tslib_1.__importDefault(require("node:https"));
    var debug_1 = tslib_1.__importDefault(require_src());
    var node_buffer_1 = tslib_1.__importDefault(require("node:buffer"));
    var BaseConnection_1 = tslib_1.__importStar(require_BaseConnection());
    var symbols_1 = require_symbols();
    var node_stream_1 = require("node:stream");
    var errors_1 = require_errors();
    var promises_1 = require("node:timers/promises");
    var debug = (0, debug_1.default)("elasticsearch");
    var INVALID_PATH_REGEX = /[^\u0021-\u00ff]/;
    var MAX_BUFFER_LENGTH = node_buffer_1.default.constants.MAX_LENGTH;
    var MAX_STRING_LENGTH = node_buffer_1.default.constants.MAX_STRING_LENGTH;
    var noop = () => {
    };
    var HttpConnection = class extends BaseConnection_1.default {
      constructor(opts) {
        super(opts);
        Object.defineProperty(this, "agent", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "makeRequest", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        if (typeof opts.agent === "function") {
          this.agent = opts.agent(opts);
        } else if (typeof opts.agent === "boolean") {
          this.agent = void 0;
        } else {
          if (opts.agent != null && !isHttpAgentOptions(opts.agent)) {
            throw new errors_1.ConfigurationError("Bad agent configuration for Http agent");
          }
          const agentOptions = Object.assign({}, {
            keepAlive: true,
            keepAliveMsecs: 1e3,
            maxSockets: 256,
            maxFreeSockets: 256,
            scheduling: "lifo"
          }, opts.agent);
          if (opts.proxy != null) {
            const proxyAgentOptions = {
              ...agentOptions,
              proxy: opts.proxy
            };
            this.agent = this.url.protocol === "http:" ? new hpagent_1.default.HttpProxyAgent(proxyAgentOptions) : new hpagent_1.default.HttpsProxyAgent(Object.assign({}, proxyAgentOptions, this.tls));
          } else {
            this.agent = this.url.protocol === "http:" ? new node_http_1.default.Agent(agentOptions) : new node_https_1.default.Agent(Object.assign({}, agentOptions, this.tls));
          }
        }
        this.makeRequest = this.url.protocol === "http:" ? node_http_1.default.request : node_https_1.default.request;
      }
      async request(params, options) {
        return await new Promise((resolve2, reject) => {
          var _a, _b;
          let cleanedListeners = false;
          const maxResponseSize = (_a = options.maxResponseSize) !== null && _a !== void 0 ? _a : MAX_STRING_LENGTH;
          const maxCompressedResponseSize = (_b = options.maxCompressedResponseSize) !== null && _b !== void 0 ? _b : MAX_BUFFER_LENGTH;
          const requestParams = this.buildRequestObject(params, options);
          if (INVALID_PATH_REGEX.test(requestParams.path)) {
            return reject(new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`));
          }
          debug("Starting a new request", params);
          let responseEnded = false;
          let requestFinished = false;
          let connectionRequestResponse;
          let request;
          try {
            request = this.makeRequest(requestParams);
          } catch (err) {
            return reject(err);
          }
          const abortListener = () => {
            request.destroy(new errors_1.RequestAbortedError("Request aborted"));
          };
          this._openRequests++;
          if (options.signal != null) {
            options.signal.addEventListener("abort", abortListener, { once: true });
          }
          const onResponse = (response) => {
            var _a2, _b2;
            cleanListeners();
            if (options.asStream === true) {
              return resolve2({
                body: response,
                statusCode: response.statusCode,
                headers: response.headers
              });
            }
            const contentEncoding = ((_a2 = response.headers["content-encoding"]) !== null && _a2 !== void 0 ? _a2 : "").toLowerCase();
            const isCompressed = contentEncoding.includes("gzip") || contentEncoding.includes("deflate");
            const bodyIsBinary = (0, BaseConnection_1.isBinary)((_b2 = response.headers["content-type"]) !== null && _b2 !== void 0 ? _b2 : "");
            if (response.headers["content-length"] !== void 0) {
              const contentLength = Number(response.headers["content-length"]);
              if (isCompressed && contentLength > maxCompressedResponseSize) {
                response.destroy();
                return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`));
              } else if (contentLength > maxResponseSize) {
                response.destroy();
                return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`));
              }
            }
            let payload = isCompressed || bodyIsBinary ? new Array() : "";
            const onData = isCompressed || bodyIsBinary ? onDataAsBuffer : onDataAsString;
            let currentLength = 0;
            function onDataAsBuffer(chunk) {
              currentLength += Buffer.byteLength(chunk);
              if (currentLength > maxCompressedResponseSize) {
                response.destroy(new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`));
              } else {
                payload.push(chunk);
              }
            }
            function onDataAsString(chunk) {
              currentLength += Buffer.byteLength(chunk);
              if (currentLength > maxResponseSize) {
                response.destroy(new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed string (${maxResponseSize})`));
              } else {
                payload = `${payload}${chunk}`;
              }
            }
            const onEnd = () => {
              response.removeListener("data", onData);
              response.removeListener("end", onEnd);
              responseEnded = true;
              connectionRequestResponse = {
                body: isCompressed || bodyIsBinary ? Buffer.concat(payload) : payload,
                statusCode: response.statusCode,
                headers: response.headers
              };
              if (requestFinished) {
                return resolve2(connectionRequestResponse);
              }
            };
            const onResponseClose = () => {
              return reject(new errors_1.ConnectionError("Response aborted while reading the body"));
            };
            if (!isCompressed && !bodyIsBinary) {
              response.setEncoding("utf8");
            }
            this.diagnostic.emit("deserialization", null, options);
            response.on("data", onData);
            response.on("end", onEnd);
            response.on("close", onResponseClose);
          };
          const onTimeout = () => {
            cleanListeners();
            request.once("error", noop);
            request.destroy();
            return reject(new errors_1.TimeoutError("Request timed out"));
          };
          const onError = (err) => {
            var _a2, _b2, _c, _d, _e, _f, _g, _h;
            let { name, message, code } = err;
            if (code === "HPE_INVALID_CONSTANT" && message.startsWith("Parse Error: Expected HTTP/"))
              return;
            cleanListeners();
            if (name === "RequestAbortedError") {
              return reject(err);
            }
            if (code === "ECONNRESET") {
              message += ` - Local: ${(_b2 = (_a2 = request.socket) === null || _a2 === void 0 ? void 0 : _a2.localAddress) !== null && _b2 !== void 0 ? _b2 : "unknown"}:${(_d = (_c = request.socket) === null || _c === void 0 ? void 0 : _c.localPort) !== null && _d !== void 0 ? _d : "unknown"}, Remote: ${(_f = (_e = request.socket) === null || _e === void 0 ? void 0 : _e.remoteAddress) !== null && _f !== void 0 ? _f : "unknown"}:${(_h = (_g = request.socket) === null || _g === void 0 ? void 0 : _g.remotePort) !== null && _h !== void 0 ? _h : "unknown"}`;
            } else if (code === "EPIPE") {
              message = "Response aborted while reading the body";
            }
            return reject(new errors_1.ConnectionError(message));
          };
          const onSocket = (socket) => {
            if (!socket.isSessionReused()) {
              socket.once("secureConnect", () => {
                const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);
                if (issuerCertificate == null) {
                  onError(new Error("Invalid or malformed certificate"));
                  request.once("error", noop);
                  return request.destroy();
                }
                if (!(0, BaseConnection_1.isCaFingerprintMatch)(this[symbols_1.kCaFingerprint], issuerCertificate.fingerprint256)) {
                  onError(new Error("Server certificate CA fingerprint does not match the value configured in caFingerprint"));
                  request.once("error", noop);
                  return request.destroy();
                }
              });
            }
          };
          const onFinish = () => {
            requestFinished = true;
            if (responseEnded) {
              if (connectionRequestResponse != null) {
                return resolve2(connectionRequestResponse);
              } else {
                return reject(new Error("No response body received"));
              }
            }
          };
          const cleanListeners = () => {
            if (cleanedListeners)
              return;
            this._openRequests--;
            request.removeListener("response", onResponse);
            request.removeListener("timeout", onTimeout);
            request.removeListener("socket", onSocket);
            if (options.signal != null) {
              if ("removeEventListener" in options.signal) {
                options.signal.removeEventListener("abort", abortListener);
              } else {
                options.signal.removeListener("abort", abortListener);
              }
            }
            cleanedListeners = true;
          };
          request.on("response", onResponse);
          request.on("timeout", onTimeout);
          request.on("error", onError);
          request.on("finish", onFinish);
          if (this[symbols_1.kCaFingerprint] != null && requestParams.protocol === "https:") {
            request.on("socket", onSocket);
          }
          request.setNoDelay(true);
          if (isStream(params.body)) {
            (0, node_stream_1.pipeline)(params.body, request, (err) => {
              if (err != null && !cleanedListeners) {
                cleanListeners();
                return reject(err);
              }
            });
          } else {
            request.end(params.body);
          }
        });
      }
      async close() {
        debug("Closing connection", this.id);
        while (this._openRequests > 0) {
          await (0, promises_1.setTimeout)(1e3);
        }
        if (this.agent !== void 0) {
          this.agent.destroy();
        }
      }
      buildRequestObject(params, options) {
        var _a, _b;
        const url = this.url;
        let search = url.search;
        let pathname = url.pathname;
        const request = {
          protocol: url.protocol,
          hostname: url.hostname[0] === "[" ? url.hostname.slice(1, -1) : url.hostname,
          path: "",
          // https://github.com/elastic/elasticsearch-js/issues/843
          port: url.port !== "" ? url.port : void 0,
          headers: this.headers,
          agent: this.agent,
          // only set a timeout if it has a value; default to no timeout
          // see https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-network.html#_http_client_configuration
          timeout: (_b = (_a = options.timeout) !== null && _a !== void 0 ? _a : this.timeout) !== null && _b !== void 0 ? _b : void 0
        };
        const paramsKeys = Object.keys(params);
        for (let i = 0, len = paramsKeys.length; i < len; i++) {
          const key = paramsKeys[i];
          if (key === "path") {
            pathname = resolve(pathname, params[key]);
          } else if (key === "querystring" && Boolean(params[key])) {
            if (search === "") {
              search = `?${params[key]}`;
            } else {
              search += `&${params[key]}`;
            }
          } else if (key === "headers") {
            request.headers = Object.assign({}, request.headers, params.headers);
          } else {
            request[key] = params[key];
          }
        }
        request.path = pathname + search;
        return request;
      }
    };
    exports2.default = HttpConnection;
    function isStream(obj) {
      return obj != null && typeof obj.pipe === "function";
    }
    function resolve(host, path) {
      const hostEndWithSlash = host[host.length - 1] === "/";
      const pathStartsWithSlash = path[0] === "/";
      if (hostEndWithSlash && pathStartsWithSlash) {
        return host + path.slice(1);
      } else if (hostEndWithSlash !== pathStartsWithSlash) {
        return host + path;
      } else {
        return host + "/" + path;
      }
    }
    function isHttpAgentOptions(opts) {
      if (opts.keepAliveTimeout != null)
        return false;
      if (opts.keepAliveMaxTimeout != null)
        return false;
      if (opts.keepAliveTimeoutThreshold != null)
        return false;
      if (opts.pipelining != null)
        return false;
      if (opts.maxHeaderSize != null)
        return false;
      if (opts.connections != null)
        return false;
      return true;
    }
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kBody: Symbol("abstracted request body"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kResume: Symbol("resume"),
      kOnError: Symbol("on error"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable"),
      kListeners: Symbol("listeners"),
      kHTTPContext: Symbol("http context"),
      kMaxConcurrentStreams: Symbol("max concurrent streams"),
      kNoProxyAgent: Symbol("no proxy agent"),
      kHttpProxyAgent: Symbol("http proxy agent"),
      kHttpsProxyAgent: Symbol("https proxy agent")
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/util/timers.js
var require_timers = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/util/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = 0;
    var RESOLUTION_MS = 1e3;
    var TICK_MS = (RESOLUTION_MS >> 1) - 1;
    var fastNowTimeout;
    var kFastTimer = Symbol("kFastTimer");
    var fastTimers = [];
    var NOT_IN_LIST = -2;
    var TO_BE_CLEARED = -1;
    var PENDING = 0;
    var ACTIVE = 1;
    function onTick() {
      fastNow += TICK_MS;
      let idx = 0;
      let len = fastTimers.length;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer._state === PENDING) {
          timer._idleStart = fastNow - TICK_MS;
          timer._state = ACTIVE;
        } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
          timer._state = TO_BE_CLEARED;
          timer._idleStart = -1;
          timer._onTimeout(timer._timerArg);
        }
        if (timer._state === TO_BE_CLEARED) {
          timer._state = NOT_IN_LIST;
          if (--len !== 0) {
            fastTimers[idx] = fastTimers[len];
          }
        } else {
          ++idx;
        }
      }
      fastTimers.length = len;
      if (fastTimers.length !== 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTick, TICK_MS);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var FastTimer = class {
      [kFastTimer] = true;
      /**
       * The state of the timer, which can be one of the following:
       * - NOT_IN_LIST (-2)
       * - TO_BE_CLEARED (-1)
       * - PENDING (0)
       * - ACTIVE (1)
       *
       * @type {-2|-1|0|1}
       * @private
       */
      _state = NOT_IN_LIST;
      /**
       * The number of milliseconds to wait before calling the callback.
       *
       * @type {number}
       * @private
       */
      _idleTimeout = -1;
      /**
       * The time in milliseconds when the timer was started. This value is used to
       * calculate when the timer should expire.
       *
       * @type {number}
       * @default -1
       * @private
       */
      _idleStart = -1;
      /**
       * The function to be executed when the timer expires.
       * @type {Function}
       * @private
       */
      _onTimeout;
      /**
       * The argument to be passed to the callback when the timer expires.
       *
       * @type {*}
       * @private
       */
      _timerArg;
      /**
       * @constructor
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should wait
       * before the specified function or code is executed.
       * @param {*} arg
       */
      constructor(callback, delay, arg) {
        this._onTimeout = callback;
        this._idleTimeout = delay;
        this._timerArg = arg;
        this.refresh();
      }
      /**
       * Sets the timer's start time to the current time, and reschedules the timer
       * to call its callback at the previously specified duration adjusted to the
       * current time.
       * Using this on a timer that has already called its callback will reactivate
       * the timer.
       *
       * @returns {void}
       */
      refresh() {
        if (this._state === NOT_IN_LIST) {
          fastTimers.push(this);
        }
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
        this._state = PENDING;
      }
      /**
       * The `clear` method cancels the timer, preventing it from executing.
       *
       * @returns {void}
       * @private
       */
      clear() {
        this._state = TO_BE_CLEARED;
        this._idleStart = -1;
      }
    };
    module2.exports = {
      /**
       * The setTimeout() method sets a timer which executes a function once the
       * timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {NodeJS.Timeout|FastTimer}
       */
      setTimeout(callback, delay, arg) {
        return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated Timer previously created
       * by calling setTimeout.
       *
       * @param {NodeJS.Timeout|FastTimer} timeout
       */
      clearTimeout(timeout) {
        if (timeout[kFastTimer]) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      },
      /**
       * The setFastTimeout() method sets a fastTimer which executes a function once
       * the timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {FastTimer}
       */
      setFastTimeout(callback, delay, arg) {
        return new FastTimer(callback, delay, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated FastTimer previously
       * created by calling setFastTimeout.
       *
       * @param {FastTimer} timeout
       */
      clearFastTimeout(timeout) {
        timeout.clear();
      },
      /**
       * The now method returns the value of the internal fast timer clock.
       *
       * @returns {number}
       */
      now() {
        return fastNow;
      },
      /**
       * Trigger the onTick function to process the fastTimers array.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       * @param {number} [delay=0] The delay in milliseconds to add to the now value.
       */
      tick(delay = 0) {
        fastNow += delay - RESOLUTION_MS + 1;
        onTick();
        onTick();
      },
      /**
       * Reset FastTimers.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      reset() {
        fastNow = 0;
        fastTimers.length = 0;
        clearTimeout(fastNowTimeout);
        fastNowTimeout = null;
      },
      /**
       * Exporting for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      kFastTimer
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/errors.js
var require_errors2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var AbortError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "The operation was aborted";
      }
    };
    var RequestAbortedError = class extends AbortError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    var ResponseError = class extends UndiciError {
      constructor(message, code, { headers, body }) {
        super(message);
        this.name = "ResponseError";
        this.message = message || "Response error";
        this.code = "UND_ERR_RESPONSE";
        this.statusCode = code;
        this.body = body;
        this.headers = headers;
      }
    };
    var SecureProxyConnectionError = class extends UndiciError {
      constructor(cause, message, options = {}) {
        super(message, { cause, ...options });
        this.name = "SecureProxyConnectionError";
        this.message = message || "Secure Proxy Connection failed";
        this.code = "UND_ERR_PRX_TLS";
        this.cause = cause;
      }
    };
    module2.exports = {
      AbortError,
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError,
      ResponseError,
      SecureProxyConnectionError
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/constants.js"(exports2, module2) {
    "use strict";
    var wellknownHeaderNames = (
      /** @type {const} */
      [
        "Accept",
        "Accept-Encoding",
        "Accept-Language",
        "Accept-Ranges",
        "Access-Control-Allow-Credentials",
        "Access-Control-Allow-Headers",
        "Access-Control-Allow-Methods",
        "Access-Control-Allow-Origin",
        "Access-Control-Expose-Headers",
        "Access-Control-Max-Age",
        "Access-Control-Request-Headers",
        "Access-Control-Request-Method",
        "Age",
        "Allow",
        "Alt-Svc",
        "Alt-Used",
        "Authorization",
        "Cache-Control",
        "Clear-Site-Data",
        "Connection",
        "Content-Disposition",
        "Content-Encoding",
        "Content-Language",
        "Content-Length",
        "Content-Location",
        "Content-Range",
        "Content-Security-Policy",
        "Content-Security-Policy-Report-Only",
        "Content-Type",
        "Cookie",
        "Cross-Origin-Embedder-Policy",
        "Cross-Origin-Opener-Policy",
        "Cross-Origin-Resource-Policy",
        "Date",
        "Device-Memory",
        "Downlink",
        "ECT",
        "ETag",
        "Expect",
        "Expect-CT",
        "Expires",
        "Forwarded",
        "From",
        "Host",
        "If-Match",
        "If-Modified-Since",
        "If-None-Match",
        "If-Range",
        "If-Unmodified-Since",
        "Keep-Alive",
        "Last-Modified",
        "Link",
        "Location",
        "Max-Forwards",
        "Origin",
        "Permissions-Policy",
        "Pragma",
        "Proxy-Authenticate",
        "Proxy-Authorization",
        "RTT",
        "Range",
        "Referer",
        "Referrer-Policy",
        "Refresh",
        "Retry-After",
        "Sec-WebSocket-Accept",
        "Sec-WebSocket-Extensions",
        "Sec-WebSocket-Key",
        "Sec-WebSocket-Protocol",
        "Sec-WebSocket-Version",
        "Server",
        "Server-Timing",
        "Service-Worker-Allowed",
        "Service-Worker-Navigation-Preload",
        "Set-Cookie",
        "SourceMap",
        "Strict-Transport-Security",
        "Supports-Loading-Mode",
        "TE",
        "Timing-Allow-Origin",
        "Trailer",
        "Transfer-Encoding",
        "Upgrade",
        "Upgrade-Insecure-Requests",
        "User-Agent",
        "Vary",
        "Via",
        "WWW-Authenticate",
        "X-Content-Type-Options",
        "X-DNS-Prefetch-Control",
        "X-Frame-Options",
        "X-Permitted-Cross-Domain-Policies",
        "X-Powered-By",
        "X-Requested-With",
        "X-XSS-Protection"
      ]
    );
    var headerNameLowerCasedRecord = {};
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    var wellknownHeaderNameBuffers = {};
    Object.setPrototypeOf(wellknownHeaderNameBuffers, null);
    function getHeaderNameAsBuffer(header) {
      let buffer = wellknownHeaderNameBuffers[header];
      if (buffer === void 0) {
        buffer = Buffer.from(header);
      }
      return buffer;
    }
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    module2.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord,
      getHeaderNameAsBuffer
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/tree.js
var require_tree = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/tree.js"(exports2, module2) {
    "use strict";
    var {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    } = require_constants();
    var TstNode = class _TstNode {
      /** @type {any} */
      value = null;
      /** @type {null | TstNode} */
      left = null;
      /** @type {null | TstNode} */
      middle = null;
      /** @type {null | TstNode} */
      right = null;
      /** @type {number} */
      code;
      /**
       * @param {string} key
       * @param {any} value
       * @param {number} index
       */
      constructor(key, value, index) {
        if (index === void 0 || index >= key.length) {
          throw new TypeError("Unreachable");
        }
        const code = this.code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (key.length !== ++index) {
          this.middle = new _TstNode(key, value, index);
        } else {
          this.value = value;
        }
      }
      /**
       * @param {string} key
       * @param {any} value
       * @returns {void}
       */
      add(key, value) {
        const length = key.length;
        if (length === 0) {
          throw new TypeError("Unreachable");
        }
        let index = 0;
        let node = this;
        while (true) {
          const code = key.charCodeAt(index);
          if (code > 127) {
            throw new TypeError("key must be ascii string");
          }
          if (node.code === code) {
            if (length === ++index) {
              node.value = value;
              break;
            } else if (node.middle !== null) {
              node = node.middle;
            } else {
              node.middle = new _TstNode(key, value, index);
              break;
            }
          } else if (node.code < code) {
            if (node.left !== null) {
              node = node.left;
            } else {
              node.left = new _TstNode(key, value, index);
              break;
            }
          } else if (node.right !== null) {
            node = node.right;
          } else {
            node.right = new _TstNode(key, value, index);
            break;
          }
        }
      }
      /**
       * @param {Uint8Array} key
       * @return {TstNode | null}
       */
      search(key) {
        const keylength = key.length;
        let index = 0;
        let node = this;
        while (node !== null && index < keylength) {
          let code = key[index];
          if (code <= 90 && code >= 65) {
            code |= 32;
          }
          while (node !== null) {
            if (code === node.code) {
              if (keylength === ++index) {
                return node;
              }
              node = node.middle;
              break;
            }
            node = node.code < code ? node.left : node.right;
          }
        }
        return null;
      }
    };
    var TernarySearchTree = class {
      /** @type {TstNode | null} */
      node = null;
      /**
       * @param {string} key
       * @param {any} value
       * @returns {void}
       * */
      insert(key, value) {
        if (this.node === null) {
          this.node = new TstNode(key, value, 0);
        } else {
          this.node.add(key, value);
        }
      }
      /**
       * @param {Uint8Array} key
       * @returns {any}
       */
      lookup(key) {
        return this.node?.search(key)?.value ?? null;
      }
    };
    var tree = new TernarySearchTree();
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
      tree.insert(key, key);
    }
    module2.exports = {
      TernarySearchTree,
      tree
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { kDestroyed, kBodyUsed, kListeners, kBody } = require_symbols2();
    var { IncomingMessage } = require("node:http");
    var stream = require("node:stream");
    var net = require("node:net");
    var { Blob: Blob2 } = require("node:buffer");
    var nodeUtil = require("node:util");
    var { stringify } = require("node:querystring");
    var { EventEmitter: EE } = require("node:events");
    var timers = require_timers();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors2();
    var { headerNameLowerCasedRecord } = require_constants();
    var { tree } = require_tree();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".", 2).map((v) => Number(v));
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    function noop() {
    }
    function wrapRequestBody(body) {
      if (isStream(body)) {
        if (bodyLength(body) === 0) {
          body.on("data", function() {
            assert(false);
          });
        }
        if (typeof body.readableDidRead !== "boolean") {
          body[kBodyUsed] = false;
          EE.prototype.on.call(body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
        return body;
      } else if (body && typeof body.pipeTo === "function") {
        return new BodyAsyncIterable(body);
      } else if (body && typeof body !== "string" && !ArrayBuffer.isView(body) && isIterable(body)) {
        return new BodyAsyncIterable(body);
      } else {
        return body;
      }
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      if (object === null) {
        return false;
      } else if (object instanceof Blob2) {
        return true;
      } else if (typeof object !== "object") {
        return false;
      } else {
        const sTag = object[Symbol.toStringTag];
        return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
      }
    }
    function serializePathWithQuery(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function isValidPort(port) {
      const value = parseInt(port, 10);
      return value === Number(port) && value >= 0 && value <= 65535;
    }
    function isHttpOrHttpsPrefixed(value) {
      return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin[origin.length - 1] === "/") {
          origin = origin.slice(0, origin.length - 1);
        }
        if (path && path[0] !== "/") {
          path = `/${path}`;
        }
        return new URL(`${origin}${path}`);
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert(typeof host === "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(body) {
      return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        queueMicrotask(() => {
          stream2.emit("error", err);
        });
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function bufferToLowerCasedHeaderName(value) {
      return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function parseHeaders(headers, obj) {
      if (obj === void 0) obj = {};
      for (let i = 0; i < headers.length; i += 2) {
        const key = headerNameToString(headers[i]);
        let val = obj[key];
        if (val) {
          if (typeof val === "string") {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        } else {
          const headersValue = headers[i + 1];
          if (typeof headersValue === "string") {
            obj[key] = headersValue;
          } else {
            obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
          }
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const headersLength = headers.length;
      const ret = new Array(headersLength);
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      let key;
      let val;
      let kLen = 0;
      for (let n = 0; n < headersLength; n += 2) {
        key = headers[n];
        val = headers[n + 1];
        typeof key !== "string" && (key = key.toString());
        typeof val !== "string" && (val = val.toString("utf8"));
        kLen = key.length;
        if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
          hasContentLength = true;
        } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = n + 1;
        }
        ret[n] = key;
        ret[n + 1] = val;
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function encodeRawHeaders(headers) {
      if (!Array.isArray(headers)) {
        throw new TypeError("expected headers to be an array");
      }
      return headers.map((x) => Buffer.from(x));
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function assertRequestHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onRequestStart === "function") {
        return;
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    function ReadableStreamFrom(iterable) {
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          pull(controller) {
            async function pull() {
              const { done, value } = await iterator.next();
              if (done) {
                queueMicrotask(() => {
                  controller.close();
                  controller.byobRequest?.respond(0);
                });
              } else {
                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                if (buf.byteLength) {
                  controller.enqueue(new Uint8Array(buf));
                } else {
                  return await pull();
                }
              }
            }
            return pull();
          },
          async cancel() {
            await iterator.return();
          },
          type: "bytes"
        }
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.once("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var toUSVString = (() => {
      if (typeof String.prototype.toWellFormed === "function") {
        return (value) => `${value}`.toWellFormed();
      } else {
        return nodeUtil.toUSVString;
      }
    })();
    var isUSVString = (() => {
      if (typeof String.prototype.isWellFormed === "function") {
        return (value) => `${value}`.isWellFormed();
      } else {
        return (value) => toUSVString(value) === `${value}`;
      }
    })();
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function isValidHeaderValue(characters) {
      return !headerCharRegex.test(characters);
    }
    var rangeHeaderRegex = /^bytes (\d+)-(\d+)\/(\d+)?$/;
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(rangeHeaderRegex) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    function addListener(obj, name, listener) {
      const listeners = obj[kListeners] ??= [];
      listeners.push([name, listener]);
      obj.on(name, listener);
      return obj;
    }
    function removeAllListeners(obj) {
      if (obj[kListeners] != null) {
        for (const [name, listener] of obj[kListeners]) {
          obj.removeListener(name, listener);
        }
        obj[kListeners] = null;
      }
      return obj;
    }
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop;
      }
      let s1 = null;
      let s2 = null;
      const fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
        });
      }, opts.timeout);
      return () => {
        timers.clearFastTimeout(fastTimer);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    } : (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop;
      }
      let s1 = null;
      const fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          onConnectTimeout(socketWeakRef.deref(), opts);
        });
      }, opts.timeout);
      return () => {
        timers.clearFastTimeout(fastTimer);
        clearImmediate(s1);
      };
    };
    function onConnectTimeout(socket, opts) {
      if (socket == null) {
        return;
      }
      let message = "Connect Timeout Error";
      if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
        message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
      } else {
        message += ` (attempted address: ${opts.hostname}:${opts.port},`;
      }
      message += ` timeout: ${opts.timeout}ms)`;
      destroy(socket, new ConnectTimeoutError(message));
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    var normalizedMethodRecordsBase = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    var normalizedMethodRecords = {
      ...normalizedMethodRecordsBase,
      patch: "patch",
      PATCH: "PATCH"
    };
    Object.setPrototypeOf(normalizedMethodRecordsBase, null);
    Object.setPrototypeOf(normalizedMethodRecords, null);
    module2.exports = {
      kEnumerableProperty,
      isDisturbed,
      toUSVString,
      isUSVString,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      bufferToLowerCasedHeaderName,
      addListener,
      removeAllListeners,
      errorRequest,
      parseRawHeaders,
      encodeRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      assertRequestHandler,
      getSocketInfo,
      isFormDataLike,
      serializePathWithQuery,
      addAbortListener,
      isValidHTTPToken,
      isValidHeaderValue,
      isTokenCharCode,
      parseRangeHeader,
      normalizedMethodRecordsBase,
      normalizedMethodRecords,
      isValidPort,
      isHttpOrHttpsPrefixed,
      nodeMajor,
      nodeMinor,
      safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]),
      wrapRequestBody,
      setupConnectTimeout
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/util/stats.js
var require_stats = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/util/stats.js"(exports2, module2) {
    "use strict";
    var {
      kConnected,
      kPending,
      kRunning,
      kSize,
      kFree,
      kQueued
    } = require_symbols2();
    var ClientStats = class {
      constructor(client) {
        this.connected = client[kConnected];
        this.pending = client[kPending];
        this.running = client[kRunning];
        this.size = client[kSize];
      }
    };
    var PoolStats = class {
      constructor(pool) {
        this.connected = pool[kConnected];
        this.free = pool[kFree];
        this.pending = pool[kPending];
        this.queued = pool[kQueued];
        this.running = pool[kRunning];
        this.size = pool[kSize];
      }
    };
    module2.exports = { ClientStats, PoolStats };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/diagnostics.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require("node:diagnostics_channel");
    var util = require("node:util");
    var undiciDebugLog = util.debuglog("undici");
    var fetchDebuglog = util.debuglog("fetch");
    var websocketDebuglog = util.debuglog("websocket");
    var channels = {
      // Client
      beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
      connected: diagnosticsChannel.channel("undici:client:connected"),
      connectError: diagnosticsChannel.channel("undici:client:connectError"),
      sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
      // Request
      create: diagnosticsChannel.channel("undici:request:create"),
      bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
      headers: diagnosticsChannel.channel("undici:request:headers"),
      trailers: diagnosticsChannel.channel("undici:request:trailers"),
      error: diagnosticsChannel.channel("undici:request:error"),
      // WebSocket
      open: diagnosticsChannel.channel("undici:websocket:open"),
      close: diagnosticsChannel.channel("undici:websocket:close"),
      socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
      ping: diagnosticsChannel.channel("undici:websocket:ping"),
      pong: diagnosticsChannel.channel("undici:websocket:pong")
    };
    var isTrackingClientEvents = false;
    function trackClientEvents(debugLog = undiciDebugLog) {
      if (isTrackingClientEvents) {
        return;
      }
      isTrackingClientEvents = true;
      diagnosticsChannel.subscribe(
        "undici:client:beforeConnect",
        (evt) => {
          const {
            connectParams: { version, protocol, port, host }
          } = evt;
          debugLog(
            "connecting to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:connected",
        (evt) => {
          const {
            connectParams: { version, protocol, port, host }
          } = evt;
          debugLog(
            "connected to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:connectError",
        (evt) => {
          const {
            connectParams: { version, protocol, port, host },
            error
          } = evt;
          debugLog(
            "connection to %s%s using %s%s errored - %s",
            host,
            port ? `:${port}` : "",
            protocol,
            version,
            error.message
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:sendHeaders",
        (evt) => {
          const {
            request: { method, path, origin }
          } = evt;
          debugLog("sending request to %s %s/%s", method, origin, path);
        }
      );
    }
    var isTrackingRequestEvents = false;
    function trackRequestEvents(debugLog = undiciDebugLog) {
      if (isTrackingRequestEvents) {
        return;
      }
      isTrackingRequestEvents = true;
      diagnosticsChannel.subscribe(
        "undici:request:headers",
        (evt) => {
          const {
            request: { method, path, origin },
            response: { statusCode }
          } = evt;
          debugLog(
            "received response to %s %s/%s - HTTP %d",
            method,
            origin,
            path,
            statusCode
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:request:trailers",
        (evt) => {
          const {
            request: { method, path, origin }
          } = evt;
          debugLog("trailers received from %s %s/%s", method, origin, path);
        }
      );
      diagnosticsChannel.subscribe(
        "undici:request:error",
        (evt) => {
          const {
            request: { method, path, origin },
            error
          } = evt;
          debugLog(
            "request to %s %s/%s errored - %s",
            method,
            origin,
            path,
            error.message
          );
        }
      );
    }
    var isTrackingWebSocketEvents = false;
    function trackWebSocketEvents(debugLog = websocketDebuglog) {
      if (isTrackingWebSocketEvents) {
        return;
      }
      isTrackingWebSocketEvents = true;
      diagnosticsChannel.subscribe(
        "undici:websocket:open",
        (evt) => {
          const {
            address: { address, port }
          } = evt;
          debugLog("connection opened %s%s", address, port ? `:${port}` : "");
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:close",
        (evt) => {
          const { websocket, code, reason } = evt;
          debugLog(
            "closed connection to %s - %s %s",
            websocket.url,
            code,
            reason
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:socket_error",
        (err) => {
          debugLog("connection errored - %s", err.message);
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:ping",
        (evt) => {
          debugLog("ping received");
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:pong",
        (evt) => {
          debugLog("pong received");
        }
      );
    }
    if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
      trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
      trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
    }
    if (websocketDebuglog.enabled) {
      trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog);
      trackWebSocketEvents(websocketDebuglog);
    }
    module2.exports = {
      channels
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors2();
    var assert = require("node:assert");
    var {
      isValidHTTPToken,
      isValidHeaderValue,
      isStream,
      destroy,
      isBuffer,
      isFormDataLike,
      isIterable,
      isBlobLike,
      serializePathWithQuery,
      assertRequestHandler,
      getServerName,
      normalizedMethodRecords
    } = require_util();
    var { channels } = require_diagnostics();
    var { headerNameLowerCasedRecord } = require_constants();
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var Request = class {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        expectContinue,
        servername,
        throwOnError
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.test(path)) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        if (throwOnError != null) {
          throw new InvalidArgumentError("invalid throwOnError");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? serializePathWithQuery(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking ?? this.method !== "HEAD";
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = [];
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          if (headers[Symbol.iterator]) {
            for (const header of headers) {
              if (!Array.isArray(header) || header.length !== 2) {
                throw new InvalidArgumentError("headers must be in key-value pair format");
              }
              processHeader(this, header[0], header[1]);
            }
          } else {
            const keys = Object.keys(headers);
            for (let i = 0; i < keys.length; ++i) {
              processHeader(this, keys[i], headers[keys[i]]);
            }
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        assertRequestHandler(handler, method, upgrade);
        this.servername = servername || getServerName(this.host) || null;
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onResponseStarted() {
        return this[kHandler].onResponseStarted?.();
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        assert(!this.completed);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
    };
    function processHeader(request, key, val) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      let headerName = headerNameLowerCasedRecord[key];
      if (headerName === void 0) {
        headerName = key.toLowerCase();
        if (headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName)) {
          throw new InvalidArgumentError("invalid header key");
        }
      }
      if (Array.isArray(val)) {
        const arr = [];
        for (let i = 0; i < val.length; i++) {
          if (typeof val[i] === "string") {
            if (!isValidHeaderValue(val[i])) {
              throw new InvalidArgumentError(`invalid ${key} header`);
            }
            arr.push(val[i]);
          } else if (val[i] === null) {
            arr.push("");
          } else if (typeof val[i] === "object") {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else {
            arr.push(`${val[i]}`);
          }
        }
        val = arr;
      } else if (typeof val === "string") {
        if (!isValidHeaderValue(val)) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
      } else if (val === null) {
        val = "";
      } else {
        val = `${val}`;
      }
      if (request.host === null && headerName === "host") {
        if (typeof val !== "string") {
          throw new InvalidArgumentError("invalid host header");
        }
        request.host = val;
      } else if (request.contentLength === null && headerName === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && headerName === "content-type") {
        request.contentType = val;
        request.headers.push(key, val);
      } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
        throw new InvalidArgumentError(`invalid ${headerName} header`);
      } else if (headerName === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        }
        if (value === "close") {
          request.reset = true;
        }
      } else if (headerName === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else {
        request.headers.push(key, val);
      }
    }
    module2.exports = Request;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/handler/wrap-handler.js
var require_wrap_handler = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/handler/wrap-handler.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors2();
    module2.exports = class WrapHandler {
      #handler;
      constructor(handler) {
        this.#handler = handler;
      }
      static wrap(handler) {
        return handler.onRequestStart ? handler : new WrapHandler(handler);
      }
      // Unwrap Interface
      onConnect(abort, context2) {
        return this.#handler.onConnect?.(abort, context2);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        return this.#handler.onHeaders?.(statusCode, rawHeaders, resume, statusMessage);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
      }
      onData(data) {
        return this.#handler.onData?.(data);
      }
      onComplete(trailers) {
        return this.#handler.onComplete?.(trailers);
      }
      onError(err) {
        if (!this.#handler.onError) {
          throw err;
        }
        return this.#handler.onError?.(err);
      }
      // Wrap Interface
      onRequestStart(controller, context2) {
        this.#handler.onConnect?.((reason) => controller.abort(reason), context2);
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        const rawHeaders = [];
        for (const [key, val] of Object.entries(headers)) {
          rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
        }
        this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        const rawHeaders = [];
        for (const [key, val] of Object.entries(headers)) {
          rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
        }
        if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {
          controller.pause();
        }
      }
      onResponseData(controller, data) {
        if (this.#handler.onData?.(data) === false) {
          controller.pause();
        }
      }
      onResponseEnd(controller, trailers) {
        const rawTrailers = [];
        for (const [key, val] of Object.entries(trailers)) {
          rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
        }
        this.#handler.onComplete?.(rawTrailers);
      }
      onResponseError(controller, err) {
        if (!this.#handler.onError) {
          throw new InvalidArgumentError("invalid onError method");
        }
        this.#handler.onError?.(err);
      }
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("node:events");
    var WrapHandler = require_wrap_handler();
    var wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler));
    var Dispatcher = class extends EventEmitter2 {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
      compose(...args) {
        const interceptors = Array.isArray(args[0]) ? args[0] : args;
        let dispatch = this.dispatch.bind(this);
        for (const interceptor of interceptors) {
          if (interceptor == null) {
            continue;
          }
          if (typeof interceptor !== "function") {
            throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
          }
          dispatch = interceptor(dispatch);
          dispatch = wrapInterceptor(dispatch);
          if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
            throw new TypeError("invalid interceptor");
          }
        }
        return new Proxy(this, {
          get: (target, key) => key === "dispatch" ? dispatch : target[key]
        });
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/handler/unwrap-handler.js
var require_unwrap_handler = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/handler/unwrap-handler.js"(exports2, module2) {
    "use strict";
    var { parseHeaders } = require_util();
    var { InvalidArgumentError } = require_errors2();
    var kResume = Symbol("resume");
    var UnwrapController = class {
      #paused = false;
      #reason = null;
      #aborted = false;
      #abort;
      [kResume] = null;
      constructor(abort) {
        this.#abort = abort;
      }
      pause() {
        this.#paused = true;
      }
      resume() {
        if (this.#paused) {
          this.#paused = false;
          this[kResume]?.();
        }
      }
      abort(reason) {
        if (!this.#aborted) {
          this.#aborted = true;
          this.#reason = reason;
          this.#abort(reason);
        }
      }
      get aborted() {
        return this.#aborted;
      }
      get reason() {
        return this.#reason;
      }
      get paused() {
        return this.#paused;
      }
    };
    module2.exports = class UnwrapHandler {
      #handler;
      #controller;
      constructor(handler) {
        this.#handler = handler;
      }
      static unwrap(handler) {
        return !handler.onRequestStart ? handler : new UnwrapHandler(handler);
      }
      onConnect(abort, context2) {
        this.#controller = new UnwrapController(abort);
        this.#handler.onRequestStart?.(this.#controller, context2);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders(rawHeaders), socket);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        this.#controller[kResume] = resume;
        this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders(rawHeaders), statusMessage);
        return !this.#controller.paused;
      }
      onData(data) {
        this.#handler.onResponseData?.(this.#controller, data);
        return !this.#controller.paused;
      }
      onComplete(rawTrailers) {
        this.#handler.onResponseEnd?.(this.#controller, parseHeaders(rawTrailers));
      }
      onError(err) {
        if (!this.#handler.onResponseError) {
          throw new InvalidArgumentError("invalid onError method");
        }
        this.#handler.onResponseError?.(this.#controller, err);
      }
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var UnwrapHandler = require_unwrap_handler();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors2();
    var { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = require_symbols2();
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        handler = UnwrapHandler.unwrap(handler);
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw err;
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("node:net");
    var assert = require("node:assert");
    var util = require_util();
    var { InvalidArgumentError } = require_errors2();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("node:tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          assert(sessionKey);
          const session = customSession || sessionCache.get(sessionKey) || null;
          port = port || 443;
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          port = port || 80;
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const clearConnectTimeout = util.setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    module2.exports = buildConnector;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj, filter = [], exceptions = []) {
      var _a, _b;
      const emptyFilter = ((_a = filter === null || filter === void 0 ? void 0 : filter.length) !== null && _a !== void 0 ? _a : 0) === 0;
      const emptyExceptions = ((_b = exceptions === null || exceptions === void 0 ? void 0 : exceptions.length) !== null && _b !== void 0 ? _b : 0) === 0;
      return Object.fromEntries(Object.entries(obj).filter(([, value]) => {
        return typeof value === "number" && (emptyFilter || filter.includes(value)) && (emptyExceptions || !exceptions.includes(value));
      }));
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.MINOR = exports2.MAJOR = exports2.HTAB_SP_VCHAR_OBS_TEXT = exports2.QUOTED_STRING = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.STATUSES_HTTP = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.HEADER_STATE = exports2.FINISH = exports2.STATUSES = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils();
    exports2.ERROR = {
      OK: 0,
      INTERNAL: 1,
      STRICT: 2,
      CR_EXPECTED: 25,
      LF_EXPECTED: 3,
      UNEXPECTED_CONTENT_LENGTH: 4,
      UNEXPECTED_SPACE: 30,
      CLOSED_CONNECTION: 5,
      INVALID_METHOD: 6,
      INVALID_URL: 7,
      INVALID_CONSTANT: 8,
      INVALID_VERSION: 9,
      INVALID_HEADER_TOKEN: 10,
      INVALID_CONTENT_LENGTH: 11,
      INVALID_CHUNK_SIZE: 12,
      INVALID_STATUS: 13,
      INVALID_EOF_STATE: 14,
      INVALID_TRANSFER_ENCODING: 15,
      CB_MESSAGE_BEGIN: 16,
      CB_HEADERS_COMPLETE: 17,
      CB_MESSAGE_COMPLETE: 18,
      CB_CHUNK_HEADER: 19,
      CB_CHUNK_COMPLETE: 20,
      PAUSED: 21,
      PAUSED_UPGRADE: 22,
      PAUSED_H2_UPGRADE: 23,
      USER: 24,
      CB_URL_COMPLETE: 26,
      CB_STATUS_COMPLETE: 27,
      CB_METHOD_COMPLETE: 32,
      CB_VERSION_COMPLETE: 33,
      CB_HEADER_FIELD_COMPLETE: 28,
      CB_HEADER_VALUE_COMPLETE: 29,
      CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,
      CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,
      CB_RESET: 31
    };
    exports2.TYPE = {
      BOTH: 0,
      // default
      REQUEST: 1,
      RESPONSE: 2
    };
    exports2.FLAGS = {
      CONNECTION_KEEP_ALIVE: 1 << 0,
      CONNECTION_CLOSE: 1 << 1,
      CONNECTION_UPGRADE: 1 << 2,
      CHUNKED: 1 << 3,
      UPGRADE: 1 << 4,
      CONTENT_LENGTH: 1 << 5,
      SKIPBODY: 1 << 6,
      TRAILING: 1 << 7,
      // 1 << 8 is unused
      TRANSFER_ENCODING: 1 << 9
    };
    exports2.LENIENT_FLAGS = {
      HEADERS: 1 << 0,
      CHUNKED_LENGTH: 1 << 1,
      KEEP_ALIVE: 1 << 2,
      TRANSFER_ENCODING: 1 << 3,
      VERSION: 1 << 4,
      DATA_AFTER_CLOSE: 1 << 5,
      OPTIONAL_LF_AFTER_CR: 1 << 6,
      OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,
      OPTIONAL_CR_BEFORE_LF: 1 << 8,
      SPACES_AFTER_CHUNK_SIZE: 1 << 9
    };
    exports2.METHODS = {
      "DELETE": 0,
      "GET": 1,
      "HEAD": 2,
      "POST": 3,
      "PUT": 4,
      /* pathological */
      "CONNECT": 5,
      "OPTIONS": 6,
      "TRACE": 7,
      /* WebDAV */
      "COPY": 8,
      "LOCK": 9,
      "MKCOL": 10,
      "MOVE": 11,
      "PROPFIND": 12,
      "PROPPATCH": 13,
      "SEARCH": 14,
      "UNLOCK": 15,
      "BIND": 16,
      "REBIND": 17,
      "UNBIND": 18,
      "ACL": 19,
      /* subversion */
      "REPORT": 20,
      "MKACTIVITY": 21,
      "CHECKOUT": 22,
      "MERGE": 23,
      /* upnp */
      "M-SEARCH": 24,
      "NOTIFY": 25,
      "SUBSCRIBE": 26,
      "UNSUBSCRIBE": 27,
      /* RFC-5789 */
      "PATCH": 28,
      "PURGE": 29,
      /* CalDAV */
      "MKCALENDAR": 30,
      /* RFC-2068, section 19.6.1.2 */
      "LINK": 31,
      "UNLINK": 32,
      /* icecast */
      "SOURCE": 33,
      /* RFC-7540, section 11.6 */
      "PRI": 34,
      /* RFC-2326 RTSP */
      "DESCRIBE": 35,
      "ANNOUNCE": 36,
      "SETUP": 37,
      "PLAY": 38,
      "PAUSE": 39,
      "TEARDOWN": 40,
      "GET_PARAMETER": 41,
      "SET_PARAMETER": 42,
      "REDIRECT": 43,
      "RECORD": 44,
      /* RAOP */
      "FLUSH": 45,
      /* DRAFT https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html */
      "QUERY": 46
    };
    exports2.STATUSES = {
      CONTINUE: 100,
      SWITCHING_PROTOCOLS: 101,
      PROCESSING: 102,
      EARLY_HINTS: 103,
      RESPONSE_IS_STALE: 110,
      // Unofficial
      REVALIDATION_FAILED: 111,
      // Unofficial
      DISCONNECTED_OPERATION: 112,
      // Unofficial
      HEURISTIC_EXPIRATION: 113,
      // Unofficial
      MISCELLANEOUS_WARNING: 199,
      // Unofficial
      OK: 200,
      CREATED: 201,
      ACCEPTED: 202,
      NON_AUTHORITATIVE_INFORMATION: 203,
      NO_CONTENT: 204,
      RESET_CONTENT: 205,
      PARTIAL_CONTENT: 206,
      MULTI_STATUS: 207,
      ALREADY_REPORTED: 208,
      TRANSFORMATION_APPLIED: 214,
      // Unofficial
      IM_USED: 226,
      MISCELLANEOUS_PERSISTENT_WARNING: 299,
      // Unofficial
      MULTIPLE_CHOICES: 300,
      MOVED_PERMANENTLY: 301,
      FOUND: 302,
      SEE_OTHER: 303,
      NOT_MODIFIED: 304,
      USE_PROXY: 305,
      SWITCH_PROXY: 306,
      // No longer used
      TEMPORARY_REDIRECT: 307,
      PERMANENT_REDIRECT: 308,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      PAYMENT_REQUIRED: 402,
      FORBIDDEN: 403,
      NOT_FOUND: 404,
      METHOD_NOT_ALLOWED: 405,
      NOT_ACCEPTABLE: 406,
      PROXY_AUTHENTICATION_REQUIRED: 407,
      REQUEST_TIMEOUT: 408,
      CONFLICT: 409,
      GONE: 410,
      LENGTH_REQUIRED: 411,
      PRECONDITION_FAILED: 412,
      PAYLOAD_TOO_LARGE: 413,
      URI_TOO_LONG: 414,
      UNSUPPORTED_MEDIA_TYPE: 415,
      RANGE_NOT_SATISFIABLE: 416,
      EXPECTATION_FAILED: 417,
      IM_A_TEAPOT: 418,
      PAGE_EXPIRED: 419,
      // Unofficial
      ENHANCE_YOUR_CALM: 420,
      // Unofficial
      MISDIRECTED_REQUEST: 421,
      UNPROCESSABLE_ENTITY: 422,
      LOCKED: 423,
      FAILED_DEPENDENCY: 424,
      TOO_EARLY: 425,
      UPGRADE_REQUIRED: 426,
      PRECONDITION_REQUIRED: 428,
      TOO_MANY_REQUESTS: 429,
      REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430,
      // Unofficial
      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
      LOGIN_TIMEOUT: 440,
      // Unofficial
      NO_RESPONSE: 444,
      // Unofficial
      RETRY_WITH: 449,
      // Unofficial
      BLOCKED_BY_PARENTAL_CONTROL: 450,
      // Unofficial
      UNAVAILABLE_FOR_LEGAL_REASONS: 451,
      CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460,
      // Unofficial
      INVALID_X_FORWARDED_FOR: 463,
      // Unofficial
      REQUEST_HEADER_TOO_LARGE: 494,
      // Unofficial
      SSL_CERTIFICATE_ERROR: 495,
      // Unofficial
      SSL_CERTIFICATE_REQUIRED: 496,
      // Unofficial
      HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497,
      // Unofficial
      INVALID_TOKEN: 498,
      // Unofficial
      CLIENT_CLOSED_REQUEST: 499,
      // Unofficial
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501,
      BAD_GATEWAY: 502,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      HTTP_VERSION_NOT_SUPPORTED: 505,
      VARIANT_ALSO_NEGOTIATES: 506,
      INSUFFICIENT_STORAGE: 507,
      LOOP_DETECTED: 508,
      BANDWIDTH_LIMIT_EXCEEDED: 509,
      NOT_EXTENDED: 510,
      NETWORK_AUTHENTICATION_REQUIRED: 511,
      WEB_SERVER_UNKNOWN_ERROR: 520,
      // Unofficial
      WEB_SERVER_IS_DOWN: 521,
      // Unofficial
      CONNECTION_TIMEOUT: 522,
      // Unofficial
      ORIGIN_IS_UNREACHABLE: 523,
      // Unofficial
      TIMEOUT_OCCURED: 524,
      // Unofficial
      SSL_HANDSHAKE_FAILED: 525,
      // Unofficial
      INVALID_SSL_CERTIFICATE: 526,
      // Unofficial
      RAILGUN_ERROR: 527,
      // Unofficial
      SITE_IS_OVERLOADED: 529,
      // Unofficial
      SITE_IS_FROZEN: 530,
      // Unofficial
      IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561,
      // Unofficial
      NETWORK_READ_TIMEOUT: 598,
      // Unofficial
      NETWORK_CONNECT_TIMEOUT: 599
      // Unofficial
    };
    exports2.FINISH = {
      SAFE: 0,
      SAFE_WITH_CB: 1,
      UNSAFE: 2
    };
    exports2.HEADER_STATE = {
      GENERAL: 0,
      CONNECTION: 1,
      CONTENT_LENGTH: 2,
      TRANSFER_ENCODING: 3,
      UPGRADE: 4,
      CONNECTION_KEEP_ALIVE: 5,
      CONNECTION_CLOSE: 6,
      CONNECTION_UPGRADE: 7,
      TRANSFER_ENCODING_CHUNKED: 8
    };
    exports2.METHODS_HTTP = [
      exports2.METHODS.DELETE,
      exports2.METHODS.GET,
      exports2.METHODS.HEAD,
      exports2.METHODS.POST,
      exports2.METHODS.PUT,
      exports2.METHODS.CONNECT,
      exports2.METHODS.OPTIONS,
      exports2.METHODS.TRACE,
      exports2.METHODS.COPY,
      exports2.METHODS.LOCK,
      exports2.METHODS.MKCOL,
      exports2.METHODS.MOVE,
      exports2.METHODS.PROPFIND,
      exports2.METHODS.PROPPATCH,
      exports2.METHODS.SEARCH,
      exports2.METHODS.UNLOCK,
      exports2.METHODS.BIND,
      exports2.METHODS.REBIND,
      exports2.METHODS.UNBIND,
      exports2.METHODS.ACL,
      exports2.METHODS.REPORT,
      exports2.METHODS.MKACTIVITY,
      exports2.METHODS.CHECKOUT,
      exports2.METHODS.MERGE,
      exports2.METHODS["M-SEARCH"],
      exports2.METHODS.NOTIFY,
      exports2.METHODS.SUBSCRIBE,
      exports2.METHODS.UNSUBSCRIBE,
      exports2.METHODS.PATCH,
      exports2.METHODS.PURGE,
      exports2.METHODS.MKCALENDAR,
      exports2.METHODS.LINK,
      exports2.METHODS.UNLINK,
      exports2.METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      exports2.METHODS.SOURCE,
      exports2.METHODS.QUERY
    ];
    exports2.METHODS_ICE = [
      exports2.METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      exports2.METHODS.OPTIONS,
      exports2.METHODS.DESCRIBE,
      exports2.METHODS.ANNOUNCE,
      exports2.METHODS.SETUP,
      exports2.METHODS.PLAY,
      exports2.METHODS.PAUSE,
      exports2.METHODS.TEARDOWN,
      exports2.METHODS.GET_PARAMETER,
      exports2.METHODS.SET_PARAMETER,
      exports2.METHODS.REDIRECT,
      exports2.METHODS.RECORD,
      exports2.METHODS.FLUSH,
      // For AirPlay
      exports2.METHODS.GET,
      exports2.METHODS.POST
    ];
    exports2.METHOD_MAP = (0, utils_1.enumToMap)(exports2.METHODS);
    exports2.H_METHOD_MAP = Object.fromEntries(Object.entries(exports2.METHODS).filter(([k]) => k.startsWith("H")));
    exports2.STATUSES_HTTP = [
      exports2.STATUSES.CONTINUE,
      exports2.STATUSES.SWITCHING_PROTOCOLS,
      exports2.STATUSES.PROCESSING,
      exports2.STATUSES.EARLY_HINTS,
      exports2.STATUSES.RESPONSE_IS_STALE,
      exports2.STATUSES.REVALIDATION_FAILED,
      exports2.STATUSES.DISCONNECTED_OPERATION,
      exports2.STATUSES.HEURISTIC_EXPIRATION,
      exports2.STATUSES.MISCELLANEOUS_WARNING,
      exports2.STATUSES.OK,
      exports2.STATUSES.CREATED,
      exports2.STATUSES.ACCEPTED,
      exports2.STATUSES.NON_AUTHORITATIVE_INFORMATION,
      exports2.STATUSES.NO_CONTENT,
      exports2.STATUSES.RESET_CONTENT,
      exports2.STATUSES.PARTIAL_CONTENT,
      exports2.STATUSES.MULTI_STATUS,
      exports2.STATUSES.ALREADY_REPORTED,
      exports2.STATUSES.TRANSFORMATION_APPLIED,
      exports2.STATUSES.IM_USED,
      exports2.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,
      exports2.STATUSES.MULTIPLE_CHOICES,
      exports2.STATUSES.MOVED_PERMANENTLY,
      exports2.STATUSES.FOUND,
      exports2.STATUSES.SEE_OTHER,
      exports2.STATUSES.NOT_MODIFIED,
      exports2.STATUSES.USE_PROXY,
      exports2.STATUSES.SWITCH_PROXY,
      exports2.STATUSES.TEMPORARY_REDIRECT,
      exports2.STATUSES.PERMANENT_REDIRECT,
      exports2.STATUSES.BAD_REQUEST,
      exports2.STATUSES.UNAUTHORIZED,
      exports2.STATUSES.PAYMENT_REQUIRED,
      exports2.STATUSES.FORBIDDEN,
      exports2.STATUSES.NOT_FOUND,
      exports2.STATUSES.METHOD_NOT_ALLOWED,
      exports2.STATUSES.NOT_ACCEPTABLE,
      exports2.STATUSES.PROXY_AUTHENTICATION_REQUIRED,
      exports2.STATUSES.REQUEST_TIMEOUT,
      exports2.STATUSES.CONFLICT,
      exports2.STATUSES.GONE,
      exports2.STATUSES.LENGTH_REQUIRED,
      exports2.STATUSES.PRECONDITION_FAILED,
      exports2.STATUSES.PAYLOAD_TOO_LARGE,
      exports2.STATUSES.URI_TOO_LONG,
      exports2.STATUSES.UNSUPPORTED_MEDIA_TYPE,
      exports2.STATUSES.RANGE_NOT_SATISFIABLE,
      exports2.STATUSES.EXPECTATION_FAILED,
      exports2.STATUSES.IM_A_TEAPOT,
      exports2.STATUSES.PAGE_EXPIRED,
      exports2.STATUSES.ENHANCE_YOUR_CALM,
      exports2.STATUSES.MISDIRECTED_REQUEST,
      exports2.STATUSES.UNPROCESSABLE_ENTITY,
      exports2.STATUSES.LOCKED,
      exports2.STATUSES.FAILED_DEPENDENCY,
      exports2.STATUSES.TOO_EARLY,
      exports2.STATUSES.UPGRADE_REQUIRED,
      exports2.STATUSES.PRECONDITION_REQUIRED,
      exports2.STATUSES.TOO_MANY_REQUESTS,
      exports2.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,
      exports2.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,
      exports2.STATUSES.LOGIN_TIMEOUT,
      exports2.STATUSES.NO_RESPONSE,
      exports2.STATUSES.RETRY_WITH,
      exports2.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,
      exports2.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,
      exports2.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,
      exports2.STATUSES.INVALID_X_FORWARDED_FOR,
      exports2.STATUSES.REQUEST_HEADER_TOO_LARGE,
      exports2.STATUSES.SSL_CERTIFICATE_ERROR,
      exports2.STATUSES.SSL_CERTIFICATE_REQUIRED,
      exports2.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,
      exports2.STATUSES.INVALID_TOKEN,
      exports2.STATUSES.CLIENT_CLOSED_REQUEST,
      exports2.STATUSES.INTERNAL_SERVER_ERROR,
      exports2.STATUSES.NOT_IMPLEMENTED,
      exports2.STATUSES.BAD_GATEWAY,
      exports2.STATUSES.SERVICE_UNAVAILABLE,
      exports2.STATUSES.GATEWAY_TIMEOUT,
      exports2.STATUSES.HTTP_VERSION_NOT_SUPPORTED,
      exports2.STATUSES.VARIANT_ALSO_NEGOTIATES,
      exports2.STATUSES.INSUFFICIENT_STORAGE,
      exports2.STATUSES.LOOP_DETECTED,
      exports2.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,
      exports2.STATUSES.NOT_EXTENDED,
      exports2.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,
      exports2.STATUSES.WEB_SERVER_UNKNOWN_ERROR,
      exports2.STATUSES.WEB_SERVER_IS_DOWN,
      exports2.STATUSES.CONNECTION_TIMEOUT,
      exports2.STATUSES.ORIGIN_IS_UNREACHABLE,
      exports2.STATUSES.TIMEOUT_OCCURED,
      exports2.STATUSES.SSL_HANDSHAKE_FAILED,
      exports2.STATUSES.INVALID_SSL_CERTIFICATE,
      exports2.STATUSES.RAILGUN_ERROR,
      exports2.STATUSES.SITE_IS_OVERLOADED,
      exports2.STATUSES.SITE_IS_FROZEN,
      exports2.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,
      exports2.STATUSES.NETWORK_READ_TIMEOUT,
      exports2.STATUSES.NETWORK_CONNECT_TIMEOUT
    ];
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.QUOTED_STRING = ["	", " "];
    for (let i = 33; i <= 255; i++) {
      if (i !== 34 && i !== 92) {
        exports2.QUOTED_STRING.push(i);
      }
    }
    exports2.HTAB_SP_VCHAR_OBS_TEXT = ["	", " "];
    for (let i = 33; i <= 126; i++) {
      exports2.HTAB_SP_VCHAR_OBS_TEXT.push(i);
    }
    for (let i = 128; i <= 255; i++) {
      exports2.HTAB_SP_VCHAR_OBS_TEXT.push(i);
    }
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    exports2.SPECIAL_HEADERS = {
      "connection": exports2.HEADER_STATE.CONNECTION,
      "content-length": exports2.HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": exports2.HEADER_STATE.CONNECTION,
      "transfer-encoding": exports2.HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": exports2.HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("node:buffer");
    var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMAq8ywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB7AE2AhwLBgAgABA5C5otAQt/IwBBEGsiCiQAQZjUACgCACIJRQRAQdjXACgCACIFRQRAQeTXAEJ/NwIAQdzXAEKAgISAgIDAADcCAEHY1wAgCkEIakFwcUHYqtWqBXMiBTYCAEHs1wBBADYCAEG81wBBADYCAAtBwNcAQYDYBDYCAEGQ1ABBgNgENgIAQaTUACAFNgIAQaDUAEF/NgIAQcTXAEGAqAM2AgADQCABQbzUAGogAUGw1ABqIgI2AgAgAiABQajUAGoiAzYCACABQbTUAGogAzYCACABQcTUAGogAUG41ABqIgM2AgAgAyACNgIAIAFBzNQAaiABQcDUAGoiAjYCACACIAM2AgAgAUHI1ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM2ARBwacDNgIAQZzUAEHo1wAoAgA2AgBBjNQAQcCnAzYCAEGY1ABBiNgENgIAQcz/B0E4NgIAQYjYBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBgNQAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBqNQAaiIBIABBsNQAaigCACIAKAIIIgNGBEBBgNQAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQYjUACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBqNQAaiIBIAJBsNQAaigCACICKAIIIgNGBEBBgNQAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQajUAGohAEGU1AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGA1AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQZTUACAENgIAQYjUACAFNgIADBELQYTUACgCACILRQ0BIAtoQQJ0QbDWAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBkNQAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQYTUACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBsNYAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbDWAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBiNQAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGQ1AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBiNQAKAIAIgMgBE8EQEGU1AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQYjUACACNgIAQZTUACAANgIAIAFBCGohAQwPC0GM1AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBmNQAIAA2AgBBjNQAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QdjXACgCAARAQeDXACgCAAwBC0Hk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBDGpBcHFB2KrVqgVzNgIAQezXAEEANgIAQbzXAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEHw1wBBMDYCAAwPCwJAQbjXACgCACIBRQ0AQbDXACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUHw1wBBMDYCAAwPC0G81wAtAABBBHENBAJAAkAgCQRAQcDXACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQOiIAQX9GDQUgAiEGQdzXACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQbjXACgCACIDBEBBsNcAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDoiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDohACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQeDXACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQOkF/RwRAIAAgBmohBiABIQAMBwtBACAGaxA6GgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtBvNcAQbzXACgCAEEEcjYCAAsgAkH+////B0sNASACEDohAEEAEDohASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBsNcAQbDXACgCACAGaiIBNgIAQbTXACgCACABSQRAQbTXACABNgIACwJAAkACQEGY1AAoAgAiAgRAQcDXACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBkNQAKAIAIgFBAEcgACABT3FFBEBBkNQAIAA2AgALQQAhAUHE1wAgBjYCAEHA1wAgADYCAEGg1ABBfzYCAEGk1ABB2NcAKAIANgIAQczXAEEANgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBnNQAQejXACgCADYCAEGM1AAgATYCAEGY1AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBjNQAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBnNQAQejXACgCADYCAEGM1AAgADYCAEGY1AAgAzYCACACIAdqQTg2AgQMAQsgAEGQ1AAoAgBJBEBBkNQAIAA2AgALIAAgBmohA0HA1wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBwNcAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGY1AAgBDYCAEGM1ABBjNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQZTUACgCACAGRgRAQZTUACAENgIAQYjUAEGI1AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAc2AgAgA0EQakHI1wApAgA3AgAgA0HA1wApAgA3AghByNcAIANBCGo2AgBBxNcAIAY2AgBBwNcAIAA2AgBBzNcAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIDcUUEQEGA1AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEGE1AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGE1AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBjNQAKAIAIgEgBE0NAEGY1AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGM1AAgATYCAEGY1AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUHw1wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBsNYAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGE1ABBhNQAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBqNQAaiEAAn9BgNQAKAIAIgJBASABQQN2dCIBcUUEQEGA1AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbDWAGohAEGE1AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGE1AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEGw1gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQYTUACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUGo1ABqIQACf0GA1AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYDUACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBsNYAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBhNQAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBsNYAaiICKAIAIABGBEAgAiADNgIAIAMNAUGE1AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBqNQAaiEBQZTUACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYDUACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0GU1AAgBzYCAEGI1AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfDXAEEwNgIAQX8PCyAAQRB0DwsACwvbQCIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLgjFJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABUcmFuc2Zlci1FbmNvZGluZyBjYW4ndCBiZSBwcmVzZW50IHdpdGggQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBzaXplAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIHNpemUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAUhUAABoVAAAPEgAA5BkAAJEVAAAJFAAALRkAAOQUAADpEQAAaRQAAKEUAAB2FQAAQxYAAF4SAACUFwAAFxYAAH0UAAB/FgAAQRcAALMTAADDFgAABBoAAL0YAADQGAAAoBMAANQZAACvFgAAaBYAAHAXAADZFgAA/BgAAP4RAABZFwAAlxYAABwXAAD2FgAAjRcAAAsSAAB/GwAALhEAALMQAABJEgAArRIAAPYYAABoEAAAYhUAABAVAABaFgAAShkAALUVAADBFQAAYBUAAFwZAABaGQAAUxkAABYVAACtEQAAQhAAALcQAABXGAAAvxUAAIkQAAAcGQAAGhkAALkVAABRGAAA3BMAAFsVAABZFQAA5hgAAGcVAAARGQAA7RgAAOcTAACuEAAAwhcAAAAUAACSEwAAhBMAAEASAAAmGQAArxUAAGIQAEHpOQsBAQBBgDoL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB6jsLBAEAAAIAQYE8C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHqPQsEAQAAAgBBgT4LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQeA/Cw1sb3NlZWVwLWFsaXZlAEH5PwsBAQBBkMAAC+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnBAAsBAQBBkMIAC+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGhxAALXgEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAQYDGAAshZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAEGwxgALK3JhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KU00NCg0KVFRQL0NFL1RTUC8AQenGAAsFAQIAAQMAQYDHAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenIAAsFAQIAAQMAQYDJAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenKAAsEAQAAAQBBgcsAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEHpzAALBQECAAEDAEGAzQALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEHpzgALBQEBAAEBAEGAzwALAQEAQZrPAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQenQAAsFAQEAAQEAQYDRAAsBAQBBitEACwYCAAAAAAIAQaHRAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB4NIAC5oBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
    var wasmBuffer;
    Object.defineProperty(module2, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("node:buffer");
    var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMArYywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQewBNgIcCwYAIAAQOQuaLQELfyMAQRBrIgokAEGY1AAoAgAiCUUEQEHY1wAoAgAiBUUEQEHk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBCGpBcHFB2KrVqgVzIgU2AgBB7NcAQQA2AgBBvNcAQQA2AgALQcDXAEGA2AQ2AgBBkNQAQYDYBDYCAEGk1AAgBTYCAEGg1ABBfzYCAEHE1wBBgKgDNgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNgEQcGnAzYCAEGc1ABB6NcAKAIANgIAQYzUAEHApwM2AgBBmNQAQYjYBDYCAEHM/wdBODYCAEGI2AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYDUACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQajUAGoiASAAQbDUAGooAgAiACgCCCIDRgRAQYDUACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GI1AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQajUAGoiASACQbDUAGooAgAiAigCCCIDRgRAQYDUACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUGo1ABqIQBBlNQAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBgNQAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGU1AAgBDYCAEGI1AAgBTYCAAwRC0GE1AAoAgAiC0UNASALaEECdEGw1gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZDUACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGE1AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbDWAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEGw1gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQYjUACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBkNQAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQYjUACgCACIDIARPBEBBlNQAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GI1AAgAjYCAEGU1AAgADYCACABQQhqIQEMDwtBjNQAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQZjUACAANgIAQYzUACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0HY1wAoAgAEQEHg1wAoAgAMAQtB5NcAQn83AgBB3NcAQoCAhICAgMAANwIAQdjXACAKQQxqQXBxQdiq1aoFczYCAEHs1wBBADYCAEG81wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB8NcAQTA2AgAMDwsCQEG41wAoAgAiAUUNAEGw1wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB8NcAQTA2AgAMDwtBvNcALQAAQQRxDQQCQAJAIAkEQEHA1wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDoiAEF/Rg0FIAIhBkHc1wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUG41wAoAgAiAwRAQbDXACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhA6IgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhA6IQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHg1wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDpBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQOhoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQbzXAEG81wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhA6IQBBABA6IQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbDXAEGw1wAoAgAgBmoiATYCAEG01wAoAgAgAUkEQEG01wAgATYCAAsCQAJAAkBBmNQAKAIAIgIEQEHA1wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZDUACgCACIBQQBHIAAgAU9xRQRAQZDUACAANgIAC0EAIQFBxNcAIAY2AgBBwNcAIAA2AgBBoNQAQX82AgBBpNQAQdjXACgCADYCAEHM1wBBADYCAANAIAFBvNQAaiABQbDUAGoiAjYCACACIAFBqNQAaiIDNgIAIAFBtNQAaiADNgIAIAFBxNQAaiABQbjUAGoiAzYCACADIAI2AgAgAUHM1ABqIAFBwNQAaiICNgIAIAIgAzYCACABQcjUAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQYzUACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAA2AgBBmNQAIAM2AgAgAiAHakE4NgIEDAELIABBkNQAKAIASQRAQZDUACAANgIACyAAIAZqIQNBwNcAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQcDXACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBmNQAIAQ2AgBBjNQAQYzUACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0GU1AAoAgAgBkYEQEGU1AAgBDYCAEGI1ABBiNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGA1ABBgNQAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGc1ABB6NcAKAIANgIAQYzUACABNgIAQZjUACAHNgIAIANBEGpByNcAKQIANwIAIANBwNcAKQIANwIIQcjXACADQQhqNgIAQcTXACAGNgIAQcDXACAANgIAQczXAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQajUAGohAAJ/QYDUACgCACIBQQEgBUEDdnQiA3FFBEBBgNQAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEGw1gBqIQBBhNQAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBhNQAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQYzUACgCACIBIARNDQBBmNQAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBjNQAIAE2AgBBmNQAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB8NcAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbDWAGoiAygCACAGRgRAIAMgADYCACAADQFBhNQAQYTUACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQajUAGohAAJ/QYDUACgCACICQQEgAUEDdnQiAXFFBEBBgNQAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEGw1gBqIQBBhNQAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBhNQAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBsNYAaiICKAIAIANGBEAgAiAANgIAIAANAUGE1AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIFcUUEQEGA1AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQYTUACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbDWAGoiAigCACAARgRAIAIgAzYCACADDQFBhNQAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQajUAGohAUGU1AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGA1AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBlNQAIAc2AgBBiNQAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEHw1wBBMDYCAEF/DwsgAEEQdA8LAAsL20AiAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4IxSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMARXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVycwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGhlYWRlciB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBxdW90ZWQtcGFpciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgcmVzcG9uc2UgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGV4dGVuc2lvbiBuYW1lAEludmFsaWQgc3RhdHVzIGNvZGUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBkYXRhAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIGRhdGEAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAERhdGEgYWZ0ZXIgYENvbm5lY3Rpb246IGNsb3NlYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAUVVFUlkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBFeHBlY3RlZCBMRiBhZnRlciBDUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAFIVAAAaFQAADxIAAOQZAACRFQAACRQAAC0ZAADkFAAA6REAAGkUAAChFAAAdhUAAEMWAABeEgAAlBcAABcWAAB9FAAAfxYAAEEXAACzEwAAwxYAAAQaAAC9GAAA0BgAAKATAADUGQAArxYAAGgWAABwFwAA2RYAAPwYAAD+EQAAWRcAAJcWAAAcFwAA9hYAAI0XAAALEgAAfxsAAC4RAACzEAAASRIAAK0SAAD2GAAAaBAAAGIVAAAQFQAAWhYAAEoZAAC1FQAAwRUAAGAVAABcGQAAWhkAAFMZAAAWFQAArREAAEIQAAC3EAAAVxgAAL8VAACJEAAAHBkAABoZAAC5FQAAURgAANwTAABbFQAAWRUAAOYYAABnFQAAERkAAO0YAADnEwAArhAAAMIXAAAAFAAAkhMAAIQTAABAEgAAJhkAAK8VAABiEABB6TkLAQEAQYA6C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQeo7CwQBAAACAEGBPAteAwQDAwMDAwAAAwMAAwMAAwMDAwMDAwMDAwAFAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMAAwBB6j0LBAEAAAIAQYE+C14DAAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAQABQAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHgPwsNbG9zZWVlcC1hbGl2ZQBB+T8LAQEAQZDAAAvgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5wQALAQEAQZDCAAvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBocQAC14BAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGAxgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBsMYACytyYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNClNNDQoNClRUUC9DRS9UU1AvAEHpxgALBQECAAEDAEGAxwALXwQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpyAALBQECAAEDAEGAyQALXwQFBQYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpygALBAEAAAEAQYHLAAteAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgBB6cwACwUBAgABAwBBgM0AC18EBQAABQUFBQUFBQUFBQUGBQUFBQUFBQUFBQUFAAUABwgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAFAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAABQBB6c4ACwUBAQABAQBBgM8ACwEBAEGazwALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEHp0AALBQEBAAEBAEGA0QALAQEAQYrRAAsGAgAAAAACAEGh0QALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQeDSAAuaAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VVRVJZT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
    var wasmBuffer;
    Object.defineProperty(module2, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/constants.js
var require_constants3 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/constants.js"(exports2, module2) {
    "use strict";
    var corsSafeListedMethods = (
      /** @type {const} */
      ["GET", "HEAD", "POST"]
    );
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = (
      /** @type {const} */
      [101, 204, 205, 304]
    );
    var redirectStatus = (
      /** @type {const} */
      [301, 302, 303, 307, 308]
    );
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = (
      /** @type {const} */
      [
        "1",
        "7",
        "9",
        "11",
        "13",
        "15",
        "17",
        "19",
        "20",
        "21",
        "22",
        "23",
        "25",
        "37",
        "42",
        "43",
        "53",
        "69",
        "77",
        "79",
        "87",
        "95",
        "101",
        "102",
        "103",
        "104",
        "109",
        "110",
        "111",
        "113",
        "115",
        "117",
        "119",
        "123",
        "135",
        "137",
        "139",
        "143",
        "161",
        "179",
        "389",
        "427",
        "465",
        "512",
        "513",
        "514",
        "515",
        "526",
        "530",
        "531",
        "532",
        "540",
        "548",
        "554",
        "556",
        "563",
        "587",
        "601",
        "636",
        "989",
        "990",
        "993",
        "995",
        "1719",
        "1720",
        "1723",
        "2049",
        "3659",
        "4045",
        "4190",
        "5060",
        "5061",
        "6000",
        "6566",
        "6665",
        "6666",
        "6667",
        "6668",
        "6669",
        "6679",
        "6697",
        "10080"
      ]
    );
    var badPortsSet = new Set(badPorts);
    var referrerPolicyTokens = (
      /** @type {const} */
      [
        "no-referrer",
        "no-referrer-when-downgrade",
        "same-origin",
        "origin",
        "strict-origin",
        "origin-when-cross-origin",
        "strict-origin-when-cross-origin",
        "unsafe-url"
      ]
    );
    var referrerPolicy = (
      /** @type {const} */
      [
        "",
        ...referrerPolicyTokens
      ]
    );
    var referrerPolicyTokensSet = new Set(referrerPolicyTokens);
    var requestRedirect = (
      /** @type {const} */
      ["follow", "manual", "error"]
    );
    var safeMethods = (
      /** @type {const} */
      ["GET", "HEAD", "OPTIONS", "TRACE"]
    );
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = (
      /** @type {const} */
      ["navigate", "same-origin", "no-cors", "cors"]
    );
    var requestCredentials = (
      /** @type {const} */
      ["omit", "same-origin", "include"]
    );
    var requestCache = (
      /** @type {const} */
      [
        "default",
        "no-store",
        "reload",
        "no-cache",
        "force-cache",
        "only-if-cached"
      ]
    );
    var requestBodyHeader = (
      /** @type {const} */
      [
        "content-encoding",
        "content-language",
        "content-location",
        "content-type",
        // See https://github.com/nodejs/undici/issues/2021
        // 'Content-Length' is a forbidden header name, which is typically
        // removed in the Headers implementation. However, undici doesn't
        // filter out headers, so we add it here.
        "content-length"
      ]
    );
    var requestDuplex = (
      /** @type {const} */
      [
        "half"
      ]
    );
    var forbiddenMethods = (
      /** @type {const} */
      ["CONNECT", "TRACE", "TRACK"]
    );
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = (
      /** @type {const} */
      [
        "audio",
        "audioworklet",
        "font",
        "image",
        "manifest",
        "paintworklet",
        "script",
        "style",
        "track",
        "video",
        "xslt",
        ""
      ]
    );
    var subresourceSet = new Set(subresource);
    module2.exports = {
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicyTokens: referrerPolicyTokensSet
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/global.js
var require_global = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/data-url.js
var require_data_url = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/data-url.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
    var ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
    var HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
      if (!hashLength && href.endsWith("#")) {
        return serialized.slice(0, -1);
      }
      return serialized;
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function isHexCharByte(byte) {
      return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
    }
    function hexByteToNumber(byte) {
      return (
        // 0-9
        byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
      );
    }
    function percentDecode(input) {
      const length = input.length;
      const output = new Uint8Array(length);
      let j = 0;
      for (let i = 0; i < length; ++i) {
        const byte = input[i];
        if (byte !== 37) {
          output[j++] = byte;
        } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
          output[j++] = 37;
        } else {
          output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
          i += 2;
        }
      }
      return length === j ? output : output.subarray(0, j);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position >= input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
      let dataLength = data.length;
      if (dataLength % 4 === 0) {
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
          if (data.charCodeAt(dataLength - 1) === 61) {
            --dataLength;
          }
        }
      }
      if (dataLength % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
        return "failure";
      }
      const buffer = Buffer.from(data, "base64");
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function collectAnHTTPQuotedString(input, position, extractValue = false) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === 13 || char === 10 || char === 9 || char === 32;
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isHTTPWhiteSpace);
    }
    function isASCIIWhitespace(char) {
      return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isASCIIWhitespace);
    }
    function removeChars(str, leading, trailing, predicate) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
      }
      if (trailing) {
        while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
      }
      return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
    }
    function isomorphicDecode(input) {
      const length = input.length;
      if ((2 << 15) - 1 > length) {
        return String.fromCharCode.apply(null, input);
      }
      let result = "";
      let i = 0;
      let addition = (2 << 15) - 1;
      while (i < length) {
        if (i + addition > length) {
          addition = length - i;
        }
        result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
      }
      return result;
    }
    function minimizeSupportedMimeType(mimeType) {
      switch (mimeType.essence) {
        case "application/ecmascript":
        case "application/javascript":
        case "application/x-ecmascript":
        case "application/x-javascript":
        case "text/ecmascript":
        case "text/javascript":
        case "text/javascript1.0":
        case "text/javascript1.1":
        case "text/javascript1.2":
        case "text/javascript1.3":
        case "text/javascript1.4":
        case "text/javascript1.5":
        case "text/jscript":
        case "text/livescript":
        case "text/x-ecmascript":
        case "text/x-javascript":
          return "text/javascript";
        case "application/json":
        case "text/json":
          return "application/json";
        case "image/svg+xml":
          return "image/svg+xml";
        case "text/xml":
        case "application/xml":
          return "application/xml";
      }
      if (mimeType.subtype.endsWith("+json")) {
        return "application/json";
      }
      if (mimeType.subtype.endsWith("+xml")) {
        return "application/xml";
      }
      return "";
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType,
      removeChars,
      removeHTTPWhitespace,
      minimizeSupportedMimeType,
      HTTP_TOKEN_CODEPOINTS,
      isomorphicDecode
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types, inspect } = require("node:util");
    var { markAsUncloneable } = require("node:worker_threads");
    var { toUSVString } = require_util();
    var UNDEFINED = 1;
    var BOOLEAN = 2;
    var STRING = 3;
    var SYMBOL = 4;
    var NUMBER = 5;
    var BIGINT = 6;
    var NULL = 7;
    var OBJECT = 8;
    var FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance]);
    var webidl = {
      converters: {},
      util: {},
      errors: {},
      is: {}
    };
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context2) {
      const plural = context2.types.length === 1 ? "" : " one of";
      const message = `${context2.argument} could not be converted to${plural}: ${context2.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context2.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context2) {
      return webidl.errors.exception({
        header: context2.prefix,
        message: `"${context2.value}" is an invalid ${context2.type}.`
      });
    };
    webidl.brandCheck = function(V, I) {
      if (!FunctionPrototypeSymbolHasInstance(I, V)) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    };
    webidl.brandCheckMultiple = function(List) {
      const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c));
      return (V) => {
        if (prototypes.every((typeCheck) => !typeCheck(V))) {
          const err = new TypeError("Illegal invocation");
          err.code = "ERR_INVALID_THIS";
          throw err;
        }
      };
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          header: ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.MakeTypeAssertion = function(I) {
      return (O) => FunctionPrototypeSymbolHasInstance(I, O);
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return UNDEFINED;
        case "boolean":
          return BOOLEAN;
        case "string":
          return STRING;
        case "symbol":
          return SYMBOL;
        case "number":
          return NUMBER;
        case "bigint":
          return BIGINT;
        case "function":
        case "object": {
          if (V === null) {
            return NULL;
          }
          return OBJECT;
        }
      }
    };
    webidl.util.Types = {
      UNDEFINED,
      BOOLEAN,
      STRING,
      SYMBOL,
      NUMBER,
      BIGINT,
      NULL,
      OBJECT
    };
    webidl.util.TypeValueToString = function(o) {
      switch (webidl.util.Type(o)) {
        case UNDEFINED:
          return "Undefined";
        case BOOLEAN:
          return "Boolean";
        case STRING:
          return "String";
        case SYMBOL:
          return "Symbol";
        case NUMBER:
          return "Number";
        case BIGINT:
          return "BigInt";
        case NULL:
          return "Null";
        case OBJECT:
          return "Object";
      }
    };
    webidl.util.markAsUncloneable = markAsUncloneable || (() => {
    });
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts?.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts?.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.util.Stringify = function(V) {
      const type = webidl.util.Type(V);
      switch (type) {
        case SYMBOL:
          return `Symbol(${V.description})`;
        case OBJECT:
          return inspect(V);
        case STRING:
          return `"${V}"`;
        default:
          return `${V}`;
      }
    };
    webidl.sequenceConverter = function(converter) {
      return (V, prefix, argument, Iterable) => {
        if (webidl.util.Type(V) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
          });
        }
        const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
        const seq = [];
        let index = 0;
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} is not iterable.`
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value, prefix, `${argument}[${index++}]`));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O, prefix, argument) => {
        if (webidl.util.Type(O) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} ("${webidl.util.TypeValueToString(O)}") is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
          for (const key of keys2) {
            const keyName = webidl.util.Stringify(key);
            const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`);
            const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key, prefix, argument);
            const typedValue = valueConverter(O[key], prefix, argument);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(TypeCheck, name) {
      return (V, prefix, argument) => {
        if (!TypeCheck(V)) {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary, prefix, argument) => {
        const dict = {};
        if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (dictionary == null || !Object.hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary?.[key];
          const hasDefault = defaultValue !== void 0;
          if (hasDefault && value === void 0) {
            value = defaultValue();
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value, prefix, `${argument}.${key}`);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V, prefix, argument) => {
        if (V === null) {
          return V;
        }
        return converter(V, prefix, argument);
      };
    };
    webidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream);
    webidl.is.Blob = webidl.util.MakeTypeAssertion(Blob);
    webidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams);
    webidl.is.File = webidl.util.MakeTypeAssertion(globalThis.File ?? require("node:buffer").File);
    webidl.is.URL = webidl.util.MakeTypeAssertion(URL);
    webidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal);
    webidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort);
    webidl.converters.DOMString = function(V, prefix, argument, opts) {
      if (V === null && opts?.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is a symbol, which cannot be converted to a DOMString.`
        });
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V, prefix, argument) {
      if (typeof V === "symbol") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is a symbol, which cannot be converted to a ByteString.`
        });
      }
      const x = String(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 64, "signed", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned long long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
      if (webidl.util.Type(V) !== OBJECT || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${argument} ("${webidl.util.Stringify(V)}")`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.resizable || V.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
      if (webidl.util.Type(V) !== OBJECT || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${name} ("${webidl.util.Stringify(V)}")`,
          types: [T.name]
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.buffer.resizable || V.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, prefix, name, opts) {
      if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${name} is not a DataView.`
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.buffer.resizable || V.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    webidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, "Blob");
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      webidl.is.AbortSignal,
      "AbortSignal"
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/util.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("node:stream");
    var zlib = require("node:zlib");
    var { redirectStatusSet, referrerPolicyTokens, badPortsSet } = require_constants3();
    var { getGlobalOrigin } = require_global();
    var { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require_data_url();
    var { performance: performance2 } = require("node:perf_hooks");
    var { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require_util();
    var assert = require("node:assert");
    var { isUint8Array } = require("node:util/types");
    var { webidl } = require_webidl();
    var supportedHashes = [];
    var crypto;
    try {
      crypto = require("node:crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location", true);
      if (location !== null && isValidHeaderValue(location)) {
        if (!isValidEncodedURL(location)) {
          location = normalizeBinaryStringToUtf8(location);
        }
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function isValidEncodedURL(url) {
      for (let i = 0; i < url.length; ++i) {
        const code = url.charCodeAt(i);
        if (code > 126 || // Non-US-ASCII + DEL
        code < 32) {
          return false;
        }
      }
      return true;
    }
    function normalizeBinaryStringToUtf8(value) {
      return Buffer.from(value, "binary").toString("utf8");
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    var isValidHeaderName = isValidHTTPToken;
    function isValidHeaderValue(potentialValue) {
      return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
    }
    function parseReferrerPolicy(actualResponse) {
      const policyHeader = (actualResponse.headersList.get("referrer-policy", true) ?? "").split(",");
      let policy = "";
      if (policyHeader.length) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      return policy;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const policy = parseReferrerPolicy(actualResponse);
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header, true);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (serializedOrigin === "client" || serializedOrigin === void 0) {
        return;
      }
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        request.headersList.append("origin", serializedOrigin, true);
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        request.headersList.append("origin", serializedOrigin, true);
      }
    }
    function coarsenTime(timestamp, crossOriginIsolatedCapability) {
      return timestamp;
    }
    function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
      if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
        return {
          domainLookupStartTime: defaultStartTime,
          domainLookupEndTime: defaultStartTime,
          connectionStartTime: defaultStartTime,
          connectionEndTime: defaultStartTime,
          secureConnectionStartTime: defaultStartTime,
          ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
        };
      }
      return {
        domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
        domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
        connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
        connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
        secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
        ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
      };
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return coarsenTime(performance2.now(), crossOriginIsolatedCapability);
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (webidl.is.URL(request.referrer)) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      switch (policy) {
        case "no-referrer":
          return "no-referrer";
        case "origin":
          if (referrerOrigin != null) {
            return referrerOrigin;
          }
          return stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "strict-origin": {
          const currentURL = requestCurrentURL(request);
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "same-origin":
          if (sameOrigin(request, referrerURL)) {
            return referrerURL;
          }
          return "no-referrer";
        case "origin-when-cross-origin":
          if (sameOrigin(request, referrerURL)) {
            return referrerURL;
          }
          return referrerOrigin;
        case "no-referrer-when-downgrade": {
          const currentURL = requestCurrentURL(request);
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
      }
    }
    function stripURLForReferrer(url, originOnly = false) {
      assert(webidl.is.URL(url));
      url = new URL(url);
      if (urlIsLocal(url)) {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly === true) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    var potentialleTrustworthyIPv4RegExp = new RegExp("^(?:(?:127\\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){2}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9]))$");
    var potentialleTrustworthyIPv6RegExp = new RegExp("^(?:(?:(?:0{1,4}):){7}(?:(?:0{0,3}1))|(?:(?:0{1,4}):){1,6}(?::(?:0{0,3}1))|(?:::(?:0{0,3}1))|)$");
    function isOriginIPPotentiallyTrustworthy(origin) {
      if (origin.includes(":")) {
        if (origin[0] === "[" && origin[origin.length - 1] === "]") {
          origin = origin.slice(1, -1);
        }
        return potentialleTrustworthyIPv6RegExp.test(origin);
      }
      return potentialleTrustworthyIPv4RegExp.test(origin);
    }
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null") {
        return false;
      }
      origin = new URL(origin);
      if (origin.protocol === "https:" || origin.protocol === "wss:") {
        return true;
      }
      if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {
        return true;
      }
      if (origin.hostname === "localhost" || origin.hostname === "localhost.") {
        return true;
      }
      if (origin.hostname.endsWith(".localhost") || origin.hostname.endsWith(".localhost.")) {
        return true;
      }
      if (origin.protocol === "file:") {
        return true;
      }
      return false;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!webidl.is.URL(url)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:") return true;
      if (url.protocol === "blob:") return true;
      return isOriginPotentiallyTrustworthy(url.origin);
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
      class FastIterableIterator {
        /** @type {any} */
        #target;
        /** @type {'key' | 'value' | 'key+value'} */
        #kind;
        /** @type {number} */
        #index;
        /**
         * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
         * @param {unknown} target
         * @param {'key' | 'value' | 'key+value'} kind
         */
        constructor(target, kind) {
          this.#target = target;
          this.#kind = kind;
          this.#index = 0;
        }
        next() {
          if (typeof this !== "object" || this === null || !(#target in this)) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const index = this.#index;
          const values = kInternalIterator(this.#target);
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          const { [keyIndex]: key, [valueIndex]: value } = values[index];
          this.#index = index + 1;
          let result;
          switch (this.#kind) {
            case "key":
              result = key;
              break;
            case "value":
              result = value;
              break;
            case "key+value":
              result = [key, value];
              break;
          }
          return {
            value: result,
            done: false
          };
        }
      }
      delete FastIterableIterator.prototype.constructor;
      Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
      Object.defineProperties(FastIterableIterator.prototype, {
        [Symbol.toStringTag]: {
          writable: false,
          enumerable: false,
          configurable: true,
          value: `${name} Iterator`
        },
        next: { writable: true, enumerable: true, configurable: true }
      });
      return function(target, kind) {
        return new FastIterableIterator(target, kind);
      };
    }
    function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
      const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
      const properties = {
        keys: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function keys() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key");
          }
        },
        values: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function values() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "value");
          }
        },
        entries: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function entries() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key+value");
          }
        },
        forEach: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function forEach(callbackfn, thisArg = globalThis) {
            webidl.brandCheck(this, object);
            webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
            if (typeof callbackfn !== "function") {
              throw new TypeError(
                `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
              );
            }
            for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
              callbackfn.call(thisArg, value, key, this);
            }
          }
        }
      };
      return Object.defineProperties(object.prototype, {
        ...properties,
        [Symbol.iterator]: {
          writable: true,
          enumerable: false,
          configurable: true,
          value: properties.entries.value
        }
      });
    }
    function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      readAllBytes(reader, successSteps, errorSteps);
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
        controller.byobRequest?.respond(0);
      } catch (err) {
        if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
          throw err;
        }
      }
    }
    var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
    function isomorphicEncode(input) {
      assert(!invalidIsomorphicEncodeValueRegex.test(input));
      return input;
    }
    async function readAllBytes(reader, successSteps, failureSteps) {
      const bytes = [];
      let byteLength = 0;
      try {
        do {
          const { done, value: chunk } = await reader.read();
          if (done) {
            successSteps(Buffer.concat(bytes, byteLength));
            return;
          }
          if (!isUint8Array(chunk)) {
            failureSteps(TypeError("Received non-Uint8Array chunk"));
            return;
          }
          bytes.push(chunk);
          byteLength += chunk.length;
        } while (true);
      } catch (e) {
        failureSteps(e);
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    function simpleRangeHeaderValue(value, allowWhitespace) {
      const data = value;
      if (!data.startsWith("bytes")) {
        return "failure";
      }
      const position = { position: 5 };
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 61) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeStart = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 45) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeEnd = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
      if (position.position < data.length) {
        return "failure";
      }
      if (rangeEndValue === null && rangeStartValue === null) {
        return "failure";
      }
      if (rangeStartValue > rangeEndValue) {
        return "failure";
      }
      return { rangeStartValue, rangeEndValue };
    }
    function buildContentRange(rangeStart, rangeEnd, fullLength) {
      let contentRange = "bytes ";
      contentRange += isomorphicEncode(`${rangeStart}`);
      contentRange += "-";
      contentRange += isomorphicEncode(`${rangeEnd}`);
      contentRange += "/";
      contentRange += isomorphicEncode(`${fullLength}`);
      return contentRange;
    }
    var InflateStream = class extends Transform {
      #zlibOptions;
      /** @param {zlib.ZlibOptions} [zlibOptions] */
      constructor(zlibOptions) {
        super();
        this.#zlibOptions = zlibOptions;
      }
      _transform(chunk, encoding, callback) {
        if (!this._inflateStream) {
          if (chunk.length === 0) {
            callback();
            return;
          }
          this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(this.#zlibOptions) : zlib.createInflateRaw(this.#zlibOptions);
          this._inflateStream.on("data", this.push.bind(this));
          this._inflateStream.on("end", () => this.push(null));
          this._inflateStream.on("error", (err) => this.destroy(err));
        }
        this._inflateStream.write(chunk, encoding, callback);
      }
      _final(callback) {
        if (this._inflateStream) {
          this._inflateStream.end();
          this._inflateStream = null;
        }
        callback();
      }
    };
    function createInflate(zlibOptions) {
      return new InflateStream(zlibOptions);
    }
    function extractMimeType(headers) {
      let charset = null;
      let essence = null;
      let mimeType = null;
      const values = getDecodeSplit("content-type", headers);
      if (values === null) {
        return "failure";
      }
      for (const value of values) {
        const temporaryMimeType = parseMIMEType(value);
        if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
          continue;
        }
        mimeType = temporaryMimeType;
        if (mimeType.essence !== essence) {
          charset = null;
          if (mimeType.parameters.has("charset")) {
            charset = mimeType.parameters.get("charset");
          }
          essence = mimeType.essence;
        } else if (!mimeType.parameters.has("charset") && charset !== null) {
          mimeType.parameters.set("charset", charset);
        }
      }
      if (mimeType == null) {
        return "failure";
      }
      return mimeType;
    }
    function gettingDecodingSplitting(value) {
      const input = value;
      const position = { position: 0 };
      const values = [];
      let temporaryValue = "";
      while (position.position < input.length) {
        temporaryValue += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== ",",
          input,
          position
        );
        if (position.position < input.length) {
          if (input.charCodeAt(position.position) === 34) {
            temporaryValue += collectAnHTTPQuotedString(
              input,
              position
            );
            if (position.position < input.length) {
              continue;
            }
          } else {
            assert(input.charCodeAt(position.position) === 44);
            position.position++;
          }
        }
        temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
        values.push(temporaryValue);
        temporaryValue = "";
      }
      return values;
    }
    function getDecodeSplit(name, list) {
      const value = list.get(name, true);
      if (value === null) {
        return null;
      }
      return gettingDecodingSplitting(value);
    }
    var textDecoder = new TextDecoder();
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    var EnvironmentSettingsObjectBase = class {
      get baseUrl() {
        return getGlobalOrigin();
      }
      get origin() {
        return this.baseUrl?.origin;
      }
      policyContainer = makePolicyContainer();
    };
    var EnvironmentSettingsObject = class {
      settingsObject = new EnvironmentSettingsObjectBase();
    };
    var environmentSettingsObject = new EnvironmentSettingsObject();
    module2.exports = {
      isAborted,
      isCancelled,
      isValidEncodedURL,
      createDeferredPromise,
      ReadableStreamFrom,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      clampAndCoarsenConnectionTimingInfo,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      iteratorMixin,
      createIterator,
      isValidHeaderName,
      isValidHeaderValue,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      simpleRangeHeaderValue,
      buildContentRange,
      parseMetadata,
      createInflate,
      extractMimeType,
      getDecodeSplit,
      utf8DecodeBytes,
      environmentSettingsObject,
      isOriginIPPotentiallyTrustworthy
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { iteratorMixin } = require_util2();
    var { kEnumerableProperty } = require_util();
    var { webidl } = require_webidl();
    var { File: NativeFile } = require("node:buffer");
    var nodeUtil = require("node:util");
    var File = globalThis.File ?? NativeFile;
    var FormData = class _FormData {
      #state = [];
      constructor(form) {
        webidl.util.markAsUncloneable(this);
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.append";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        name = webidl.converters.USVString(name);
        if (arguments.length === 3 || webidl.is.Blob(value)) {
          value = webidl.converters.Blob(value, prefix, "value");
          if (filename !== void 0) {
            filename = webidl.converters.USVString(filename);
          }
        } else {
          value = webidl.converters.USVString(value);
        }
        const entry = makeEntry(name, value, filename);
        this.#state.push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        this.#state = this.#state.filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.get";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        const idx = this.#state.findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this.#state[idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.getAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        return this.#state.filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        return this.#state.findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.set";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        name = webidl.converters.USVString(name);
        if (arguments.length === 3 || webidl.is.Blob(value)) {
          value = webidl.converters.Blob(value, prefix, "value");
          if (filename !== void 0) {
            filename = webidl.converters.USVString(filename);
          }
        } else {
          value = webidl.converters.USVString(value);
        }
        const entry = makeEntry(name, value, filename);
        const idx = this.#state.findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this.#state = [
            ...this.#state.slice(0, idx),
            entry,
            ...this.#state.slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this.#state.push(entry);
        }
      }
      [nodeUtil.inspect.custom](depth, options) {
        const state = this.#state.reduce((a, b) => {
          if (a[b.name]) {
            if (Array.isArray(a[b.name])) {
              a[b.name].push(b.value);
            } else {
              a[b.name] = [a[b.name], b.value];
            }
          } else {
            a[b.name] = b.value;
          }
          return a;
        }, { __proto__: null });
        options.depth ??= depth;
        options.colors ??= true;
        const output = nodeUtil.formatWithOptions(options, state);
        return `FormData ${output.slice(output.indexOf("]") + 2)}`;
      }
      /**
       * @param {FormData} formData
       */
      static getFormDataState(formData) {
        return formData.#state;
      }
      /**
       * @param {FormData} formData
       * @param {any[]} newState
       */
      static setFormDataState(formData, newState) {
        formData.#state = newState;
      }
    };
    var { getFormDataState, setFormDataState } = FormData;
    Reflect.deleteProperty(FormData, "getFormDataState");
    Reflect.deleteProperty(FormData, "setFormDataState");
    iteratorMixin("FormData", FormData, getFormDataState, "name", "value");
    Object.defineProperties(FormData.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      getAll: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      if (typeof value === "string") {
      } else {
        if (!webidl.is.File(value)) {
          value = new File([value], "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = new File([value], filename, options);
        }
      }
      return { name, value };
    }
    webidl.is.FormData = webidl.util.MakeTypeAssertion(FormData);
    module2.exports = { FormData, makeEntry, setFormDataState };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/formdata-parser.js
var require_formdata_parser = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/formdata-parser.js"(exports2, module2) {
    "use strict";
    var { isUSVString, bufferToLowerCasedHeaderName } = require_util();
    var { utf8DecodeBytes } = require_util2();
    var { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require_data_url();
    var { makeEntry } = require_formdata();
    var { webidl } = require_webidl();
    var assert = require("node:assert");
    var { File: NodeFile } = require("node:buffer");
    var File = globalThis.File ?? NodeFile;
    var formDataNameBuffer = Buffer.from('form-data; name="');
    var filenameBuffer = Buffer.from("filename");
    var dd = Buffer.from("--");
    var ddcrlf = Buffer.from("--\r\n");
    function isAsciiString(chars) {
      for (let i = 0; i < chars.length; ++i) {
        if ((chars.charCodeAt(i) & ~127) !== 0) {
          return false;
        }
      }
      return true;
    }
    function validateBoundary(boundary) {
      const length = boundary.length;
      if (length < 27 || length > 70) {
        return false;
      }
      for (let i = 0; i < length; ++i) {
        const cp = boundary.charCodeAt(i);
        if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
          return false;
        }
      }
      return true;
    }
    function multipartFormDataParser(input, mimeType) {
      assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
      const boundaryString = mimeType.parameters.get("boundary");
      if (boundaryString === void 0) {
        throw parsingError("missing boundary in content-type header");
      }
      const boundary = Buffer.from(`--${boundaryString}`, "utf8");
      const entryList = [];
      const position = { position: 0 };
      while (input[position.position] === 13 && input[position.position + 1] === 10) {
        position.position += 2;
      }
      let trailing = input.length;
      while (input[trailing - 1] === 10 && input[trailing - 2] === 13) {
        trailing -= 2;
      }
      if (trailing !== input.length) {
        input = input.subarray(0, trailing);
      }
      while (true) {
        if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
          position.position += boundary.length;
        } else {
          throw parsingError("expected a value starting with -- and the boundary");
        }
        if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
          return entryList;
        }
        if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        }
        position.position += 2;
        const result = parseMultipartFormDataHeaders(input, position);
        let { name, filename, contentType, encoding } = result;
        position.position += 2;
        let body;
        {
          const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
          if (boundaryIndex === -1) {
            throw parsingError("expected boundary after body");
          }
          body = input.subarray(position.position, boundaryIndex - 4);
          position.position += body.length;
          if (encoding === "base64") {
            body = Buffer.from(body.toString(), "base64");
          }
        }
        if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        } else {
          position.position += 2;
        }
        let value;
        if (filename !== null) {
          contentType ??= "text/plain";
          if (!isAsciiString(contentType)) {
            contentType = "";
          }
          value = new File([body], filename, { type: contentType });
        } else {
          value = utf8DecodeBytes(Buffer.from(body));
        }
        assert(isUSVString(name));
        assert(typeof value === "string" && isUSVString(value) || webidl.is.File(value));
        entryList.push(makeEntry(name, value, filename));
      }
    }
    function parseMultipartFormDataHeaders(input, position) {
      let name = null;
      let filename = null;
      let contentType = null;
      let encoding = null;
      while (true) {
        if (input[position.position] === 13 && input[position.position + 1] === 10) {
          if (name === null) {
            throw parsingError("header name is null");
          }
          return { name, filename, contentType, encoding };
        }
        let headerName = collectASequenceOfBytes(
          (char) => char !== 10 && char !== 13 && char !== 58,
          input,
          position
        );
        headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
        if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
          throw parsingError("header name does not match the field-name token production");
        }
        if (input[position.position] !== 58) {
          throw parsingError("expected :");
        }
        position.position++;
        collectASequenceOfBytes(
          (char) => char === 32 || char === 9,
          input,
          position
        );
        switch (bufferToLowerCasedHeaderName(headerName)) {
          case "content-disposition": {
            name = filename = null;
            if (!bufferStartsWith(input, formDataNameBuffer, position)) {
              throw parsingError('expected form-data; name=" for content-disposition header');
            }
            position.position += 17;
            name = parseMultipartFormDataName(input, position);
            if (input[position.position] === 59 && input[position.position + 1] === 32) {
              const at = { position: position.position + 2 };
              if (bufferStartsWith(input, filenameBuffer, at)) {
                if (input[at.position + 8] === 42) {
                  at.position += 10;
                  collectASequenceOfBytes(
                    (char) => char === 32 || char === 9,
                    input,
                    at
                  );
                  const headerValue = collectASequenceOfBytes(
                    (char) => char !== 32 && char !== 13 && char !== 10,
                    // ' ' or CRLF
                    input,
                    at
                  );
                  if (headerValue[0] !== 117 && headerValue[0] !== 85 || // u or U
                  headerValue[1] !== 116 && headerValue[1] !== 84 || // t or T
                  headerValue[2] !== 102 && headerValue[2] !== 70 || // f or F
                  headerValue[3] !== 45 || // -
                  headerValue[4] !== 56) {
                    throw parsingError("unknown encoding, expected utf-8''");
                  }
                  filename = decodeURIComponent(new TextDecoder().decode(headerValue.subarray(7)));
                  position.position = at.position;
                } else {
                  position.position += 11;
                  collectASequenceOfBytes(
                    (char) => char === 32 || char === 9,
                    input,
                    position
                  );
                  position.position++;
                  filename = parseMultipartFormDataName(input, position);
                }
              }
            }
            break;
          }
          case "content-type": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            contentType = isomorphicDecode(headerValue);
            break;
          }
          case "content-transfer-encoding": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            encoding = isomorphicDecode(headerValue);
            break;
          }
          default: {
            collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
          }
        }
        if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        } else {
          position.position += 2;
        }
      }
    }
    function parseMultipartFormDataName(input, position) {
      assert(input[position.position - 1] === 34);
      let name = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 34,
        input,
        position
      );
      if (input[position.position] !== 34) {
        throw parsingError('expected "');
      } else {
        position.position++;
      }
      name = new TextDecoder().decode(name).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
      return name;
    }
    function collectASequenceOfBytes(condition, input, position) {
      let start = position.position;
      while (start < input.length && condition(input[start])) {
        ++start;
      }
      return input.subarray(position.position, position.position = start);
    }
    function removeChars(buf, leading, trailing, predicate) {
      let lead = 0;
      let trail = buf.length - 1;
      if (leading) {
        while (lead < buf.length && predicate(buf[lead])) lead++;
      }
      if (trailing) {
        while (trail > 0 && predicate(buf[trail])) trail--;
      }
      return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
    }
    function bufferStartsWith(buffer, start, position) {
      if (buffer.length < start.length) {
        return false;
      }
      for (let i = 0; i < start.length; i++) {
        if (start[i] !== buffer[position.position + i]) {
          return false;
        }
      }
      return true;
    }
    function parsingError(cause) {
      return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(cause) });
    }
    module2.exports = {
      multipartFormDataParser,
      validateBoundary
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/body.js
var require_body = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/body.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var {
      ReadableStreamFrom,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody,
      extractMimeType,
      utf8DecodeBytes
    } = require_util2();
    var { FormData, setFormDataState } = require_formdata();
    var { webidl } = require_webidl();
    var { Blob: Blob2 } = require("node:buffer");
    var assert = require("node:assert");
    var { isErrored, isDisturbed } = require("node:stream");
    var { isArrayBuffer } = require("node:util/types");
    var { serializeAMimeType } = require_data_url();
    var { multipartFormDataParser } = require_formdata_parser();
    var random;
    try {
      const crypto = require("node:crypto");
      random = (max) => crypto.randomInt(0, max);
    } catch {
      random = (max) => Math.floor(Math.random() * max);
    }
    var textEncoder = new TextEncoder();
    function noop() {
    }
    var hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
    var streamRegistry;
    if (hasFinalizationRegistry) {
      streamRegistry = new FinalizationRegistry((weakRef) => {
        const stream = weakRef.deref();
        if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
          stream.cancel("Response object has been garbage collected").catch(noop);
        }
      });
    }
    function extractBody(object, keepalive = false) {
      let stream = null;
      if (webidl.is.ReadableStream(object)) {
        stream = object;
      } else if (webidl.is.Blob(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
            if (buffer.byteLength) {
              controller.enqueue(buffer);
            }
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: "bytes"
        });
      }
      assert(webidl.is.ReadableStream(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (webidl.is.URLSearchParams(object)) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (webidl.is.FormData(object)) {
        const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--\r
`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = `multipart/form-data; boundary=${boundary}`;
      } else if (webidl.is.Blob(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
                controller.byobRequest?.respond(0);
              });
            } else {
              if (!isErrored(stream)) {
                const buffer = new Uint8Array(value);
                if (buffer.byteLength) {
                  controller.enqueue(buffer);
                }
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: "bytes"
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (webidl.is.ReadableStream(object)) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(instance, body) {
      const [out1, out2] = body.stream.tee();
      if (hasFinalizationRegistry) {
        streamRegistry.register(instance, new WeakRef(out1));
      }
      body.stream = out1;
      return {
        stream: out2,
        length: body.length,
        source: body.source
      };
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance, getInternalState) {
      const methods = {
        blob() {
          return consumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(getInternalState(this));
            if (mimeType === null) {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance, getInternalState);
        },
        arrayBuffer() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance, getInternalState);
        },
        text() {
          return consumeBody(this, utf8DecodeBytes, instance, getInternalState);
        },
        json() {
          return consumeBody(this, parseJSONFromBytes, instance, getInternalState);
        },
        formData() {
          return consumeBody(this, (value) => {
            const mimeType = bodyMimeType(getInternalState(this));
            if (mimeType !== null) {
              switch (mimeType.essence) {
                case "multipart/form-data": {
                  const parsed = multipartFormDataParser(value, mimeType);
                  const fd = new FormData();
                  setFormDataState(fd, parsed);
                  return fd;
                }
                case "application/x-www-form-urlencoded": {
                  const entries = new URLSearchParams(value.toString());
                  const fd = new FormData();
                  for (const [name, value2] of entries) {
                    fd.append(name, value2);
                  }
                  return fd;
                }
              }
            }
            throw new TypeError(
              'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
            );
          }, instance, getInternalState);
        },
        bytes() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes);
          }, instance, getInternalState);
        }
      };
      return methods;
    }
    function mixinBody(prototype, getInternalState) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState));
    }
    async function consumeBody(object, convertBytesToJSValue, instance, getInternalState) {
      webidl.brandCheck(object, instance);
      const state = getInternalState(object);
      if (bodyUnusable(state)) {
        throw new TypeError("Body is unusable: Body has already been read");
      }
      throwIfAborted(state);
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (state.body == null) {
        successSteps(Buffer.allocUnsafe(0));
        return promise.promise;
      }
      fullyReadBody(state.body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(object) {
      const body = object.body;
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(requestOrResponse) {
      const headers = requestOrResponse.headersList;
      const mimeType = extractMimeType(headers);
      if (mimeType === "failure") {
        return null;
      }
      return mimeType;
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody,
      streamRegistry,
      hasFinalizationRegistry,
      bodyUnusable
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/client-h1.js
var require_client_h1 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/client-h1.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var util = require_util();
    var { channels } = require_diagnostics();
    var timers = require_timers();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError
    } = require_errors2();
    var {
      kUrl,
      kReset,
      kClient,
      kParser,
      kBlocking,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kMaxRequests,
      kCounter,
      kMaxResponseSize,
      kOnError,
      kResume,
      kHTTPContext,
      kClosed
    } = require_symbols2();
    var constants = require_constants2();
    var EMPTY_BUF = Buffer.alloc(0);
    var FastBuffer = Buffer[Symbol.species];
    var removeAllListeners = util.removeAllListeners;
    var extractBody;
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(require_llhttp_simd_wasm());
      } catch (e) {
        mod = await WebAssembly.compile(llhttpWasmData || require_llhttp_wasm());
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_status: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @returns {number}
           */
          wasm_on_message_begin: (p) => {
            assert(currentParser.ptr === p);
            return currentParser.onMessageBegin();
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_header_field: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_header_value: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @param {number} statusCode
           * @param {0|1} upgrade
           * @param {0|1} shouldKeepAlive
           * @returns {number}
           */
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert(currentParser.ptr === p);
            return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1);
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_body: (p, at, len) => {
            assert(currentParser.ptr === p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @returns {number}
           */
          wasm_on_message_complete: (p) => {
            assert(currentParser.ptr === p);
            return currentParser.onMessageComplete();
          }
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var USE_NATIVE_TIMER = 0;
    var USE_FAST_TIMER = 1;
    var TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
    var TIMEOUT_BODY = 4 | USE_FAST_TIMER;
    var TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;
    var Parser = class {
      /**
         * @param {import('./client.js')} client
         * @param {import('net').Socket} socket
         * @param {*} llhttp
         */
      constructor(client, socket, { exports: exports3 }) {
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = 0;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(delay, type) {
        if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
          if (this.timeout) {
            timers.clearTimeout(this.timeout);
            this.timeout = null;
          }
          if (delay) {
            if (type & USE_FAST_TIMER) {
              this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
            } else {
              this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
              this.timeout.unref();
            }
          }
          this.timeoutValue = delay;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.timeoutType = type;
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser === null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      /**
       * @param {Buffer} chunk
       */
      execute(chunk) {
        assert(currentParser === null);
        assert(this.ptr != null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (chunk.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(chunk.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk);
        try {
          let ret;
          try {
            currentBufferRef = chunk;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          if (ret !== constants.ERROR.OK) {
            const data = chunk.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr);
            if (ret === constants.ERROR.PAUSED_UPGRADE) {
              this.onUpgrade(data);
            } else if (ret === constants.ERROR.PAUSED) {
              this.paused = true;
              socket.unshift(data);
            } else {
              const ptr = llhttp.llhttp_get_error_reason(this.ptr);
              let message = "";
              if (ptr) {
                const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
              }
              throw new HTTPParserError(message, constants.ERROR[ret], data);
            }
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(currentParser === null);
        assert(this.ptr != null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        this.timeout && timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      /**
       * @param {Buffer} buf
       * @returns {0}
       */
      onStatus(buf) {
        this.statusText = buf.toString();
        return 0;
      }
      /**
       * @returns {0|-1}
       */
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        request.onResponseStarted();
        return 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
        return 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10) {
          const headerName = util.bufferToLowerCasedHeaderName(key);
          if (headerName === "keep-alive") {
            this.keepAlive += buf.toString();
          } else if (headerName === "connection") {
            this.connection += buf.toString();
          }
        } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
        return 0;
      }
      /**
       * @param {number} len
       */
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      /**
       * @param {Buffer} head
       */
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        assert(client[kSocket] === socket);
        assert(!socket.destroyed);
        assert(!this.paused);
        assert((headers.length & 1) === 0);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = 0;
        this.statusText = "";
        this.shouldKeepAlive = false;
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        removeAllListeners(socket);
        client[kSocket] = null;
        client[kHTTPContext] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        client[kResume]();
      }
      /**
       * @param {number} statusCode
       * @param {boolean} upgrade
       * @param {boolean} shouldKeepAlive
       * @returns {number}
       */
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert(this.timeoutType === TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert((this.headers.length & 1) === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          client[kResume]();
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
        return 0;
      }
      /**
       * @returns {number}
       */
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return 0;
        }
        assert(statusCode >= 100);
        assert((this.headers.length & 1) === 0);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        this.statusCode = 0;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return 0;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert(client[kRunning] === 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] == null || client[kPipelining] === 1) {
          setImmediate(() => client[kResume]());
        } else {
          client[kResume]();
        }
        return 0;
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client, paused } = parser.deref();
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    async function connectH1(client, socket) {
      client[kSocket] = socket;
      if (!llhttpInstance) {
        const noop = () => {
        };
        socket.on("error", noop);
        llhttpInstance = await llhttpPromise;
        llhttpPromise = null;
        socket.off("error", noop);
      }
      if (socket.errored) {
        throw socket.errored;
      }
      if (socket.destroyed) {
        throw new SocketError("destroyed");
      }
      socket[kNoRef] = false;
      socket[kWriting] = false;
      socket[kReset] = false;
      socket[kBlocking] = false;
      socket[kParser] = new Parser(client, socket, llhttpInstance);
      util.addListener(socket, "error", onHttpSocketError);
      util.addListener(socket, "readable", onHttpSocketReadable);
      util.addListener(socket, "end", onHttpSocketEnd);
      util.addListener(socket, "close", onHttpSocketClose);
      socket[kClosed] = false;
      socket.on("close", onSocketClose);
      return {
        version: "h1",
        defaultPipelining: 1,
        write(request) {
          return writeH1(client, request);
        },
        resume() {
          resumeH1(client);
        },
        /**
         * @param {Error|undefined} err
         * @param {() => void} callback
         */
        destroy(err, callback) {
          if (socket[kClosed]) {
            queueMicrotask(callback);
          } else {
            socket.on("close", callback);
            socket.destroy(err);
          }
        },
        /**
         * @returns {boolean}
         */
        get destroyed() {
          return socket.destroyed;
        },
        /**
         * @param {import('../core/request.js')} request
         * @returns {boolean}
         */
        busy(request) {
          if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
            return true;
          }
          if (request) {
            if (client[kRunning] > 0 && !request.idempotent) {
              return true;
            }
            if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
              return true;
            }
            if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {
              return true;
            }
          }
          return false;
        }
      };
    }
    function onHttpSocketError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      const parser = this[kParser];
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttpSocketReadable() {
      this[kParser]?.readMore();
    }
    function onHttpSocketEnd() {
      const parser = this[kParser];
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onHttpSocketClose() {
      const parser = this[kParser];
      if (parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      const client = this[kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        util.errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function onSocketClose() {
      this[kClosed] = true;
    }
    function resumeH1(client) {
      const socket = client[kSocket];
      if (socket && !socket.destroyed) {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH1(client, request) {
      const { method, path, host, upgrade, blocking, reset } = request;
      let { body, headers, contentLength } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
      if (util.isFormDataLike(body)) {
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (request.contentType == null) {
          headers.push("content-type", contentType);
        }
        body = bodyStream.stream;
        contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && request.contentType == null && body.type) {
        headers.push("content-type", body.type);
      }
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      contentLength = bodyLength ?? contentLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      const abort = (err) => {
        if (request.aborted || request.completed) {
          return;
        }
        util.errorRequest(client, request, err || new RequestAbortedError());
        util.destroy(body);
        util.destroy(socket, new InformationalError("aborted"));
      };
      try {
        request.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (Array.isArray(headers)) {
        for (let n = 0; n < headers.length; n += 2) {
          const key = headers[n + 0];
          const val = headers[n + 1];
          if (Array.isArray(val)) {
            for (let i = 0; i < val.length; i++) {
              header += `${key}: ${val[i]}\r
`;
            }
          } else {
            header += `${key}: ${val}\r
`;
          }
        }
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isBuffer(body)) {
        writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);
        } else {
          writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);
        }
      } else if (util.isStream(body)) {
        writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isIterable(body)) {
        writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else {
        assert(false);
      }
      return true;
    }
    function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      let finished = false;
      const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onClose = function() {
        queueMicrotask(() => {
          body.removeListener("error", onFinished);
        });
        if (!finished) {
          const err = new RequestAbortedError();
          queueMicrotask(() => onFinished(err));
        }
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
      if (body.errorEmitted ?? body.errored) {
        setImmediate(() => onFinished(body.errored));
      } else if (body.endEmitted ?? body.readableEnded) {
        setImmediate(() => onFinished(null));
      }
      if (body.closeEmitted ?? body.closed) {
        setImmediate(onClose);
      }
    }
    function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      try {
        if (!body) {
          if (contentLength === 0) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            assert(contentLength === null, "no body must not have content length");
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(body);
          socket.uncork();
          request.onBodySent(body);
          if (!expectsPayload && request.reset !== false) {
            socket[kReset] = true;
          }
        }
        request.onRequestSent();
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(buffer);
        socket.uncork();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      /**
       *
       * @param {object} arg
       * @param {AbortCallback} arg.abort
       * @param {import('net').Socket} arg.socket
       * @param {import('../core/request.js')} arg.request
       * @param {number} arg.contentLength
       * @param {import('./client.js')} arg.client
       * @param {boolean} arg.expectsPayload
       * @param {string} arg.header
       */
      constructor({ abort, socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        this.abort = abort;
        socket[kWriting] = true;
      }
      /**
       * @param {Buffer} chunk
       * @returns
       */
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload && request.reset !== false) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      /**
       * @returns {void}
       */
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        client[kResume]();
      }
      /**
       * @param {Error} [err]
       * @returns {void}
       */
      destroy(err) {
        const { socket, client, abort } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          abort(err);
        }
      }
    };
    module2.exports = connectH1;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/client-h2.js
var require_client_h2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/client-h2.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { pipeline } = require("node:stream");
    var util = require_util();
    var {
      RequestContentLengthMismatchError,
      RequestAbortedError,
      SocketError,
      InformationalError
    } = require_errors2();
    var {
      kUrl,
      kReset,
      kClient,
      kRunning,
      kPending,
      kQueue,
      kPendingIdx,
      kRunningIdx,
      kError,
      kSocket,
      kStrictContentLength,
      kOnError,
      kMaxConcurrentStreams,
      kHTTP2Session,
      kResume,
      kSize,
      kHTTPContext,
      kClosed,
      kBodyTimeout
    } = require_symbols2();
    var { channels } = require_diagnostics();
    var kOpenStreams = Symbol("open streams");
    var extractBody;
    var http2;
    try {
      http2 = require("node:http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    function parseH2Headers(headers) {
      const result = [];
      for (const [name, value] of Object.entries(headers)) {
        if (Array.isArray(value)) {
          for (const subvalue of value) {
            result.push(Buffer.from(name), Buffer.from(subvalue));
          }
        } else {
          result.push(Buffer.from(name), Buffer.from(value));
        }
      }
      return result;
    }
    async function connectH2(client, socket) {
      client[kSocket] = socket;
      const session = http2.connect(client[kUrl], {
        createConnection: () => socket,
        peerMaxConcurrentStreams: client[kMaxConcurrentStreams],
        settings: {
          // TODO(metcoder95): add support for PUSH
          enablePush: false
        }
      });
      session[kOpenStreams] = 0;
      session[kClient] = client;
      session[kSocket] = socket;
      session[kHTTP2Session] = null;
      util.addListener(session, "error", onHttp2SessionError);
      util.addListener(session, "frameError", onHttp2FrameError);
      util.addListener(session, "end", onHttp2SessionEnd);
      util.addListener(session, "goaway", onHttp2SessionGoAway);
      util.addListener(session, "close", onHttp2SessionClose);
      session.unref();
      client[kHTTP2Session] = session;
      socket[kHTTP2Session] = session;
      util.addListener(socket, "error", onHttp2SocketError);
      util.addListener(socket, "end", onHttp2SocketEnd);
      util.addListener(socket, "close", onHttp2SocketClose);
      socket[kClosed] = false;
      socket.on("close", onSocketClose);
      return {
        version: "h2",
        defaultPipelining: Infinity,
        write(request) {
          return writeH2(client, request);
        },
        resume() {
          resumeH2(client);
        },
        destroy(err, callback) {
          if (socket[kClosed]) {
            queueMicrotask(callback);
          } else {
            socket.destroy(err).on("close", callback);
          }
        },
        get destroyed() {
          return socket.destroyed;
        },
        busy() {
          return false;
        }
      };
    }
    function resumeH2(client) {
      const socket = client[kSocket];
      if (socket?.destroyed === false) {
        if (client[kSize] === 0 || client[kMaxConcurrentStreams] === 0) {
          socket.unref();
          client[kHTTP2Session].unref();
        } else {
          socket.ref();
          client[kHTTP2Session].ref();
        }
      }
    }
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttp2FrameError(type, code, id) {
      if (id === 0) {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        this[kSocket][kError] = err;
        this[kClient][kOnError](err);
      }
    }
    function onHttp2SessionEnd() {
      const err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
      this.destroy(err);
      util.destroy(this[kSocket], err);
    }
    function onHttp2SessionGoAway(errorCode) {
      const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${errorCode}`, util.getSocketInfo(this[kSocket]));
      const client = this[kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      this.close();
      this[kHTTP2Session] = null;
      util.destroy(this[kSocket], err);
      if (client[kRunningIdx] < client[kQueue].length) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        util.errorRequest(client, request, err);
        client[kPendingIdx] = client[kRunningIdx];
      }
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client.emit("connectionError", client[kUrl], [client], err);
      client[kResume]();
    }
    function onHttp2SessionClose() {
      const { [kClient]: client } = this;
      const { [kSocket]: socket } = client;
      const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket));
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client, request, err);
        }
      }
    }
    function onHttp2SocketClose() {
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      const client = this[kHTTP2Session][kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (this[kHTTP2Session] !== null) {
        this[kHTTP2Session].destroy(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function onHttp2SocketError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttp2SocketEnd() {
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      this[kClosed] = true;
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH2(client, request) {
      const requestTimeout = request.bodyTimeout ?? client[kBodyTimeout];
      const session = client[kHTTP2Session];
      const { method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let { body } = request;
      if (upgrade) {
        util.errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      const headers = {};
      for (let n = 0; n < reqHeaders.length; n += 2) {
        const key = reqHeaders[n + 0];
        const val = reqHeaders[n + 1];
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (headers[key]) {
              headers[key] += `, ${val[i]}`;
            } else {
              headers[key] = val[i];
            }
          }
        } else if (headers[key]) {
          headers[key] += `, ${val}`;
        } else {
          headers[key] = val;
        }
      }
      let stream = null;
      const { hostname, port } = client[kUrl];
      headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
      headers[HTTP2_HEADER_METHOD] = method;
      const abort = (err) => {
        if (request.aborted || request.completed) {
          return;
        }
        err = err || new RequestAbortedError();
        util.errorRequest(client, request, err);
        if (stream != null) {
          stream.removeAllListeners("data");
          stream.close();
          client[kOnError](err);
          client[kResume]();
        }
        util.destroy(body, err);
      };
      try {
        request.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (!stream.pending) {
          request.onUpgrade(null, null, stream);
          ++session[kOpenStreams];
          client[kQueue][client[kRunningIdx]++] = null;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++session[kOpenStreams];
            client[kQueue][client[kRunningIdx]++] = null;
          });
        }
        stream.once("close", () => {
          session[kOpenStreams] -= 1;
          if (session[kOpenStreams] === 0) session.unref();
        });
        stream.setTimeout(requestTimeout);
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (util.isFormDataLike(body)) {
        extractBody ??= require_body().extractBody;
        const [bodyStream, contentType] = extractBody(body);
        headers["content-type"] = contentType;
        body = bodyStream.stream;
        contentLength = bodyStream.length;
      }
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      if (channels.sendHeaders.hasSubscribers) {
        let header = "";
        for (const key in headers) {
          header += `${key}: ${headers[key]}\r
`;
        }
        channels.sendHeaders.publish({ request, headers: header, socket: session[kSocket] });
      }
      const shouldEndStream = method === "GET" || method === "HEAD" || body === null;
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++session[kOpenStreams];
      stream.setTimeout(requestTimeout);
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        request.onResponseStarted();
        if (request.aborted) {
          stream.removeAllListeners("data");
          return;
        }
        if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("end", (err) => {
        stream.removeAllListeners("data");
        if (stream.state?.state == null || stream.state.state < 6) {
          if (!request.aborted && !request.completed) {
            request.onComplete({});
          }
          client[kQueue][client[kRunningIdx]++] = null;
          client[kResume]();
        } else {
          --session[kOpenStreams];
          if (session[kOpenStreams] === 0) {
            session.unref();
          }
          abort(err ?? new InformationalError("HTTP/2: stream half-closed (remote)"));
          client[kQueue][client[kRunningIdx]++] = null;
          client[kPendingIdx] = client[kRunningIdx];
          client[kResume]();
        }
      });
      stream.once("close", () => {
        stream.removeAllListeners("data");
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        stream.removeAllListeners("data");
        abort(err);
      });
      stream.once("frameError", (type, code) => {
        stream.removeAllListeners("data");
        abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
      });
      stream.on("aborted", () => {
        stream.removeAllListeners("data");
      });
      stream.on("timeout", () => {
        const err = new InformationalError(`HTTP/2: "stream timeout after ${requestTimeout}"`);
        stream.removeAllListeners("data");
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
        abort(err);
      });
      stream.once("trailers", (trailers) => {
        if (request.aborted || request.completed) {
          return;
        }
        request.onComplete(trailers);
      });
      return true;
      function writeBodyH2() {
        if (!body || contentLength === 0) {
          writeBuffer(
            abort,
            stream,
            null,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBuffer(body)) {
          writeBuffer(
            abort,
            stream,
            body,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable(
              abort,
              stream,
              body.stream(),
              client,
              request,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          } else {
            writeBlob(
              abort,
              stream,
              body,
              client,
              request,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          }
        } else if (util.isStream(body)) {
          writeStream(
            abort,
            client[kSocket],
            expectsPayload,
            stream,
            body,
            client,
            request,
            contentLength
          );
        } else if (util.isIterable(body)) {
          writeIterable(
            abort,
            stream,
            body,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else {
          assert(false);
        }
      }
    }
    function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      try {
        if (body != null && util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          h2stream.cork();
          h2stream.write(body);
          h2stream.uncork();
          h2stream.end();
          request.onBodySent(body);
        }
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        request.onRequestSent();
        client[kResume]();
      } catch (error) {
        abort(error);
      }
    }
    function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      const pipe = pipeline(
        body,
        h2stream,
        (err) => {
          if (err) {
            util.destroy(pipe, err);
            abort(err);
          } else {
            util.removeAllListeners(pipe);
            request.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            client[kResume]();
          }
        }
      );
      util.addListener(pipe, "data", onPipeData);
      function onPipeData(chunk) {
        request.onBodySent(chunk);
      }
    }
    async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        h2stream.cork();
        h2stream.write(buffer);
        h2stream.uncork();
        h2stream.end();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk);
          request.onBodySent(chunk);
          if (!res) {
            await waitForDrain();
          }
        }
        h2stream.end();
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      } finally {
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
    }
    module2.exports = connectH2;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/client.js
var require_client = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/client.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var net = require("node:net");
    var http = require("node:http");
    var util = require_util();
    var { ClientStats } = require_stats();
    var { channels } = require_diagnostics();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      InvalidArgumentError,
      InformationalError,
      ClientDestroyedError
    } = require_errors2();
    var buildConnector = require_connect();
    var {
      kUrl,
      kServerName,
      kClient,
      kBusy,
      kConnect,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kLocalAddress,
      kMaxResponseSize,
      kOnError,
      kHTTPContext,
      kMaxConcurrentStreams,
      kResume
    } = require_symbols2();
    var connectH1 = require_client_h1();
    var connectH2 = require_client_h2();
    var kClosedResolve = Symbol("kClosedResolve");
    var getDefaultNodeMaxHeaderSize = http && http.maxHeaderSize && Number.isInteger(http.maxHeaderSize) && http.maxHeaderSize > 0 ? () => http.maxHeaderSize : () => {
      throw new InvalidArgumentError("http module not available or http.maxHeaderSize invalid");
    };
    var noop = () => {
    };
    function getPipelining(client) {
      return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;
    }
    var Client3 = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../../types/client.js').Client.Options} options
       */
      constructor(url, {
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        maxConcurrentStreams,
        allowH2
      } = {}) {
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null) {
          if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {
            throw new InvalidArgumentError("invalid maxHeaderSize");
          }
        } else {
          maxHeaderSize = getDefaultNodeMaxHeaderSize();
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
        }
        super();
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
        this[kHTTPContext] = null;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
        this[kResume] = (sync) => resume(this, sync);
        this[kOnError] = (err) => onError(this, err);
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        this[kResume](true);
      }
      get stats() {
        return new ClientStats(this);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
      }
      get [kBusy]() {
        return Boolean(
          this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0
        );
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = new Request(origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          queueMicrotask(() => resume(this));
        } else {
          this[kResume](true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (this[kSize]) {
            this[kClosedResolve] = resolve;
          } else {
            resolve(null);
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            util.errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve(null);
          };
          if (this[kHTTPContext]) {
            this[kHTTPContext].destroy(err, callback);
            this[kHTTPContext] = null;
          } else {
            queueMicrotask(callback);
          }
          this[kResume]();
        });
      }
    };
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kHTTPContext]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIPv6(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", noop), new ClientDestroyedError());
          return;
        }
        assert(socket);
        try {
          client[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client, socket) : await connectH1(client, socket);
        } catch (err) {
          socket.destroy().on("error", noop);
          throw err;
        }
        client[kConnecting] = false;
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: client[kHTTPContext]?.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: client[kHTTPContext]?.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            util.errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      client[kResume]();
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        if (client[kHTTPContext]) {
          client[kHTTPContext].resume();
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            queueMicrotask(() => emitDrain(client));
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (getPipelining(client) || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          client[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
            client[kHTTPContext] = null;
            resume(client);
          });
        }
        if (client[kConnecting]) {
          return;
        }
        if (!client[kHTTPContext]) {
          connect(client);
          return;
        }
        if (client[kHTTPContext].destroyed) {
          return;
        }
        if (client[kHTTPContext].busy(request)) {
          return;
        }
        if (!request.aborted && client[kHTTPContext].write(request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    module2.exports = Client3;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize).fill(void 0);
        this.next = null;
      }
      /**
       * @returns {boolean}
       */
      isEmpty() {
        return this.top === this.bottom;
      }
      /**
       * @returns {boolean}
       */
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      /**
       * @param {T} data
       * @returns {void}
       */
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      /**
       * @returns {T|null}
       */
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0) {
          return null;
        }
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      /**
       * @returns {boolean}
       */
      isEmpty() {
        return this.head.isEmpty();
      }
      /**
       * @param {T} data
       */
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      /**
       * @returns {T|null}
       */
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
          tail.next = null;
        }
        return next;
      }
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/pool-base.js"(exports2, module2) {
    "use strict";
    var { PoolStats } = require_stats();
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols2();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return new PoolStats(this);
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          await Promise.all(this[kClients].map((c) => c.close()));
        } else {
          await new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        await Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          queueMicrotask(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/pool.js
var require_pool = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher,
      kRemoveClient
    } = require_pool_base();
    var Client3 = require_client();
    var {
      InvalidArgumentError
    } = require_errors2();
    var util = require_util();
    var { kUrl } = require_symbols2();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client3(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        clientTtl,
        ...options
      } = {}) {
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        super();
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connect", (origin2, targets) => {
          if (clientTtl != null && clientTtl > 0) {
            for (const target of targets) {
              Object.assign(target, { ttl: Date.now() });
            }
          }
        });
        this.on("connectionError", (origin2, targets, error) => {
          for (const target of targets) {
            const idx = this[kClients].indexOf(target);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        const clientTtlOption = this[kOptions].clientTtl;
        for (const client of this[kClients]) {
          if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && Date.now() - client.ttl > clientTtlOption) {
            this[kRemoveClient](client);
          } else if (!client[kNeedDrain]) {
            return client;
          }
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
          return dispatcher;
        }
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors2();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl } = require_symbols2();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (a === 0) return b;
      while (b !== 0) {
        const t = b;
        b = a % b;
        a = t;
      }
      return a;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        let result = 0;
        for (let i = 0; i < this[kClients].length; i++) {
          result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
        }
        this[kGreatestCommonDivisor] = result;
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/agent.js
var require_agent = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors2();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kUrl } = require_symbols2();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client3 = require_client();
    var util = require_util();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client3(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, connect, ...options } = {}) {
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        super();
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kOnDrain] = (origin, targets) => {
          this.emit("drain", origin, [this, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          const result = this[kClients].get(origin);
          if (result) {
            result.count += 1;
          }
          this.emit("connect", origin, [this, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          const result = this[kClients].get(origin);
          if (result) {
            result.count -= 1;
            if (result.count <= 0) {
              this[kClients].delete(origin);
              result.dispatcher.destroy();
            }
          }
          this.emit("disconnect", origin, [this, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          this.emit("connectionError", origin, [this, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const { dispatcher } of this[kClients].values()) {
          ret += dispatcher[kRunning];
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const result = this[kClients].get(key);
        let dispatcher = result && result.dispatcher;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, { count: 0, dispatcher });
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const { dispatcher } of this[kClients].values()) {
          closePromises.push(dispatcher.close());
        }
        this[kClients].clear();
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const { dispatcher } of this[kClients].values()) {
          destroyPromises.push(dispatcher.destroy(err));
        }
        this[kClients].clear();
        await Promise.all(destroyPromises);
      }
      get stats() {
        const allClientStats = {};
        for (const { dispatcher } of this[kClients].values()) {
          if (dispatcher.stats) {
            allClientStats[dispatcher[kUrl].origin] = dispatcher.stats;
          }
        }
        return allClientStats;
      }
    };
    module2.exports = Agent;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kDispatch, kConnector } = require_symbols2();
    var { URL: URL2 } = require("node:url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require_errors2();
    var buildConnector = require_connect();
    var Client3 = require_client();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    var kTunnelProxy = Symbol("tunnel proxy");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var noop = () => {
    };
    var ProxyClient = class extends DispatcherBase {
      #client = null;
      constructor(origin, opts) {
        if (typeof origin === "string") {
          origin = new URL2(origin);
        }
        if (origin.protocol !== "http:" && origin.protocol !== "https:") {
          throw new InvalidArgumentError("ProxyClient only supports http and https protocols");
        }
        super();
        this.#client = new Client3(origin, opts);
      }
      async [kClose]() {
        await this.#client.close();
      }
      async [kDestroy]() {
        await this.#client.destroy();
      }
      async [kDispatch](opts, handler) {
        const { method, origin } = opts;
        if (method === "CONNECT") {
          this.#client[kConnector](
            {
              origin,
              port: opts.port || defaultProtocolPort(opts.protocol),
              path: opts.host,
              signal: opts.signal,
              headers: {
                ...this[kProxyHeaders],
                host: opts.host
              },
              servername: this[kProxyTls]?.servername || opts.servername
            },
            (err, socket) => {
              if (err) {
                handler.callback(err);
              } else {
                handler.callback(null, { socket, statusCode: 200 });
              }
            }
          );
          return;
        }
        if (typeof origin === "string") {
          opts.origin = new URL2(origin);
        }
        return this.#client.dispatch(opts, handler);
      }
    };
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        if (!opts || typeof opts === "object" && !(opts instanceof URL2) && !opts.uri) {
          throw new InvalidArgumentError("Proxy uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        const { proxyTunnel = true } = opts;
        super();
        const url = this.#getUrl(opts);
        const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
        this[kProxy] = { uri: href, protocol };
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const factory = !proxyTunnel && protocol === "http:" ? (origin2, options) => {
          if (origin2.protocol === "http:") {
            return new ProxyClient(origin2, options);
          }
          return new Client3(origin2, options);
        } : void 0;
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(url, { connect, factory });
        this[kTunnelProxy] = proxyTunnel;
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedPath = opts2.host;
            if (!opts2.port) {
              requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedPath,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host: opts2.host
                },
                servername: this[kProxyTls]?.servername || proxyHostname
              });
              if (statusCode !== 200) {
                socket.on("error", noop).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
                callback(new SecureProxyConnectionError(err));
              } else {
                callback(err);
              }
            }
          }
        });
      }
      dispatch(opts, handler) {
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        if (headers && !("host" in headers) && !("Host" in headers)) {
          const { host } = new URL2(opts.origin);
          headers.host = host;
        }
        if (!this.#shouldConnect(new URL2(opts.origin))) {
          opts.path = opts.origin + opts.path;
        }
        return this[kAgent].dispatch(
          {
            ...opts,
            headers
          },
          handler
        );
      }
      /**
       * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
       * @returns {URL}
       */
      #getUrl(opts) {
        if (typeof opts === "string") {
          return new URL2(opts);
        } else if (opts instanceof URL2) {
          return opts;
        } else {
          return new URL2(opts.uri);
        }
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
      #shouldConnect(uri) {
        if (typeof uri === "string") {
          uri = new URL2(uri);
        }
        if (this[kTunnelProxy]) {
          return true;
        }
        if (uri.protocol !== "http:" || this[kProxy].protocol !== "http:") {
          return true;
        }
        return false;
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js
var require_env_http_proxy_agent = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/env-http-proxy-agent.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require_symbols2();
    var ProxyAgent = require_proxy_agent();
    var Agent = require_agent();
    var DEFAULT_PORTS = {
      "http:": 80,
      "https:": 443
    };
    var EnvHttpProxyAgent = class extends DispatcherBase {
      #noProxyValue = null;
      #noProxyEntries = null;
      #opts = null;
      constructor(opts = {}) {
        super();
        this.#opts = opts;
        const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
        this[kNoProxyAgent] = new Agent(agentOpts);
        const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
        if (HTTP_PROXY) {
          this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
        } else {
          this[kHttpProxyAgent] = this[kNoProxyAgent];
        }
        const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
        if (HTTPS_PROXY) {
          this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
        } else {
          this[kHttpsProxyAgent] = this[kHttpProxyAgent];
        }
        this.#parseNoProxy();
      }
      [kDispatch](opts, handler) {
        const url = new URL(opts.origin);
        const agent = this.#getProxyAgentForUrl(url);
        return agent.dispatch(opts, handler);
      }
      async [kClose]() {
        await this[kNoProxyAgent].close();
        if (!this[kHttpProxyAgent][kClosed]) {
          await this[kHttpProxyAgent].close();
        }
        if (!this[kHttpsProxyAgent][kClosed]) {
          await this[kHttpsProxyAgent].close();
        }
      }
      async [kDestroy](err) {
        await this[kNoProxyAgent].destroy(err);
        if (!this[kHttpProxyAgent][kDestroyed]) {
          await this[kHttpProxyAgent].destroy(err);
        }
        if (!this[kHttpsProxyAgent][kDestroyed]) {
          await this[kHttpsProxyAgent].destroy(err);
        }
      }
      #getProxyAgentForUrl(url) {
        let { protocol, host: hostname, port } = url;
        hostname = hostname.replace(/:\d*$/, "").toLowerCase();
        port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
        if (!this.#shouldProxy(hostname, port)) {
          return this[kNoProxyAgent];
        }
        if (protocol === "https:") {
          return this[kHttpsProxyAgent];
        }
        return this[kHttpProxyAgent];
      }
      #shouldProxy(hostname, port) {
        if (this.#noProxyChanged) {
          this.#parseNoProxy();
        }
        if (this.#noProxyEntries.length === 0) {
          return true;
        }
        if (this.#noProxyValue === "*") {
          return false;
        }
        for (let i = 0; i < this.#noProxyEntries.length; i++) {
          const entry = this.#noProxyEntries[i];
          if (entry.port && entry.port !== port) {
            continue;
          }
          if (!/^[.*]/.test(entry.hostname)) {
            if (hostname === entry.hostname) {
              return false;
            }
          } else {
            if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
              return false;
            }
          }
        }
        return true;
      }
      #parseNoProxy() {
        const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
        const noProxySplit = noProxyValue.split(/[,\s]/);
        const noProxyEntries = [];
        for (let i = 0; i < noProxySplit.length; i++) {
          const entry = noProxySplit[i];
          if (!entry) {
            continue;
          }
          const parsed = entry.match(/^(.+):(\d+)$/);
          noProxyEntries.push({
            hostname: (parsed ? parsed[1] : entry).toLowerCase(),
            port: parsed ? Number.parseInt(parsed[2], 10) : 0
          });
        }
        this.#noProxyValue = noProxyValue;
        this.#noProxyEntries = noProxyEntries;
      }
      get #noProxyChanged() {
        if (this.#opts.noProxy !== void 0) {
          return false;
        }
        return this.#noProxyValue !== this.#noProxyEnv;
      }
      get #noProxyEnv() {
        return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
      }
    };
    module2.exports = EnvHttpProxyAgent;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/handler/retry-handler.js
var require_retry_handler = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/handler/retry-handler.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { kRetryHandlerDefaultRetry } = require_symbols2();
    var { RequestRetryError } = require_errors2();
    var WrapHandler = require_wrap_handler();
    var {
      isDisturbed,
      parseRangeHeader,
      wrapRequestBody
    } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const retryTime = new Date(retryAfter).getTime();
      return isNaN(retryTime) ? 0 : retryTime - Date.now();
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, { dispatch, handler }) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = dispatch;
        this.handler = WrapHandler.wrap(handler);
        this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          minTimeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE",
            "UND_ERR_SOCKET"
          ]
        };
        this.retryCount = 0;
        this.retryCountCheckpoint = 0;
        this.headersSent = false;
        this.start = 0;
        this.end = null;
        this.etag = null;
      }
      onRequestStart(controller, context2) {
        if (!this.headersSent) {
          this.handler.onRequestStart?.(controller, context2);
        }
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          minTimeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        const { counter } = state;
        if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers?.["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(headers["retry-after"]) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
        setTimeout(() => cb(null), retryTimeout);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        this.retryCount += 1;
        if (statusCode >= 300) {
          if (this.retryOpts.statusCodes.includes(statusCode) === false) {
            this.headersSent = true;
            this.handler.onResponseStart?.(
              controller,
              statusCode,
              headers,
              statusMessage
            );
            return;
          } else {
            throw new RequestRetryError("Request failed", statusCode, {
              headers,
              data: {
                count: this.retryCount
              }
            });
          }
        }
        if (this.headersSent) {
          if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
            throw new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            throw new RequestRetryError("Content-Range mismatch", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          if (this.etag != null && this.etag !== headers.etag) {
            throw new RequestRetryError("ETag mismatch", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          const { start, size, end = size ? size - 1 : null } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          return;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              this.headersSent = true;
              this.handler.onResponseStart?.(
                controller,
                statusCode,
                headers,
                statusMessage
              );
              return;
            }
            const { start, size, end = size ? size - 1 : null } = range;
            assert(
              start != null && Number.isFinite(start),
              "content-range mismatch"
            );
            assert(end != null && Number.isFinite(end), "invalid content-length");
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) - 1 : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = true;
          this.etag = headers.etag != null ? headers.etag : null;
          if (this.etag != null && this.etag[0] === "W" && this.etag[1] === "/") {
            this.etag = null;
          }
          this.headersSent = true;
          this.handler.onResponseStart?.(
            controller,
            statusCode,
            headers,
            statusMessage
          );
        } else {
          throw new RequestRetryError("Request failed", statusCode, {
            headers,
            data: { count: this.retryCount }
          });
        }
      }
      onResponseData(controller, chunk) {
        this.start += chunk.length;
        this.handler.onResponseData?.(controller, chunk);
      }
      onResponseEnd(controller, trailers) {
        this.retryCount = 0;
        return this.handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        if (controller?.aborted || isDisturbed(this.opts.body)) {
          this.handler.onResponseError?.(controller, err);
          return;
        }
        if (this.retryCount - this.retryCountCheckpoint > 0) {
          this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
        } else {
          this.retryCount += 1;
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || controller?.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onResponseError?.(controller, err2);
          }
          if (this.start !== 0) {
            const headers = { range: `bytes=${this.start}-${this.end ?? ""}` };
            if (this.etag != null) {
              headers["if-match"] = this.etag;
            }
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                ...headers
              }
            };
          }
          try {
            this.retryCountCheckpoint = this.retryCount;
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onResponseError?.(controller, err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/retry-agent.js
var require_retry_agent = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/retry-agent.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var RetryHandler = require_retry_handler();
    var RetryAgent = class extends Dispatcher {
      #agent = null;
      #options = null;
      constructor(agent, options = {}) {
        super(options);
        this.#agent = agent;
        this.#options = options;
      }
      dispatch(opts, handler) {
        const retry = new RetryHandler({
          ...opts,
          retryOptions: this.#options
        }, {
          dispatch: this.#agent.dispatch.bind(this.#agent),
          handler
        });
        return this.#agent.dispatch(opts, retry);
      }
      close() {
        return this.#agent.close();
      }
      destroy() {
        return this.#agent.destroy();
      }
    };
    module2.exports = RetryAgent;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/h2c-client.js
var require_h2c_client = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/dispatcher/h2c-client.js"(exports2, module2) {
    "use strict";
    var { connect } = require("node:net");
    var { kClose, kDestroy } = require_symbols2();
    var { InvalidArgumentError } = require_errors2();
    var util = require_util();
    var Client3 = require_client();
    var DispatcherBase = require_dispatcher_base();
    var H2CClient = class extends DispatcherBase {
      #client = null;
      constructor(origin, clientOpts) {
        super();
        if (typeof origin === "string") {
          origin = new URL(origin);
        }
        if (origin.protocol !== "http:") {
          throw new InvalidArgumentError(
            "h2c-client: Only h2c protocol is supported"
          );
        }
        const { connect: connect2, maxConcurrentStreams, pipelining, ...opts } = clientOpts ?? {};
        let defaultMaxConcurrentStreams = 100;
        let defaultPipelining = 100;
        if (maxConcurrentStreams != null && Number.isInteger(maxConcurrentStreams) && maxConcurrentStreams > 0) {
          defaultMaxConcurrentStreams = maxConcurrentStreams;
        }
        if (pipelining != null && Number.isInteger(pipelining) && pipelining > 0) {
          defaultPipelining = pipelining;
        }
        if (defaultPipelining > defaultMaxConcurrentStreams) {
          throw new InvalidArgumentError(
            "h2c-client: pipelining cannot be greater than maxConcurrentStreams"
          );
        }
        this.#client = new Client3(origin, {
          ...opts,
          connect: this.#buildConnector(connect2),
          maxConcurrentStreams: defaultMaxConcurrentStreams,
          pipelining: defaultPipelining,
          allowH2: true
        });
      }
      #buildConnector(connectOpts) {
        return (opts, callback) => {
          const timeout = connectOpts?.connectOpts ?? 1e4;
          const { hostname, port, pathname } = opts;
          const socket = connect({
            ...opts,
            host: hostname,
            port,
            pathname
          });
          if (opts.keepAlive == null || opts.keepAlive) {
            const keepAliveInitialDelay = opts.keepAliveInitialDelay == null ? 6e4 : opts.keepAliveInitialDelay;
            socket.setKeepAlive(true, keepAliveInitialDelay);
          }
          socket.alpnProtocol = "h2";
          const clearConnectTimeout = util.setupConnectTimeout(
            new WeakRef(socket),
            { timeout, hostname, port }
          );
          socket.setNoDelay(true).once("connect", function() {
            queueMicrotask(clearConnectTimeout);
            if (callback) {
              const cb = callback;
              callback = null;
              cb(null, this);
            }
          }).on("error", function(err) {
            queueMicrotask(clearConnectTimeout);
            if (callback) {
              const cb = callback;
              callback = null;
              cb(err);
            }
          });
          return socket;
        };
      }
      dispatch(opts, handler) {
        return this.#client.dispatch(opts, handler);
      }
      async [kClose]() {
        await this.#client.close();
      }
      async [kDestroy]() {
        await this.#client.destroy();
      }
    };
    module2.exports = H2CClient;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { Readable } = require("node:stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require_errors2();
    var util = require_util();
    var { ReadableStreamFrom } = require_util();
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("kAbort");
    var kContentType = Symbol("kContentType");
    var kContentLength = Symbol("kContentLength");
    var kUsed = Symbol("kUsed");
    var kBytesRead = Symbol("kBytesRead");
    var noop = () => {
    };
    var BodyReadable = class extends Readable {
      /**
       * @param {object} opts
       * @param {(this: Readable, size: number) => void} opts.resume
       * @param {() => (void | null)} opts.abort
       * @param {string} [opts.contentType = '']
       * @param {number} [opts.contentLength]
       * @param {number} [opts.highWaterMark = 64 * 1024]
       */
      constructor({
        resume,
        abort,
        contentType = "",
        contentLength,
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBytesRead] = 0;
        this[kBody] = null;
        this[kUsed] = false;
        this[kContentType] = contentType;
        this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null;
        this[kReading] = false;
      }
      /**
       * @param {Error|null} err
       * @param {(error:(Error|null)) => void} callback
       * @returns {void}
       */
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        if (!this[kUsed]) {
          setImmediate(() => {
            callback(err);
          });
        } else {
          callback(err);
        }
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      on(event, listener) {
        if (event === "data" || event === "readable") {
          this[kReading] = true;
          this[kUsed] = true;
        }
        return super.on(event, listener);
      }
      /**
       * @param {string} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      addListener(event, listener) {
        return this.on(event, listener);
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      off(event, listener) {
        const ret = super.off(event, listener);
        if (event === "data" || event === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      removeListener(event, listener) {
        return this.off(event, listener);
      }
      /**
       * @param {Buffer|null} chunk
       * @returns {boolean}
       */
      push(chunk) {
        this[kBytesRead] += chunk ? chunk.length : 0;
        if (this[kConsume] && chunk !== null) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      /**
       * Consumes and returns the body as a string.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-text
       * @returns {Promise<string>}
       */
      text() {
        return consume(this, "text");
      }
      /**
       * Consumes and returns the body as a JavaScript Object.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-json
       * @returns {Promise<unknown>}
       */
      json() {
        return consume(this, "json");
      }
      /**
       * Consumes and returns the body as a Blob
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-blob
       * @returns {Promise<Blob>}
       */
      blob() {
        return consume(this, "blob");
      }
      /**
       * Consumes and returns the body as an Uint8Array.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-bytes
       * @returns {Promise<Uint8Array>}
       */
      bytes() {
        return consume(this, "bytes");
      }
      /**
       * Consumes and returns the body as an ArrayBuffer.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer
       * @returns {Promise<ArrayBuffer>}
       */
      arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      /**
       * Not implemented
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-formdata
       * @throws {NotSupportedError}
       */
      async formData() {
        throw new NotSupportedError();
      }
      /**
       * Returns true if the body is not null and the body has been consumed.
       * Otherwise, returns false.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-bodyused
       * @readonly
       * @returns {boolean}
       */
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      /**
       * @see https://fetch.spec.whatwg.org/#dom-body-body
       * @readonly
       * @returns {ReadableStream}
       */
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      /**
       * Dumps the response body by reading `limit` number of bytes.
       * @param {object} opts
       * @param {number} [opts.limit = 131072] Number of bytes to read.
       * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.
       * @returns {Promise<null>}
       */
      async dump(opts) {
        const signal = opts?.signal;
        if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
          throw new InvalidArgumentError("signal must be an AbortSignal");
        }
        const limit = opts?.limit && Number.isFinite(opts.limit) ? opts.limit : 128 * 1024;
        signal?.throwIfAborted();
        if (this._readableState.closeEmitted) {
          return null;
        }
        return await new Promise((resolve, reject) => {
          if (this[kContentLength] && this[kContentLength] > limit || this[kBytesRead] > limit) {
            this.destroy(new AbortError());
          }
          if (signal) {
            const onAbort = () => {
              this.destroy(signal.reason ?? new AbortError());
            };
            signal.addEventListener("abort", onAbort);
            this.on("close", function() {
              signal.removeEventListener("abort", onAbort);
              if (signal.aborted) {
                reject(signal.reason ?? new AbortError());
              } else {
                resolve(null);
              }
            });
          } else {
            this.on("close", resolve);
          }
          this.on("error", noop).on("data", () => {
            if (this[kBytesRead] > limit) {
              this.destroy();
            }
          }).resume();
        });
      }
      /**
       * @param {BufferEncoding} encoding
       * @returns {this}
       */
      setEncoding(encoding) {
        if (Buffer.isEncoding(encoding)) {
          this._readableState.encoding = encoding;
        }
        return this;
      }
    };
    function isLocked(bodyReadable) {
      return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null;
    }
    function isUnusable(bodyReadable) {
      return util.isDisturbed(bodyReadable) || isLocked(bodyReadable);
    }
    function consume(stream, type) {
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        if (isUnusable(stream)) {
          const rState = stream._readableState;
          if (rState.destroyed && rState.closeEmitted === false) {
            stream.on("error", (err) => {
              reject(err);
            }).on("close", () => {
              reject(new TypeError("unusable"));
            });
          } else {
            reject(rState.errored ?? new TypeError("unusable"));
          }
        } else {
          queueMicrotask(() => {
            stream[kConsume] = {
              type,
              stream,
              resolve,
              reject,
              length: 0,
              body: []
            };
            stream.on("error", function(err) {
              consumeFinish(this[kConsume], err);
            }).on("close", function() {
              if (this[kConsume].body !== null) {
                consumeFinish(this[kConsume], new RequestAbortedError());
              }
            });
            consumeStart(stream[kConsume]);
          });
        }
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      if (state.bufferIndex) {
        const start = state.bufferIndex;
        const end = state.buffer.length;
        for (let n = start; n < end; n++) {
          consumePush(consume2, state.buffer[n]);
        }
      } else {
        for (const chunk of state.buffer) {
          consumePush(consume2, chunk);
        }
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume], this._readableState.encoding);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume], this._readableState.encoding);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function chunksDecode(chunks, length, encoding) {
      if (chunks.length === 0 || length === 0) {
        return "";
      }
      const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
      const bufferLength = buffer.length;
      const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
      if (!encoding || encoding === "utf8" || encoding === "utf-8") {
        return buffer.utf8Slice(start, bufferLength);
      } else {
        return buffer.subarray(start, bufferLength).toString(encoding);
      }
    }
    function chunksConcat(chunks, length) {
      if (chunks.length === 0 || length === 0) {
        return new Uint8Array(0);
      }
      if (chunks.length === 1) {
        return new Uint8Array(chunks[0]);
      }
      const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
      let offset = 0;
      for (let i = 0; i < chunks.length; ++i) {
        const chunk = chunks[i];
        buffer.set(chunk, offset);
        offset += chunk.length;
      }
      return buffer;
    }
    function consumeEnd(consume2, encoding) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(chunksDecode(body, length, encoding));
        } else if (type === "json") {
          resolve(JSON.parse(chunksDecode(body, length, encoding)));
        } else if (type === "arrayBuffer") {
          resolve(chunksConcat(body, length).buffer);
        } else if (type === "blob") {
          resolve(new Blob(body, { type: stream[kContentType] }));
        } else if (type === "bytes") {
          resolve(chunksConcat(body, length));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
    module2.exports = {
      Readable: BodyReadable,
      chunksDecode
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { AsyncResource } = require("node:async_hooks");
    var { Readable } = require_readable();
    var { InvalidArgumentError, RequestAbortedError } = require_errors2();
    var util = require_util();
    function noop() {
    }
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", noop), err);
          }
          throw err;
        }
        this.method = method;
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.highWaterMark = highWaterMark;
        this.reason = null;
        this.removeAbortListener = null;
        if (signal?.aborted) {
          this.reason = signal.reason ?? new RequestAbortedError();
        } else if (signal) {
          this.removeAbortListener = util.addAbortListener(signal, () => {
            this.reason = signal.reason ?? new RequestAbortedError();
            if (this.res) {
              util.destroy(this.res.on("error", noop), this.reason);
            } else if (this.abort) {
              this.abort(this.reason);
            }
          });
        }
      }
      onConnect(abort, context2) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context2;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context: context2, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const contentLength = parsedHeaders["content-length"];
        const res = new Readable({
          resume,
          abort,
          contentType,
          contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
          highWaterMark
        });
        if (this.removeAbortListener) {
          res.on("close", this.removeAbortListener);
          this.removeAbortListener = null;
        }
        this.callback = null;
        this.res = res;
        if (callback !== null) {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body: res,
            context: context2
          });
        }
      }
      onData(chunk) {
        return this.res.push(chunk);
      }
      onComplete(trailers) {
        util.parseHeaders(trailers, this.trailers);
        this.res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res.on("error", noop), err);
          });
        }
        if (body) {
          this.body = null;
          if (util.isStream(body)) {
            body.on("error", noop);
            util.destroy(body, err);
          }
        }
        if (this.removeAbortListener) {
          this.removeAbortListener();
          this.removeAbortListener = null;
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const handler = new RequestHandler(opts, callback);
        this.dispatch(opts, handler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    "use strict";
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors2();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self) {
      if (self.abort) {
        self.abort(self[kSignal]?.reason);
      } else {
        self.reason = self[kSignal]?.reason ?? new RequestAbortedError();
      }
      removeSignal(self);
    }
    function addSignal(self, signal) {
      self.reason = null;
      self[kSignal] = null;
      self[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self);
        return;
      }
      self[kSignal] = signal;
      self[kListener] = () => {
        abort(self);
      };
      addAbortListener(self[kSignal], self[kListener]);
    }
    function removeSignal(self) {
      if (!self[kSignal]) {
        return;
      }
      if ("removeEventListener" in self[kSignal]) {
        self[kSignal].removeEventListener("abort", self[kListener]);
      } else {
        self[kSignal].removeListener("abort", self[kListener]);
      }
      self[kSignal] = null;
      self[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { finished } = require("node:stream");
    var { AsyncResource } = require("node:async_hooks");
    var { InvalidArgumentError, InvalidReturnValueError } = require_errors2();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    function noop() {
    }
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", noop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context2;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context: context2, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        if (factory === null) {
          return;
        }
        const res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context: context2
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState?.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const handler = new StreamHandler(opts, factory, callback);
        this.dispatch(opts, handler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require("node:stream");
    var assert = require("node:assert");
    var { AsyncResource } = require("node:async_hooks");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors2();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    function noop() {
    }
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", noop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body?.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        const { res } = this;
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(!res, "pipeline cannot be retried");
        this.abort = abort;
        this.context = context2;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context: context2 } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context: context2
          });
        } catch (err) {
          this.res.on("error", noop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, SocketError } = require_errors2();
    var { AsyncResource } = require("node:async_hooks");
    var assert = require("node:assert");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        assert(statusCode === 101);
        const { callback, opaque, context: context2 } = this;
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context: context2
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        const upgradeOpts = {
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        };
        this.dispatch(upgradeOpts, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { AsyncResource } = require("node:async_hooks");
    var { InvalidArgumentError, SocketError } = require_errors2();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context2) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context2;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context: context2 } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context: context2
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        const connectOptions = { ...opts, method: "CONNECT" };
        this.dispatch(connectOptions, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors2();
    var MockNotMatchedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOriginalDispatch: Symbol("original dispatch"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected"),
      kIgnoreTrailingSlash: Symbol("ignore trailing slash"),
      kMockAgentMockCallHistoryInstance: Symbol("mock agent mock call history name"),
      kMockAgentRegisterCallHistory: Symbol("mock agent register mock call history"),
      kMockAgentAddCallHistoryLog: Symbol("mock agent add call history log"),
      kMockAgentIsCallHistoryEnabled: Symbol("mock agent is call history enabled"),
      kMockAgentAcceptsNonStandardSearchParameters: Symbol("mock agent accepts non standard search parameters"),
      kMockCallHistoryAddLog: Symbol("mock call history add log")
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { serializePathWithQuery } = require_util();
    var { STATUS_CODES } = require("node:http");
    var {
      types: {
        isPromise
      }
    } = require("node:util");
    var { InvalidArgumentError } = require_errors2();
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function normalizeSearchParams(query) {
      if (typeof query !== "string") {
        return query;
      }
      const originalQp = new URLSearchParams(query);
      const normalizedQp = new URLSearchParams();
      for (let [key, value] of originalQp.entries()) {
        key = key.replace("[]", "");
        const valueRepresentsString = /^(['"]).*\1$/.test(value);
        if (valueRepresentsString) {
          normalizedQp.append(key, value);
          continue;
        }
        if (value.includes(",")) {
          const values = value.split(",");
          for (const v of values) {
            normalizedQp.append(key, v);
          }
          continue;
        }
        normalizedQp.append(key, value);
      }
      return normalizedQp;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?", 3);
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else if (data) {
        return data.toString();
      } else {
        return "";
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath);
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path, ignoreTrailingSlash }) => {
        return ignoreTrailingSlash ? matchValue(removeTrailingSlash(safeUrl(path)), resolvedPathWithoutTrailingSlash) : matchValue(safeUrl(path), resolvedPath);
      });
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        const headers = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data, opts) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function removeTrailingSlash(path) {
      while (path.endsWith("/")) {
        path = path.slice(0, -1);
      }
      if (path.length === 0) {
        path = "/";
      }
      return path;
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      const keys = Object.keys(data);
      const result = [];
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = data[key];
        const name = Buffer.from(`${key}`);
        if (Array.isArray(value)) {
          for (let j = 0; j < value.length; ++j) {
            result.push(name, Buffer.from(`${value[j]}`));
          }
        } else {
          result.push(name, Buffer.from(`${value}`));
        }
      }
      return result;
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.onConnect?.((err) => handler.onError(err), null);
        handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData?.(Buffer.from(responseData));
        handler.onComplete?.(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildAndValidateMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        if ("enableCallHistory" in mockOptions && typeof mockOptions.enableCallHistory !== "boolean") {
          throw new InvalidArgumentError("options.enableCallHistory must to be a boolean");
        }
        if ("acceptNonStandardSearchParameters" in mockOptions && typeof mockOptions.acceptNonStandardSearchParameters !== "boolean") {
          throw new InvalidArgumentError("options.acceptNonStandardSearchParameters must to be a boolean");
        }
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildAndValidateMockOptions,
      getHeaderByName,
      buildHeadersFromArray,
      normalizeSearchParams
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors2();
    var { serializePathWithQuery } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = serializePathWithQuery(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData({ statusCode, data, responseOptions }) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(replyParameters) {
        if (typeof replyParameters.statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyOptionsCallbackOrStatusCode) {
        if (typeof replyOptionsCallbackOrStatusCode === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyOptionsCallbackOrStatusCode(opts);
            if (typeof resolvedData !== "object" || resolvedData === null) {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
            this.validateReplyParameters(replyParameters2);
            return {
              ...this.createMockScopeDispatchData(replyParameters2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
          return new MockScope(newMockDispatch2);
        }
        const replyParameters = {
          statusCode: replyOptionsCallbackOrStatusCode,
          data: arguments[1] === void 0 ? "" : arguments[1],
          responseOptions: arguments[2] === void 0 ? {} : arguments[2]
        };
        this.validateReplyParameters(replyParameters);
        const dispatchData = this.createMockScopeDispatchData(replyParameters);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("node:util");
    var Client3 = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols2();
    var { InvalidArgumentError } = require_errors2();
    var MockClient = class extends Client3 {
      constructor(origin, opts) {
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        super(origin, opts);
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(
          opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
          this[kDispatches]
        );
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-call-history.js
var require_mock_call_history = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-call-history.js"(exports2, module2) {
    "use strict";
    var { kMockCallHistoryAddLog } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors2();
    function handleFilterCallsWithOptions(criteria, options, handler, store) {
      switch (options.operator) {
        case "OR":
          store.push(...handler(criteria));
          return store;
        case "AND":
          return handler.call({ logs: store }, criteria);
        default:
          throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
      }
    }
    function buildAndValidateFilterCallsOptions(options = {}) {
      const finalOptions = {};
      if ("operator" in options) {
        if (typeof options.operator !== "string" || options.operator.toUpperCase() !== "OR" && options.operator.toUpperCase() !== "AND") {
          throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
        }
        return {
          ...finalOptions,
          operator: options.operator.toUpperCase()
        };
      }
      return finalOptions;
    }
    function makeFilterCalls(parameterName) {
      return (parameterValue) => {
        if (typeof parameterValue === "string" || parameterValue == null) {
          return this.logs.filter((log) => {
            return log[parameterName] === parameterValue;
          });
        }
        if (parameterValue instanceof RegExp) {
          return this.logs.filter((log) => {
            return parameterValue.test(log[parameterName]);
          });
        }
        throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`);
      };
    }
    function computeUrlWithMaybeSearchParameters(requestInit) {
      try {
        const url = new URL(requestInit.path, requestInit.origin);
        if (url.search.length !== 0) {
          return url;
        }
        url.search = new URLSearchParams(requestInit.query).toString();
        return url;
      } catch (error) {
        throw new InvalidArgumentError("An error occurred when computing MockCallHistoryLog.url", { cause: error });
      }
    }
    var MockCallHistoryLog = class {
      constructor(requestInit = {}) {
        this.body = requestInit.body;
        this.headers = requestInit.headers;
        this.method = requestInit.method;
        const url = computeUrlWithMaybeSearchParameters(requestInit);
        this.fullUrl = url.toString();
        this.origin = url.origin;
        this.path = url.pathname;
        this.searchParams = Object.fromEntries(url.searchParams);
        this.protocol = url.protocol;
        this.host = url.host;
        this.port = url.port;
        this.hash = url.hash;
      }
      toMap() {
        return /* @__PURE__ */ new Map(
          [
            ["protocol", this.protocol],
            ["host", this.host],
            ["port", this.port],
            ["origin", this.origin],
            ["path", this.path],
            ["hash", this.hash],
            ["searchParams", this.searchParams],
            ["fullUrl", this.fullUrl],
            ["method", this.method],
            ["body", this.body],
            ["headers", this.headers]
          ]
        );
      }
      toString() {
        const options = { betweenKeyValueSeparator: "->", betweenPairSeparator: "|" };
        let result = "";
        this.toMap().forEach((value, key) => {
          if (typeof value === "string" || value === void 0 || value === null) {
            result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`;
          }
          if (typeof value === "object" && value !== null || Array.isArray(value)) {
            result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`;
          }
        });
        return result.slice(0, -1);
      }
    };
    var MockCallHistory = class {
      logs = [];
      calls() {
        return this.logs;
      }
      firstCall() {
        return this.logs.at(0);
      }
      lastCall() {
        return this.logs.at(-1);
      }
      nthCall(number) {
        if (typeof number !== "number") {
          throw new InvalidArgumentError("nthCall must be called with a number");
        }
        if (!Number.isInteger(number)) {
          throw new InvalidArgumentError("nthCall must be called with an integer");
        }
        if (Math.sign(number) !== 1) {
          throw new InvalidArgumentError("nthCall must be called with a positive value. use firstCall or lastCall instead");
        }
        return this.logs.at(number - 1);
      }
      filterCalls(criteria, options) {
        if (this.logs.length === 0) {
          return this.logs;
        }
        if (typeof criteria === "function") {
          return this.logs.filter(criteria);
        }
        if (criteria instanceof RegExp) {
          return this.logs.filter((log) => {
            return criteria.test(log.toString());
          });
        }
        if (typeof criteria === "object" && criteria !== null) {
          if (Object.keys(criteria).length === 0) {
            return this.logs;
          }
          const finalOptions = { operator: "OR", ...buildAndValidateFilterCallsOptions(options) };
          let maybeDuplicatedLogsFiltered = [];
          if ("protocol" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered);
          }
          if ("host" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered);
          }
          if ("port" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered);
          }
          if ("origin" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered);
          }
          if ("path" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered);
          }
          if ("hash" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered);
          }
          if ("fullUrl" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered);
          }
          if ("method" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered);
          }
          const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)];
          return uniqLogsFiltered;
        }
        throw new InvalidArgumentError("criteria parameter should be one of function, regexp, or object");
      }
      filterCallsByProtocol = makeFilterCalls.call(this, "protocol");
      filterCallsByHost = makeFilterCalls.call(this, "host");
      filterCallsByPort = makeFilterCalls.call(this, "port");
      filterCallsByOrigin = makeFilterCalls.call(this, "origin");
      filterCallsByPath = makeFilterCalls.call(this, "path");
      filterCallsByHash = makeFilterCalls.call(this, "hash");
      filterCallsByFullUrl = makeFilterCalls.call(this, "fullUrl");
      filterCallsByMethod = makeFilterCalls.call(this, "method");
      clear() {
        this.logs = [];
      }
      [kMockCallHistoryAddLog](requestInit) {
        const log = new MockCallHistoryLog(requestInit);
        this.logs.push(log);
        return log;
      }
      *[Symbol.iterator]() {
        for (const log of this.calls()) {
          yield log;
        }
      }
    };
    module2.exports.MockCallHistory = MockCallHistory;
    module2.exports.MockCallHistoryLog = MockCallHistoryLog;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("node:util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols2();
    var { InvalidArgumentError } = require_errors2();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        super(origin, opts);
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(
          opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
          this[kDispatches]
        );
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("node:stream");
    var { Console } = require("node:console");
    var PERSISTENT = process.versions.icu ? "\u2705" : "Y ";
    var NOT_PERSISTENT = process.versions.icu ? "\u274C" : "N ";
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols2();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory,
      kMockAgentRegisterCallHistory,
      kMockAgentIsCallHistoryEnabled,
      kMockAgentAddCallHistoryLog,
      kMockAgentMockCallHistoryInstance,
      kMockAgentAcceptsNonStandardSearchParameters,
      kMockCallHistoryAddLog
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, normalizeSearchParams, buildAndValidateMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors2();
    var Dispatcher = require_dispatcher();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var { MockCallHistory } = require_mock_call_history();
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        const mockOptions = buildAndValidateMockOptions(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        this[kMockAgentIsCallHistoryEnabled] = mockOptions?.enableCallHistory ?? false;
        this[kMockAgentAcceptsNonStandardSearchParameters] = mockOptions?.acceptNonStandardSearchParameters ?? false;
        if (opts?.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts?.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = mockOptions;
        if (this[kMockAgentIsCallHistoryEnabled]) {
          this[kMockAgentRegisterCallHistory]();
        }
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        this[kMockAgentAddCallHistoryLog](opts);
        const acceptNonStandardSearchParameters = this[kMockAgentAcceptsNonStandardSearchParameters];
        const dispatchOpts = { ...opts };
        if (acceptNonStandardSearchParameters && dispatchOpts.path) {
          const [path, searchParams] = dispatchOpts.path.split("?");
          const normalizedSearchParams = normalizeSearchParams(searchParams, acceptNonStandardSearchParameters);
          dispatchOpts.path = `${path}?${normalizedSearchParams}`;
        }
        return this[kAgent].dispatch(dispatchOpts, handler);
      }
      async close() {
        this.clearCallHistory();
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      enableCallHistory() {
        this[kMockAgentIsCallHistoryEnabled] = true;
        return this;
      }
      disableCallHistory() {
        this[kMockAgentIsCallHistoryEnabled] = false;
        return this;
      }
      getCallHistory() {
        return this[kMockAgentMockCallHistoryInstance];
      }
      clearCallHistory() {
        if (this[kMockAgentMockCallHistoryInstance] !== void 0) {
          this[kMockAgentMockCallHistoryInstance].clear();
        }
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentRegisterCallHistory]() {
        if (this[kMockAgentMockCallHistoryInstance] === void 0) {
          this[kMockAgentMockCallHistoryInstance] = new MockCallHistory();
        }
      }
      [kMockAgentAddCallHistoryLog](opts) {
        if (this[kMockAgentIsCallHistoryEnabled]) {
          this[kMockAgentRegisterCallHistory]();
          this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts);
        }
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, { count: 0, dispatcher });
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const result = this[kClients].get(origin);
        if (result?.dispatcher) {
          return result.dispatcher;
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, result2] of Array.from(this[kClients])) {
          if (result2 && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = result2.dispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, result]) => result.dispatcher[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        throw new UndiciError(
          pending.length === 1 ? `1 interceptor is pending:

${pendingInterceptorsFormatter.format(pending)}`.trim() : `${pending.length} interceptors are pending:

${pendingInterceptorsFormatter.format(pending)}`.trim()
        );
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors2();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/handler/decorator-handler.js
var require_decorator_handler = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/handler/decorator-handler.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var WrapHandler = require_wrap_handler();
    module2.exports = class DecoratorHandler {
      #handler;
      #onCompleteCalled = false;
      #onErrorCalled = false;
      #onResponseStartCalled = false;
      constructor(handler) {
        if (typeof handler !== "object" || handler === null) {
          throw new TypeError("handler must be an object");
        }
        this.#handler = WrapHandler.wrap(handler);
      }
      onRequestStart(...args) {
        this.#handler.onRequestStart?.(...args);
      }
      onRequestUpgrade(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        return this.#handler.onRequestUpgrade?.(...args);
      }
      onResponseStart(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        assert(!this.#onResponseStartCalled);
        this.#onResponseStartCalled = true;
        return this.#handler.onResponseStart?.(...args);
      }
      onResponseData(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        return this.#handler.onResponseData?.(...args);
      }
      onResponseEnd(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        this.#onCompleteCalled = true;
        return this.#handler.onResponseEnd?.(...args);
      }
      onResponseError(...args) {
        this.#onErrorCalled = true;
        return this.#handler.onResponseError?.(...args);
      }
      /**
       * @deprecated
       */
      onBodySent() {
      }
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/handler/redirect-handler.js
var require_redirect_handler = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/handler/redirect-handler.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols2();
    var assert = require("node:assert");
    var { InvalidArgumentError } = require_errors2();
    var EE = require("node:events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var noop = () => {
    };
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class _RedirectHandler {
      static buildDispatch(dispatcher, maxRedirections) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        const dispatch = dispatcher.dispatch.bind(dispatcher);
        return (opts, originalHandler) => dispatch(opts, new _RedirectHandler(dispatch, maxRedirections, opts, originalHandler));
      }
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        this.dispatch = dispatch;
        this.location = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body) && !util.isFormDataLike(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onRequestStart(controller, context2) {
        this.handler.onRequestStart?.(controller, { ...context2, history: this.history });
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
          throw new Error("max redirects");
        }
        if ((statusCode === 301 || statusCode === 302) && this.opts.method === "POST") {
          this.opts.method = "GET";
          if (util.isStream(this.opts.body)) {
            util.destroy(this.opts.body.on("error", noop));
          }
          this.opts.body = null;
        }
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          if (util.isStream(this.opts.body)) {
            util.destroy(this.opts.body.on("error", noop));
          }
          this.opts.body = null;
        }
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1 ? null : headers.location;
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
          return;
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
      }
      onResponseData(controller, chunk) {
        if (this.location) {
        } else {
          this.handler.onResponseData?.(controller, chunk);
        }
      }
      onResponseEnd(controller, trailers) {
        if (this.location) {
          this.dispatch(this.opts, this);
        } else {
          this.handler.onResponseEnd(controller, trailers);
        }
      }
      onResponseError(controller, error) {
        this.handler.onResponseError?.(controller, error);
      }
    };
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        const entries = typeof headers[Symbol.iterator] === "function" ? headers : Object.entries(headers);
        for (const [key, value] of entries) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, value);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/interceptor/redirect.js
var require_redirect = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/interceptor/redirect.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_redirect_handler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections } = {}) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections, ...rest } = opts;
          if (maxRedirections == null || maxRedirections === 0) {
            return dispatch(opts, handler);
          }
          const dispatchOpts = { ...rest, maxRedirections: 0 };
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler);
          return dispatch(dispatchOpts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/interceptor/response-error.js
var require_response_error = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/interceptor/response-error.js"(exports2, module2) {
    "use strict";
    var DecoratorHandler = require_decorator_handler();
    var { ResponseError } = require_errors2();
    var ResponseErrorHandler = class extends DecoratorHandler {
      #statusCode;
      #contentType;
      #decoder;
      #headers;
      #body;
      constructor(_opts, { handler }) {
        super(handler);
      }
      #checkContentType(contentType) {
        return (this.#contentType ?? "").indexOf(contentType) === 0;
      }
      onRequestStart(controller, context2) {
        this.#statusCode = 0;
        this.#contentType = null;
        this.#decoder = null;
        this.#headers = null;
        this.#body = "";
        return super.onRequestStart(controller, context2);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        this.#statusCode = statusCode;
        this.#headers = headers;
        this.#contentType = headers["content-type"];
        if (this.#statusCode < 400) {
          return super.onResponseStart(controller, statusCode, headers, statusMessage);
        }
        if (this.#checkContentType("application/json") || this.#checkContentType("text/plain")) {
          this.#decoder = new TextDecoder("utf-8");
        }
      }
      onResponseData(controller, chunk) {
        if (this.#statusCode < 400) {
          return super.onResponseData(controller, chunk);
        }
        this.#body += this.#decoder?.decode(chunk, { stream: true }) ?? "";
      }
      onResponseEnd(controller, trailers) {
        if (this.#statusCode >= 400) {
          this.#body += this.#decoder?.decode(void 0, { stream: false }) ?? "";
          if (this.#checkContentType("application/json")) {
            try {
              this.#body = JSON.parse(this.#body);
            } catch {
            }
          }
          let err;
          const stackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          try {
            err = new ResponseError("Response Error", this.#statusCode, {
              body: this.#body,
              headers: this.#headers
            });
          } finally {
            Error.stackTraceLimit = stackTraceLimit;
          }
          super.onResponseError(controller, err);
        } else {
          super.onResponseEnd(controller, trailers);
        }
      }
      onResponseError(controller, err) {
        super.onResponseError(controller, err);
      }
    };
    module2.exports = () => {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          return dispatch(opts, new ResponseErrorHandler(opts, { handler }));
        };
      };
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/interceptor/retry.js
var require_retry = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/interceptor/retry.js"(exports2, module2) {
    "use strict";
    var RetryHandler = require_retry_handler();
    module2.exports = (globalOpts) => {
      return (dispatch) => {
        return function retryInterceptor(opts, handler) {
          return dispatch(
            opts,
            new RetryHandler(
              { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
              {
                handler,
                dispatch
              }
            )
          );
        };
      };
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/interceptor/dump.js
var require_dump = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/interceptor/dump.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError } = require_errors2();
    var DecoratorHandler = require_decorator_handler();
    var DumpHandler = class extends DecoratorHandler {
      #maxSize = 1024 * 1024;
      #dumped = false;
      #size = 0;
      #controller = null;
      aborted = false;
      reason = false;
      constructor({ maxSize, signal }, handler) {
        if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
          throw new InvalidArgumentError("maxSize must be a number greater than 0");
        }
        super(handler);
        this.#maxSize = maxSize ?? this.#maxSize;
      }
      #abort(reason) {
        this.aborted = true;
        this.reason = reason;
      }
      onRequestStart(controller, context2) {
        controller.abort = this.#abort.bind(this);
        this.#controller = controller;
        return super.onRequestStart(controller, context2);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        const contentLength = headers["content-length"];
        if (contentLength != null && contentLength > this.#maxSize) {
          throw new RequestAbortedError(
            `Response size (${contentLength}) larger than maxSize (${this.#maxSize})`
          );
        }
        if (this.aborted === true) {
          return true;
        }
        return super.onResponseStart(controller, statusCode, headers, statusMessage);
      }
      onResponseError(controller, err) {
        if (this.#dumped) {
          return;
        }
        err = this.#controller.reason ?? err;
        super.onResponseError(controller, err);
      }
      onResponseData(controller, chunk) {
        this.#size = this.#size + chunk.length;
        if (this.#size >= this.#maxSize) {
          this.#dumped = true;
          if (this.aborted === true) {
            super.onResponseError(controller, this.reason);
          } else {
            super.onResponseEnd(controller, {});
          }
        }
        return true;
      }
      onResponseEnd(controller, trailers) {
        if (this.#dumped) {
          return;
        }
        if (this.#controller.aborted === true) {
          super.onResponseError(controller, this.reason);
          return;
        }
        super.onResponseEnd(controller, trailers);
      }
    };
    function createDumpInterceptor({ maxSize: defaultMaxSize } = {
      maxSize: 1024 * 1024
    }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { dumpMaxSize = defaultMaxSize } = opts;
          const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler);
          return dispatch(opts, dumpHandler);
        };
      };
    }
    module2.exports = createDumpInterceptor;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/interceptor/dns.js
var require_dns = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/interceptor/dns.js"(exports2, module2) {
    "use strict";
    var { isIP } = require("node:net");
    var { lookup } = require("node:dns");
    var DecoratorHandler = require_decorator_handler();
    var { InvalidArgumentError, InformationalError } = require_errors2();
    var maxInt = Math.pow(2, 31) - 1;
    var DNSInstance = class {
      #maxTTL = 0;
      #maxItems = 0;
      #records = /* @__PURE__ */ new Map();
      dualStack = true;
      affinity = null;
      lookup = null;
      pick = null;
      constructor(opts) {
        this.#maxTTL = opts.maxTTL;
        this.#maxItems = opts.maxItems;
        this.dualStack = opts.dualStack;
        this.affinity = opts.affinity;
        this.lookup = opts.lookup ?? this.#defaultLookup;
        this.pick = opts.pick ?? this.#defaultPick;
      }
      get full() {
        return this.#records.size === this.#maxItems;
      }
      runLookup(origin, opts, cb) {
        const ips = this.#records.get(origin.hostname);
        if (ips == null && this.full) {
          cb(null, origin);
          return;
        }
        const newOpts = {
          affinity: this.affinity,
          dualStack: this.dualStack,
          lookup: this.lookup,
          pick: this.pick,
          ...opts.dns,
          maxTTL: this.#maxTTL,
          maxItems: this.#maxItems
        };
        if (ips == null) {
          this.lookup(origin, newOpts, (err, addresses) => {
            if (err || addresses == null || addresses.length === 0) {
              cb(err ?? new InformationalError("No DNS entries found"));
              return;
            }
            this.setRecords(origin, addresses);
            const records = this.#records.get(origin.hostname);
            const ip = this.pick(
              origin,
              records,
              newOpts.affinity
            );
            let port;
            if (typeof ip.port === "number") {
              port = `:${ip.port}`;
            } else if (origin.port !== "") {
              port = `:${origin.port}`;
            } else {
              port = "";
            }
            cb(
              null,
              new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
            );
          });
        } else {
          const ip = this.pick(
            origin,
            ips,
            newOpts.affinity
          );
          if (ip == null) {
            this.#records.delete(origin.hostname);
            this.runLookup(origin, opts, cb);
            return;
          }
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (origin.port !== "") {
            port = `:${origin.port}`;
          } else {
            port = "";
          }
          cb(
            null,
            new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
          );
        }
      }
      #defaultLookup(origin, opts, cb) {
        lookup(
          origin.hostname,
          {
            all: true,
            family: this.dualStack === false ? this.affinity : 0,
            order: "ipv4first"
          },
          (err, addresses) => {
            if (err) {
              return cb(err);
            }
            const results = /* @__PURE__ */ new Map();
            for (const addr of addresses) {
              results.set(`${addr.address}:${addr.family}`, addr);
            }
            cb(null, results.values());
          }
        );
      }
      #defaultPick(origin, hostnameRecords, affinity) {
        let ip = null;
        const { records, offset } = hostnameRecords;
        let family;
        if (this.dualStack) {
          if (affinity == null) {
            if (offset == null || offset === maxInt) {
              hostnameRecords.offset = 0;
              affinity = 4;
            } else {
              hostnameRecords.offset++;
              affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
            }
          }
          if (records[affinity] != null && records[affinity].ips.length > 0) {
            family = records[affinity];
          } else {
            family = records[affinity === 4 ? 6 : 4];
          }
        } else {
          family = records[affinity];
        }
        if (family == null || family.ips.length === 0) {
          return ip;
        }
        if (family.offset == null || family.offset === maxInt) {
          family.offset = 0;
        } else {
          family.offset++;
        }
        const position = family.offset % family.ips.length;
        ip = family.ips[position] ?? null;
        if (ip == null) {
          return ip;
        }
        if (Date.now() - ip.timestamp > ip.ttl) {
          family.ips.splice(position, 1);
          return this.pick(origin, hostnameRecords, affinity);
        }
        return ip;
      }
      pickFamily(origin, ipFamily) {
        const records = this.#records.get(origin.hostname)?.records;
        if (!records) {
          return null;
        }
        const family = records[ipFamily];
        if (!family) {
          return null;
        }
        if (family.offset == null || family.offset === maxInt) {
          family.offset = 0;
        } else {
          family.offset++;
        }
        const position = family.offset % family.ips.length;
        const ip = family.ips[position] ?? null;
        if (ip == null) {
          return ip;
        }
        if (Date.now() - ip.timestamp > ip.ttl) {
          family.ips.splice(position, 1);
        }
        return ip;
      }
      setRecords(origin, addresses) {
        const timestamp = Date.now();
        const records = { records: { 4: null, 6: null } };
        for (const record of addresses) {
          record.timestamp = timestamp;
          if (typeof record.ttl === "number") {
            record.ttl = Math.min(record.ttl, this.#maxTTL);
          } else {
            record.ttl = this.#maxTTL;
          }
          const familyRecords = records.records[record.family] ?? { ips: [] };
          familyRecords.ips.push(record);
          records.records[record.family] = familyRecords;
        }
        this.#records.set(origin.hostname, records);
      }
      deleteRecords(origin) {
        this.#records.delete(origin.hostname);
      }
      getHandler(meta, opts) {
        return new DNSDispatchHandler(this, meta, opts);
      }
    };
    var DNSDispatchHandler = class extends DecoratorHandler {
      #state = null;
      #opts = null;
      #dispatch = null;
      #origin = null;
      #controller = null;
      #newOrigin = null;
      #firstTry = true;
      constructor(state, { origin, handler, dispatch, newOrigin }, opts) {
        super(handler);
        this.#origin = origin;
        this.#newOrigin = newOrigin;
        this.#opts = { ...opts };
        this.#state = state;
        this.#dispatch = dispatch;
      }
      onResponseError(controller, err) {
        switch (err.code) {
          case "ETIMEDOUT":
          case "ECONNREFUSED": {
            if (this.#state.dualStack) {
              if (!this.#firstTry) {
                super.onResponseError(controller, err);
                return;
              }
              this.#firstTry = false;
              const otherFamily = this.#newOrigin.hostname[0] === "[" ? 4 : 6;
              const ip = this.#state.pickFamily(this.#origin, otherFamily);
              if (ip == null) {
                super.onResponseError(controller, err);
                return;
              }
              let port;
              if (typeof ip.port === "number") {
                port = `:${ip.port}`;
              } else if (this.#origin.port !== "") {
                port = `:${this.#origin.port}`;
              } else {
                port = "";
              }
              const dispatchOpts = {
                ...this.#opts,
                origin: `${this.#origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
              };
              this.#dispatch(dispatchOpts, this);
              return;
            }
            super.onResponseError(controller, err);
            break;
          }
          case "ENOTFOUND":
            this.#state.deleteRecords(this.#origin);
            super.onResponseError(controller, err);
            break;
          default:
            super.onResponseError(controller, err);
            break;
        }
      }
    };
    module2.exports = (interceptorOpts) => {
      if (interceptorOpts?.maxTTL != null && (typeof interceptorOpts?.maxTTL !== "number" || interceptorOpts?.maxTTL < 0)) {
        throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
      }
      if (interceptorOpts?.maxItems != null && (typeof interceptorOpts?.maxItems !== "number" || interceptorOpts?.maxItems < 1)) {
        throw new InvalidArgumentError(
          "Invalid maxItems. Must be a positive number and greater than zero"
        );
      }
      if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) {
        throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
      }
      if (interceptorOpts?.dualStack != null && typeof interceptorOpts?.dualStack !== "boolean") {
        throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
      }
      if (interceptorOpts?.lookup != null && typeof interceptorOpts?.lookup !== "function") {
        throw new InvalidArgumentError("Invalid lookup. Must be a function");
      }
      if (interceptorOpts?.pick != null && typeof interceptorOpts?.pick !== "function") {
        throw new InvalidArgumentError("Invalid pick. Must be a function");
      }
      const dualStack = interceptorOpts?.dualStack ?? true;
      let affinity;
      if (dualStack) {
        affinity = interceptorOpts?.affinity ?? null;
      } else {
        affinity = interceptorOpts?.affinity ?? 4;
      }
      const opts = {
        maxTTL: interceptorOpts?.maxTTL ?? 1e4,
        // Expressed in ms
        lookup: interceptorOpts?.lookup ?? null,
        pick: interceptorOpts?.pick ?? null,
        dualStack,
        affinity,
        maxItems: interceptorOpts?.maxItems ?? Infinity
      };
      const instance = new DNSInstance(opts);
      return (dispatch) => {
        return function dnsInterceptor(origDispatchOpts, handler) {
          const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
          if (isIP(origin.hostname) !== 0) {
            return dispatch(origDispatchOpts, handler);
          }
          instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
            if (err) {
              return handler.onResponseError(null, err);
            }
            const dispatchOpts = {
              ...origDispatchOpts,
              servername: origin.hostname,
              // For SNI on TLS
              origin: newOrigin.origin,
              headers: {
                host: origin.host,
                ...origDispatchOpts.headers
              }
            };
            dispatch(
              dispatchOpts,
              instance.getHandler(
                { origin, dispatch, handler, newOrigin },
                origDispatchOpts
              )
            );
          });
          return true;
        };
      };
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/util/cache.js
var require_cache = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/util/cache.js"(exports2, module2) {
    "use strict";
    var {
      safeHTTPMethods
    } = require_util();
    function makeCacheKey(opts) {
      if (!opts.origin) {
        throw new Error("opts.origin is undefined");
      }
      return {
        origin: opts.origin.toString(),
        method: opts.method,
        path: opts.path,
        headers: opts.headers
      };
    }
    function normaliseHeaders(opts) {
      let headers;
      if (opts.headers == null) {
        headers = {};
      } else if (typeof opts.headers[Symbol.iterator] === "function") {
        headers = {};
        for (const x of opts.headers) {
          if (!Array.isArray(x)) {
            throw new Error("opts.headers is not a valid header map");
          }
          const [key, val] = x;
          if (typeof key !== "string" || typeof val !== "string") {
            throw new Error("opts.headers is not a valid header map");
          }
          headers[key.toLowerCase()] = val;
        }
      } else if (typeof opts.headers === "object") {
        headers = {};
        for (const key of Object.keys(opts.headers)) {
          headers[key.toLowerCase()] = opts.headers[key];
        }
      } else {
        throw new Error("opts.headers is not an object");
      }
      return headers;
    }
    function assertCacheKey(key) {
      if (typeof key !== "object") {
        throw new TypeError(`expected key to be object, got ${typeof key}`);
      }
      for (const property of ["origin", "method", "path"]) {
        if (typeof key[property] !== "string") {
          throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`);
        }
      }
      if (key.headers !== void 0 && typeof key.headers !== "object") {
        throw new TypeError(`expected headers to be object, got ${typeof key}`);
      }
    }
    function assertCacheValue(value) {
      if (typeof value !== "object") {
        throw new TypeError(`expected value to be object, got ${typeof value}`);
      }
      for (const property of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) {
        if (typeof value[property] !== "number") {
          throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`);
        }
      }
      if (typeof value.statusMessage !== "string") {
        throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`);
      }
      if (value.headers != null && typeof value.headers !== "object") {
        throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`);
      }
      if (value.vary !== void 0 && typeof value.vary !== "object") {
        throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`);
      }
      if (value.etag !== void 0 && typeof value.etag !== "string") {
        throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`);
      }
    }
    function parseCacheControlHeader(header) {
      const output = {};
      let directives;
      if (Array.isArray(header)) {
        directives = [];
        for (const directive of header) {
          directives.push(...directive.split(","));
        }
      } else {
        directives = header.split(",");
      }
      for (let i = 0; i < directives.length; i++) {
        const directive = directives[i].toLowerCase();
        const keyValueDelimiter = directive.indexOf("=");
        let key;
        let value;
        if (keyValueDelimiter !== -1) {
          key = directive.substring(0, keyValueDelimiter).trimStart();
          value = directive.substring(keyValueDelimiter + 1);
        } else {
          key = directive.trim();
        }
        switch (key) {
          case "min-fresh":
          case "max-stale":
          case "max-age":
          case "s-maxage":
          case "stale-while-revalidate":
          case "stale-if-error": {
            if (value === void 0 || value[0] === " ") {
              continue;
            }
            if (value.length >= 2 && value[0] === '"' && value[value.length - 1] === '"') {
              value = value.substring(1, value.length - 1);
            }
            const parsedValue = parseInt(value, 10);
            if (parsedValue !== parsedValue) {
              continue;
            }
            if (key === "max-age" && key in output && output[key] >= parsedValue) {
              continue;
            }
            output[key] = parsedValue;
            break;
          }
          case "private":
          case "no-cache": {
            if (value) {
              if (value[0] === '"') {
                const headers = [value.substring(1)];
                let foundEndingQuote = value[value.length - 1] === '"';
                if (!foundEndingQuote) {
                  for (let j = i + 1; j < directives.length; j++) {
                    const nextPart = directives[j];
                    const nextPartLength = nextPart.length;
                    headers.push(nextPart.trim());
                    if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '"') {
                      foundEndingQuote = true;
                      break;
                    }
                  }
                }
                if (foundEndingQuote) {
                  let lastHeader = headers[headers.length - 1];
                  if (lastHeader[lastHeader.length - 1] === '"') {
                    lastHeader = lastHeader.substring(0, lastHeader.length - 1);
                    headers[headers.length - 1] = lastHeader;
                  }
                  if (key in output) {
                    output[key] = output[key].concat(headers);
                  } else {
                    output[key] = headers;
                  }
                }
              } else {
                if (key in output) {
                  output[key] = output[key].concat(value);
                } else {
                  output[key] = [value];
                }
              }
              break;
            }
          }
          // eslint-disable-next-line no-fallthrough
          case "public":
          case "no-store":
          case "must-revalidate":
          case "proxy-revalidate":
          case "immutable":
          case "no-transform":
          case "must-understand":
          case "only-if-cached":
            if (value) {
              continue;
            }
            output[key] = true;
            break;
          default:
            continue;
        }
      }
      return output;
    }
    function parseVaryHeader(varyHeader, headers) {
      if (typeof varyHeader === "string" && varyHeader.includes("*")) {
        return headers;
      }
      const output = (
        /** @type {Record<string, string | string[] | null>} */
        {}
      );
      const varyingHeaders = typeof varyHeader === "string" ? varyHeader.split(",") : varyHeader;
      for (const header of varyingHeaders) {
        const trimmedHeader = header.trim().toLowerCase();
        output[trimmedHeader] = headers[trimmedHeader] ?? null;
      }
      return output;
    }
    function isEtagUsable(etag) {
      if (etag.length <= 2) {
        return false;
      }
      if (etag[0] === '"' && etag[etag.length - 1] === '"') {
        return !(etag[1] === '"' || etag.startsWith('"W/'));
      }
      if (etag.startsWith('W/"') && etag[etag.length - 1] === '"') {
        return etag.length !== 4;
      }
      return false;
    }
    function assertCacheStore(store, name = "CacheStore") {
      if (typeof store !== "object" || store === null) {
        throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? "null" : typeof store}`);
      }
      for (const fn of ["get", "createWriteStream", "delete"]) {
        if (typeof store[fn] !== "function") {
          throw new TypeError(`${name} needs to have a \`${fn}()\` function`);
        }
      }
    }
    function assertCacheMethods(methods, name = "CacheMethods") {
      if (!Array.isArray(methods)) {
        throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? "null" : typeof methods}`);
      }
      if (methods.length === 0) {
        throw new TypeError(`${name} needs to have at least one method`);
      }
      for (const method of methods) {
        if (!safeHTTPMethods.includes(method)) {
          throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(", ")}, got ${method}`);
        }
      }
    }
    module2.exports = {
      makeCacheKey,
      normaliseHeaders,
      assertCacheKey,
      assertCacheValue,
      parseCacheControlHeader,
      parseVaryHeader,
      isEtagUsable,
      assertCacheMethods,
      assertCacheStore
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/util/date.js
var require_date = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/util/date.js"(exports2, module2) {
    "use strict";
    var IMF_DAYS = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"];
    var IMF_SPACES = [4, 7, 11, 16, 25];
    var IMF_MONTHS = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
    var IMF_COLONS = [19, 22];
    var ASCTIME_SPACES = [3, 7, 10, 19];
    var RFC850_DAYS = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
    function parseHttpDate(date, now) {
      date = date.toLowerCase();
      switch (date[3]) {
        case ",":
          return parseImfDate(date);
        case " ":
          return parseAscTimeDate(date);
        default:
          return parseRfc850Date(date, now);
      }
    }
    function parseImfDate(date) {
      if (date.length !== 29) {
        return void 0;
      }
      if (!date.endsWith("gmt")) {
        return void 0;
      }
      for (const spaceInx of IMF_SPACES) {
        if (date[spaceInx] !== " ") {
          return void 0;
        }
      }
      for (const colonIdx of IMF_COLONS) {
        if (date[colonIdx] !== ":") {
          return void 0;
        }
      }
      const dayName = date.substring(0, 3);
      if (!IMF_DAYS.includes(dayName)) {
        return void 0;
      }
      const dayString = date.substring(5, 7);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== "0") {
        return void 0;
      }
      const month = date.substring(8, 11);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      const year = Number.parseInt(date.substring(12, 16));
      if (isNaN(year)) {
        return void 0;
      }
      const hourString = date.substring(17, 19);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date.substring(20, 22);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date.substring(23, 25);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    function parseAscTimeDate(date) {
      if (date.length !== 24) {
        return void 0;
      }
      for (const spaceIdx of ASCTIME_SPACES) {
        if (date[spaceIdx] !== " ") {
          return void 0;
        }
      }
      const dayName = date.substring(0, 3);
      if (!IMF_DAYS.includes(dayName)) {
        return void 0;
      }
      const month = date.substring(4, 7);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      const dayString = date.substring(8, 10);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== " ") {
        return void 0;
      }
      const hourString = date.substring(11, 13);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date.substring(14, 16);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date.substring(17, 19);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      const year = Number.parseInt(date.substring(20, 24));
      if (isNaN(year)) {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    function parseRfc850Date(date, now = /* @__PURE__ */ new Date()) {
      if (!date.endsWith("gmt")) {
        return void 0;
      }
      const commaIndex = date.indexOf(",");
      if (commaIndex === -1) {
        return void 0;
      }
      if (date.length - commaIndex - 1 !== 23) {
        return void 0;
      }
      const dayName = date.substring(0, commaIndex);
      if (!RFC850_DAYS.includes(dayName)) {
        return void 0;
      }
      if (date[commaIndex + 1] !== " " || date[commaIndex + 4] !== "-" || date[commaIndex + 8] !== "-" || date[commaIndex + 11] !== " " || date[commaIndex + 14] !== ":" || date[commaIndex + 17] !== ":" || date[commaIndex + 20] !== " ") {
        return void 0;
      }
      const dayString = date.substring(commaIndex + 2, commaIndex + 4);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== "0") {
        return void 0;
      }
      const month = date.substring(commaIndex + 5, commaIndex + 8);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      let year = Number.parseInt(date.substring(commaIndex + 9, commaIndex + 11));
      if (isNaN(year)) {
        return void 0;
      }
      const currentYear = now.getUTCFullYear();
      const currentDecade = currentYear % 100;
      const currentCentury = Math.floor(currentYear / 100);
      if (year > currentDecade && year - currentDecade >= 50) {
        year += (currentCentury - 1) * 100;
      } else {
        year += currentCentury * 100;
      }
      const hourString = date.substring(commaIndex + 12, commaIndex + 14);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date.substring(commaIndex + 15, commaIndex + 17);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date.substring(commaIndex + 18, commaIndex + 20);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    module2.exports = {
      parseHttpDate
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/handler/cache-handler.js
var require_cache_handler = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/handler/cache-handler.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var {
      parseCacheControlHeader,
      parseVaryHeader,
      isEtagUsable
    } = require_cache();
    var { parseHttpDate } = require_date();
    function noop() {
    }
    var HEURISTICALLY_CACHEABLE_STATUS_CODES = [
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ];
    var MAX_RESPONSE_AGE = 2147483647e3;
    var CacheHandler = class {
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}
       */
      #cacheKey;
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}
       */
      #cacheType;
      /**
       * @type {number | undefined}
       */
      #cacheByDefault;
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}
       */
      #store;
      /**
       * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}
       */
      #handler;
      /**
       * @type {import('node:stream').Writable | undefined}
       */
      #writeStream;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey
       * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler
       */
      constructor({ store, type, cacheByDefault }, cacheKey, handler) {
        this.#store = store;
        this.#cacheType = type;
        this.#cacheByDefault = cacheByDefault;
        this.#cacheKey = cacheKey;
        this.#handler = handler;
      }
      onRequestStart(controller, context2) {
        this.#writeStream?.destroy();
        this.#writeStream = void 0;
        this.#handler.onRequestStart?.(controller, context2);
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      /**
       * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
       * @param {number} statusCode
       * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders
       * @param {string} statusMessage
       */
      onResponseStart(controller, statusCode, resHeaders, statusMessage) {
        const downstreamOnHeaders = () => this.#handler.onResponseStart?.(
          controller,
          statusCode,
          resHeaders,
          statusMessage
        );
        if (!util.safeHTTPMethods.includes(this.#cacheKey.method) && statusCode >= 200 && statusCode <= 399) {
          try {
            this.#store.delete(this.#cacheKey)?.catch?.(noop);
          } catch {
          }
          return downstreamOnHeaders();
        }
        const cacheControlHeader = resHeaders["cache-control"];
        const heuristicallyCacheable = resHeaders["last-modified"] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode);
        if (!cacheControlHeader && !resHeaders["expires"] && !heuristicallyCacheable && !this.#cacheByDefault) {
          return downstreamOnHeaders();
        }
        const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {};
        if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {
          return downstreamOnHeaders();
        }
        const now = Date.now();
        const resAge = resHeaders.age ? getAge(resHeaders.age) : void 0;
        if (resAge && resAge >= MAX_RESPONSE_AGE) {
          return downstreamOnHeaders();
        }
        const resDate = typeof resHeaders.date === "string" ? parseHttpDate(resHeaders.date) : void 0;
        const staleAt = determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ?? this.#cacheByDefault;
        if (staleAt === void 0 || resAge && resAge > staleAt) {
          return downstreamOnHeaders();
        }
        const baseTime = resDate ? resDate.getTime() : now;
        const absoluteStaleAt = staleAt + baseTime;
        if (now >= absoluteStaleAt) {
          return downstreamOnHeaders();
        }
        let varyDirectives;
        if (this.#cacheKey.headers && resHeaders.vary) {
          varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers);
          if (!varyDirectives) {
            return downstreamOnHeaders();
          }
        }
        const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt);
        const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives);
        const value = {
          statusCode,
          statusMessage,
          headers: strippedHeaders,
          vary: varyDirectives,
          cacheControlDirectives,
          cachedAt: resAge ? now - resAge : now,
          staleAt: absoluteStaleAt,
          deleteAt
        };
        if (typeof resHeaders.etag === "string" && isEtagUsable(resHeaders.etag)) {
          value.etag = resHeaders.etag;
        }
        this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value);
        if (!this.#writeStream) {
          return downstreamOnHeaders();
        }
        const handler = this;
        this.#writeStream.on("drain", () => controller.resume()).on("error", function() {
          handler.#writeStream = void 0;
          handler.#store.delete(handler.#cacheKey);
        }).on("close", function() {
          if (handler.#writeStream === this) {
            handler.#writeStream = void 0;
          }
          controller.resume();
        });
        return downstreamOnHeaders();
      }
      onResponseData(controller, chunk) {
        if (this.#writeStream?.write(chunk) === false) {
          controller.pause();
        }
        this.#handler.onResponseData?.(controller, chunk);
      }
      onResponseEnd(controller, trailers) {
        this.#writeStream?.end();
        this.#handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        this.#writeStream?.destroy(err);
        this.#writeStream = void 0;
        this.#handler.onResponseError?.(controller, err);
      }
    };
    function canCacheResponse(cacheType, statusCode, resHeaders, cacheControlDirectives) {
      if (statusCode !== 200 && statusCode !== 307) {
        return false;
      }
      if (cacheControlDirectives["no-store"]) {
        return false;
      }
      if (cacheType === "shared" && cacheControlDirectives.private === true) {
        return false;
      }
      if (resHeaders.vary?.includes("*")) {
        return false;
      }
      if (resHeaders.authorization) {
        if (!cacheControlDirectives.public || typeof resHeaders.authorization !== "string") {
          return false;
        }
        if (Array.isArray(cacheControlDirectives["no-cache"]) && cacheControlDirectives["no-cache"].includes("authorization")) {
          return false;
        }
        if (Array.isArray(cacheControlDirectives["private"]) && cacheControlDirectives["private"].includes("authorization")) {
          return false;
        }
      }
      return true;
    }
    function getAge(ageHeader) {
      const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader);
      return isNaN(age) ? void 0 : age * 1e3;
    }
    function determineStaleAt(cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {
      if (cacheType === "shared") {
        const sMaxAge = cacheControlDirectives["s-maxage"];
        if (sMaxAge !== void 0) {
          return sMaxAge > 0 ? sMaxAge * 1e3 : void 0;
        }
      }
      const maxAge = cacheControlDirectives["max-age"];
      if (maxAge !== void 0) {
        return maxAge > 0 ? maxAge * 1e3 : void 0;
      }
      if (typeof resHeaders.expires === "string") {
        const expiresDate = parseHttpDate(resHeaders.expires);
        if (expiresDate) {
          if (now >= expiresDate.getTime()) {
            return void 0;
          }
          if (responseDate) {
            if (responseDate >= expiresDate) {
              return void 0;
            }
            if (age !== void 0 && age > expiresDate - responseDate) {
              return void 0;
            }
          }
          return expiresDate.getTime() - now;
        }
      }
      if (typeof resHeaders["last-modified"] === "string") {
        const lastModified = new Date(resHeaders["last-modified"]);
        if (isValidDate(lastModified)) {
          if (lastModified.getTime() >= now) {
            return void 0;
          }
          const responseAge = now - lastModified.getTime();
          return responseAge * 0.1;
        }
      }
      if (cacheControlDirectives.immutable) {
        return 31536e3;
      }
      return void 0;
    }
    function determineDeleteAt(now, cacheControlDirectives, staleAt) {
      let staleWhileRevalidate = -Infinity;
      let staleIfError = -Infinity;
      let immutable = -Infinity;
      if (cacheControlDirectives["stale-while-revalidate"]) {
        staleWhileRevalidate = staleAt + cacheControlDirectives["stale-while-revalidate"] * 1e3;
      }
      if (cacheControlDirectives["stale-if-error"]) {
        staleIfError = staleAt + cacheControlDirectives["stale-if-error"] * 1e3;
      }
      if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {
        immutable = now + 31536e6;
      }
      return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable);
    }
    function stripNecessaryHeaders(resHeaders, cacheControlDirectives) {
      const headersToRemove = [
        "connection",
        "proxy-authenticate",
        "proxy-authentication-info",
        "proxy-authorization",
        "proxy-connection",
        "te",
        "transfer-encoding",
        "upgrade",
        // We'll add age back when serving it
        "age"
      ];
      if (resHeaders["connection"]) {
        if (Array.isArray(resHeaders["connection"])) {
          headersToRemove.push(...resHeaders["connection"].map((header) => header.trim()));
        } else {
          headersToRemove.push(...resHeaders["connection"].split(",").map((header) => header.trim()));
        }
      }
      if (Array.isArray(cacheControlDirectives["no-cache"])) {
        headersToRemove.push(...cacheControlDirectives["no-cache"]);
      }
      if (Array.isArray(cacheControlDirectives["private"])) {
        headersToRemove.push(...cacheControlDirectives["private"]);
      }
      let strippedHeaders;
      for (const headerName of headersToRemove) {
        if (resHeaders[headerName]) {
          strippedHeaders ??= { ...resHeaders };
          delete strippedHeaders[headerName];
        }
      }
      return strippedHeaders ?? resHeaders;
    }
    function isValidDate(date) {
      return date instanceof Date && Number.isFinite(date.valueOf());
    }
    module2.exports = CacheHandler;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/cache/memory-cache-store.js
var require_memory_cache_store = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/cache/memory-cache-store.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("node:stream");
    var { EventEmitter: EventEmitter2 } = require("node:events");
    var { assertCacheKey, assertCacheValue } = require_cache();
    var MemoryCacheStore = class extends EventEmitter2 {
      #maxCount = Infinity;
      #maxSize = Infinity;
      #maxEntrySize = Infinity;
      #size = 0;
      #count = 0;
      #entries = /* @__PURE__ */ new Map();
      #hasEmittedMaxSizeEvent = false;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]
       */
      constructor(opts) {
        super();
        if (opts) {
          if (typeof opts !== "object") {
            throw new TypeError("MemoryCacheStore options must be an object");
          }
          if (opts.maxCount !== void 0) {
            if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
              throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
            }
            this.#maxCount = opts.maxCount;
          }
          if (opts.maxSize !== void 0) {
            if (typeof opts.maxSize !== "number" || !Number.isInteger(opts.maxSize) || opts.maxSize < 0) {
              throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
            }
            this.#maxSize = opts.maxSize;
          }
          if (opts.maxEntrySize !== void 0) {
            if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
              throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
            }
            this.#maxEntrySize = opts.maxEntrySize;
          }
        }
      }
      /**
       * Get the current size of the cache in bytes
       * @returns {number} The current size of the cache in bytes
       */
      get size() {
        return this.#size;
      }
      /**
       * Check if the cache is full (either max size or max count reached)
       * @returns {boolean} True if the cache is full, false otherwise
       */
      isFull() {
        return this.#size >= this.#maxSize || this.#count >= this.#maxCount;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req
       * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}
       */
      get(key) {
        assertCacheKey(key);
        const topLevelKey = `${key.origin}:${key.path}`;
        const now = Date.now();
        const entries = this.#entries.get(topLevelKey);
        const entry = entries ? findEntry(key, entries, now) : null;
        return entry == null ? void 0 : {
          statusMessage: entry.statusMessage,
          statusCode: entry.statusCode,
          headers: entry.headers,
          body: entry.body,
          vary: entry.vary ? entry.vary : void 0,
          etag: entry.etag,
          cacheControlDirectives: entry.cacheControlDirectives,
          cachedAt: entry.cachedAt,
          staleAt: entry.staleAt,
          deleteAt: entry.deleteAt
        };
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val
       * @returns {Writable | undefined}
       */
      createWriteStream(key, val) {
        assertCacheKey(key);
        assertCacheValue(val);
        const topLevelKey = `${key.origin}:${key.path}`;
        const store = this;
        const entry = { ...key, ...val, body: [], size: 0 };
        return new Writable({
          write(chunk, encoding, callback) {
            if (typeof chunk === "string") {
              chunk = Buffer.from(chunk, encoding);
            }
            entry.size += chunk.byteLength;
            if (entry.size >= store.#maxEntrySize) {
              this.destroy();
            } else {
              entry.body.push(chunk);
            }
            callback(null);
          },
          final(callback) {
            let entries = store.#entries.get(topLevelKey);
            if (!entries) {
              entries = [];
              store.#entries.set(topLevelKey, entries);
            }
            const previousEntry = findEntry(key, entries, Date.now());
            if (previousEntry) {
              const index = entries.indexOf(previousEntry);
              entries.splice(index, 1, entry);
              store.#size -= previousEntry.size;
            } else {
              entries.push(entry);
              store.#count += 1;
            }
            store.#size += entry.size;
            if (store.#size > store.#maxSize || store.#count > store.#maxCount) {
              if (!store.#hasEmittedMaxSizeEvent) {
                store.emit("maxSizeExceeded", {
                  size: store.#size,
                  maxSize: store.#maxSize,
                  count: store.#count,
                  maxCount: store.#maxCount
                });
                store.#hasEmittedMaxSizeEvent = true;
              }
              for (const [key2, entries2] of store.#entries) {
                for (const entry2 of entries2.splice(0, entries2.length / 2)) {
                  store.#size -= entry2.size;
                  store.#count -= 1;
                }
                if (entries2.length === 0) {
                  store.#entries.delete(key2);
                }
              }
              if (store.#size < store.#maxSize && store.#count < store.#maxCount) {
                store.#hasEmittedMaxSizeEvent = false;
              }
            }
            callback(null);
          }
        });
      }
      /**
       * @param {CacheKey} key
       */
      delete(key) {
        if (typeof key !== "object") {
          throw new TypeError(`expected key to be object, got ${typeof key}`);
        }
        const topLevelKey = `${key.origin}:${key.path}`;
        for (const entry of this.#entries.get(topLevelKey) ?? []) {
          this.#size -= entry.size;
          this.#count -= 1;
        }
        this.#entries.delete(topLevelKey);
      }
    };
    function findEntry(key, entries, now) {
      return entries.find((entry) => entry.deleteAt > now && entry.method === key.method && (entry.vary == null || Object.keys(entry.vary).every((headerName) => {
        if (entry.vary[headerName] === null) {
          return key.headers[headerName] === void 0;
        }
        return entry.vary[headerName] === key.headers[headerName];
      })));
    }
    module2.exports = MemoryCacheStore;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/handler/cache-revalidation-handler.js
var require_cache_revalidation_handler = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/handler/cache-revalidation-handler.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var CacheRevalidationHandler = class {
      #successful = false;
      /**
       * @type {((boolean, any) => void) | null}
       */
      #callback;
      /**
       * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}
       */
      #handler;
      #context;
      /**
       * @type {boolean}
       */
      #allowErrorStatusCodes;
      /**
       * @param {(boolean) => void} callback Function to call if the cached value is valid
       * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler
       * @param {boolean} allowErrorStatusCodes
       */
      constructor(callback, handler, allowErrorStatusCodes) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        this.#callback = callback;
        this.#handler = handler;
        this.#allowErrorStatusCodes = allowErrorStatusCodes;
      }
      onRequestStart(_, context2) {
        this.#successful = false;
        this.#context = context2;
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        assert(this.#callback != null);
        this.#successful = statusCode === 304 || this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504;
        this.#callback(this.#successful, this.#context);
        this.#callback = null;
        if (this.#successful) {
          return true;
        }
        this.#handler.onRequestStart?.(controller, this.#context);
        this.#handler.onResponseStart?.(
          controller,
          statusCode,
          headers,
          statusMessage
        );
      }
      onResponseData(controller, chunk) {
        if (this.#successful) {
          return;
        }
        return this.#handler.onResponseData?.(controller, chunk);
      }
      onResponseEnd(controller, trailers) {
        if (this.#successful) {
          return;
        }
        this.#handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        if (this.#successful) {
          return;
        }
        if (this.#callback) {
          this.#callback(false);
          this.#callback = null;
        }
        if (typeof this.#handler.onResponseError === "function") {
          this.#handler.onResponseError(controller, err);
        } else {
          throw err;
        }
      }
    };
    module2.exports = CacheRevalidationHandler;
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/interceptor/cache.js
var require_cache2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/interceptor/cache.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { Readable } = require("node:stream");
    var util = require_util();
    var CacheHandler = require_cache_handler();
    var MemoryCacheStore = require_memory_cache_store();
    var CacheRevalidationHandler = require_cache_revalidation_handler();
    var { assertCacheStore, assertCacheMethods, makeCacheKey, normaliseHeaders, parseCacheControlHeader } = require_cache();
    var { AbortError } = require_errors2();
    function needsRevalidation(result, cacheControlDirectives) {
      if (cacheControlDirectives?.["no-cache"]) {
        return true;
      }
      if (result.cacheControlDirectives?.["no-cache"] && !Array.isArray(result.cacheControlDirectives["no-cache"])) {
        return true;
      }
      const now = Date.now();
      if (now > result.staleAt) {
        if (cacheControlDirectives?.["max-stale"]) {
          const gracePeriod = result.staleAt + cacheControlDirectives["max-stale"] * 1e3;
          return now > gracePeriod;
        }
        return true;
      }
      if (cacheControlDirectives?.["min-fresh"]) {
        const timeLeftTillStale = result.staleAt - now;
        const threshold = cacheControlDirectives["min-fresh"] * 1e3;
        return timeLeftTillStale <= threshold;
      }
      return false;
    }
    function handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl) {
      if (reqCacheControl?.["only-if-cached"]) {
        let aborted = false;
        try {
          if (typeof handler.onConnect === "function") {
            handler.onConnect(() => {
              aborted = true;
            });
            if (aborted) {
              return;
            }
          }
          if (typeof handler.onHeaders === "function") {
            handler.onHeaders(504, [], () => {
            }, "Gateway Timeout");
            if (aborted) {
              return;
            }
          }
          if (typeof handler.onComplete === "function") {
            handler.onComplete([]);
          }
        } catch (err) {
          if (typeof handler.onError === "function") {
            handler.onError(err);
          }
        }
        return true;
      }
      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
    }
    function sendCachedValue(handler, opts, result, age, context2, isStale) {
      const stream = util.isStream(result.body) ? result.body : Readable.from(result.body ?? []);
      assert(!stream.destroyed, "stream should not be destroyed");
      assert(!stream.readableDidRead, "stream should not be readableDidRead");
      const controller = {
        resume() {
          stream.resume();
        },
        pause() {
          stream.pause();
        },
        get paused() {
          return stream.isPaused();
        },
        get aborted() {
          return stream.destroyed;
        },
        get reason() {
          return stream.errored;
        },
        abort(reason) {
          stream.destroy(reason ?? new AbortError());
        }
      };
      stream.on("error", function(err) {
        if (!this.readableEnded) {
          if (typeof handler.onResponseError === "function") {
            handler.onResponseError(controller, err);
          } else {
            throw err;
          }
        }
      }).on("close", function() {
        if (!this.errored) {
          handler.onResponseEnd?.(controller, {});
        }
      });
      handler.onRequestStart?.(controller, context2);
      if (stream.destroyed) {
        return;
      }
      const headers = { ...result.headers, age: String(age) };
      if (isStale) {
        headers.warning = '110 - "response is stale"';
      }
      handler.onResponseStart?.(controller, result.statusCode, headers, result.statusMessage);
      if (opts.method === "HEAD") {
        stream.destroy();
      } else {
        stream.on("data", function(chunk) {
          handler.onResponseData?.(controller, chunk);
        });
      }
    }
    function handleResult(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl, result) {
      if (!result) {
        return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl);
      }
      const now = Date.now();
      if (now > result.deleteAt) {
        return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
      }
      const age = Math.round((now - result.cachedAt) / 1e3);
      if (reqCacheControl?.["max-age"] && age >= reqCacheControl["max-age"]) {
        return dispatch(opts, handler);
      }
      if (needsRevalidation(result, reqCacheControl)) {
        if (util.isStream(opts.body) && util.bodyLength(opts.body) !== 0) {
          return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
        }
        let withinStaleIfErrorThreshold = false;
        const staleIfErrorExpiry = result.cacheControlDirectives["stale-if-error"] ?? reqCacheControl?.["stale-if-error"];
        if (staleIfErrorExpiry) {
          withinStaleIfErrorThreshold = now < result.staleAt + staleIfErrorExpiry * 1e3;
        }
        let headers = {
          ...opts.headers,
          "if-modified-since": new Date(result.cachedAt).toUTCString()
        };
        if (result.etag) {
          headers["if-none-match"] = result.etag;
        }
        if (result.vary) {
          headers = {
            ...headers,
            ...result.vary
          };
        }
        return dispatch(
          {
            ...opts,
            headers
          },
          new CacheRevalidationHandler(
            (success, context2) => {
              if (success) {
                sendCachedValue(handler, opts, result, age, context2, true);
              } else if (util.isStream(result.body)) {
                result.body.on("error", () => {
                }).destroy();
              }
            },
            new CacheHandler(globalOpts, cacheKey, handler),
            withinStaleIfErrorThreshold
          )
        );
      }
      if (util.isStream(opts.body)) {
        opts.body.on("error", () => {
        }).destroy();
      }
      sendCachedValue(handler, opts, result, age, null, false);
    }
    module2.exports = (opts = {}) => {
      const {
        store = new MemoryCacheStore(),
        methods = ["GET"],
        cacheByDefault = void 0,
        type = "shared"
      } = opts;
      if (typeof opts !== "object" || opts === null) {
        throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
      }
      assertCacheStore(store, "opts.store");
      assertCacheMethods(methods, "opts.methods");
      if (typeof cacheByDefault !== "undefined" && typeof cacheByDefault !== "number") {
        throw new TypeError(`exepcted opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`);
      }
      if (typeof type !== "undefined" && type !== "shared" && type !== "private") {
        throw new TypeError(`exepcted opts.type to be shared, private, or undefined, got ${typeof type}`);
      }
      const globalOpts = {
        store,
        methods,
        cacheByDefault,
        type
      };
      const safeMethodsToNotCache = util.safeHTTPMethods.filter((method) => methods.includes(method) === false);
      return (dispatch) => {
        return (opts2, handler) => {
          if (!opts2.origin || safeMethodsToNotCache.includes(opts2.method)) {
            return dispatch(opts2, handler);
          }
          opts2 = {
            ...opts2,
            headers: normaliseHeaders(opts2)
          };
          const reqCacheControl = opts2.headers?.["cache-control"] ? parseCacheControlHeader(opts2.headers["cache-control"]) : void 0;
          if (reqCacheControl?.["no-store"]) {
            return dispatch(opts2, handler);
          }
          const cacheKey = makeCacheKey(opts2);
          const result = store.get(cacheKey);
          if (result && typeof result.then === "function") {
            result.then((result2) => {
              handleResult(
                dispatch,
                globalOpts,
                cacheKey,
                handler,
                opts2,
                reqCacheControl,
                result2
              );
            });
          } else {
            handleResult(
              dispatch,
              globalOpts,
              cacheKey,
              handler,
              opts2,
              reqCacheControl,
              result
            );
          }
          return true;
        };
      };
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/cache/sqlite-cache-store.js
var require_sqlite_cache_store = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/cache/sqlite-cache-store.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var { assertCacheKey, assertCacheValue } = require_cache();
    var DatabaseSync;
    var VERSION2 = 3;
    var MAX_ENTRY_SIZE = 2 * 1e3 * 1e3 * 1e3;
    module2.exports = class SqliteCacheStore {
      #maxEntrySize = MAX_ENTRY_SIZE;
      #maxCount = Infinity;
      /**
       * @type {import('node:sqlite').DatabaseSync}
       */
      #db;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #getValuesQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #updateValueQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #insertValueQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #deleteExpiredValuesQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #deleteByUrlQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #countEntriesQuery;
      /**
       * @type {import('node:sqlite').StatementSync | null}
       */
      #deleteOldValuesQuery;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts
       */
      constructor(opts) {
        if (opts) {
          if (typeof opts !== "object") {
            throw new TypeError("SqliteCacheStore options must be an object");
          }
          if (opts.maxEntrySize !== void 0) {
            if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
              throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
            }
            if (opts.maxEntrySize > MAX_ENTRY_SIZE) {
              throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
            }
            this.#maxEntrySize = opts.maxEntrySize;
          }
          if (opts.maxCount !== void 0) {
            if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
              throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
            }
            this.#maxCount = opts.maxCount;
          }
        }
        if (!DatabaseSync) {
          DatabaseSync = require("node:sqlite").DatabaseSync;
        }
        this.#db = new DatabaseSync(opts?.location ?? ":memory:");
        this.#db.exec(`
      PRAGMA journal_mode = WAL;
      PRAGMA synchronous = NORMAL;
      PRAGMA temp_store = memory;
      PRAGMA optimize;

      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION2} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION2}_getValuesQuery ON cacheInterceptorV${VERSION2}(url, method, deleteAt);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION2}_deleteByUrlQuery ON cacheInterceptorV${VERSION2}(deleteAt);
    `);
        this.#getValuesQuery = this.#db.prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${VERSION2}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `);
        this.#updateValueQuery = this.#db.prepare(`
      UPDATE cacheInterceptorV${VERSION2} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `);
        this.#insertValueQuery = this.#db.prepare(`
      INSERT INTO cacheInterceptorV${VERSION2} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
        this.#deleteByUrlQuery = this.#db.prepare(
          `DELETE FROM cacheInterceptorV${VERSION2} WHERE url = ?`
        );
        this.#countEntriesQuery = this.#db.prepare(
          `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION2}`
        );
        this.#deleteExpiredValuesQuery = this.#db.prepare(
          `DELETE FROM cacheInterceptorV${VERSION2} WHERE deleteAt <= ?`
        );
        this.#deleteOldValuesQuery = this.#maxCount === Infinity ? null : this.#db.prepare(`
        DELETE FROM cacheInterceptorV${VERSION2}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${VERSION2}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `);
      }
      close() {
        this.#db.close();
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}
       */
      get(key) {
        assertCacheKey(key);
        const value = this.#findValue(key);
        return value ? {
          body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : void 0,
          statusCode: value.statusCode,
          statusMessage: value.statusMessage,
          headers: value.headers ? JSON.parse(value.headers) : void 0,
          etag: value.etag ? value.etag : void 0,
          vary: value.vary ? JSON.parse(value.vary) : void 0,
          cacheControlDirectives: value.cacheControlDirectives ? JSON.parse(value.cacheControlDirectives) : void 0,
          cachedAt: value.cachedAt,
          staleAt: value.staleAt,
          deleteAt: value.deleteAt
        } : void 0;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value
       */
      set(key, value) {
        assertCacheKey(key);
        const url = this.#makeValueUrl(key);
        const body = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body;
        const size = body?.byteLength;
        if (size && size > this.#maxEntrySize) {
          return;
        }
        const existingValue = this.#findValue(key, true);
        if (existingValue) {
          this.#updateValueQuery.run(
            body,
            value.deleteAt,
            value.statusCode,
            value.statusMessage,
            value.headers ? JSON.stringify(value.headers) : null,
            value.etag ? value.etag : null,
            value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
            value.cachedAt,
            value.staleAt,
            existingValue.id
          );
        } else {
          this.#prune();
          this.#insertValueQuery.run(
            url,
            key.method,
            body,
            value.deleteAt,
            value.statusCode,
            value.statusMessage,
            value.headers ? JSON.stringify(value.headers) : null,
            value.etag ? value.etag : null,
            value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
            value.vary ? JSON.stringify(value.vary) : null,
            value.cachedAt,
            value.staleAt
          );
        }
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value
       * @returns {Writable | undefined}
       */
      createWriteStream(key, value) {
        assertCacheKey(key);
        assertCacheValue(value);
        let size = 0;
        const body = [];
        const store = this;
        return new Writable({
          decodeStrings: true,
          write(chunk, encoding, callback) {
            size += chunk.byteLength;
            if (size < store.#maxEntrySize) {
              body.push(chunk);
            } else {
              this.destroy();
            }
            callback();
          },
          final(callback) {
            store.set(key, { ...value, body });
            callback();
          }
        });
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       */
      delete(key) {
        if (typeof key !== "object") {
          throw new TypeError(`expected key to be object, got ${typeof key}`);
        }
        this.#deleteByUrlQuery.run(this.#makeValueUrl(key));
      }
      #prune() {
        if (Number.isFinite(this.#maxCount) && this.size <= this.#maxCount) {
          return 0;
        }
        {
          const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes;
          if (removed) {
            return removed;
          }
        }
        {
          const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes;
          if (removed) {
            return removed;
          }
        }
        return 0;
      }
      /**
       * Counts the number of rows in the cache
       * @returns {Number}
       */
      get size() {
        const { total } = this.#countEntriesQuery.get();
        return total;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @returns {string}
       */
      #makeValueUrl(key) {
        return `${key.origin}/${key.path}`;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {boolean} [canBeExpired=false]
       * @returns {SqliteStoreValue | undefined}
       */
      #findValue(key, canBeExpired = false) {
        const url = this.#makeValueUrl(key);
        const { headers, method } = key;
        const values = this.#getValuesQuery.all(url, method);
        if (values.length === 0) {
          return void 0;
        }
        const now = Date.now();
        for (const value of values) {
          if (now >= value.deleteAt && !canBeExpired) {
            return void 0;
          }
          let matches = true;
          if (value.vary) {
            const vary = JSON.parse(value.vary);
            for (const header in vary) {
              if (!headerValueEquals(headers[header], vary[header])) {
                matches = false;
                break;
              }
            }
          }
          if (matches) {
            return value;
          }
        }
        return void 0;
      }
    };
    function headerValueEquals(lhs, rhs) {
      if (lhs == null && rhs == null) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (Array.isArray(lhs) && Array.isArray(rhs)) {
        if (lhs.length !== rhs.length) {
          return false;
        }
        return lhs.every((x, i) => x === rhs[i]);
      }
      return lhs === rhs;
    }
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      iteratorMixin,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var { webidl } = require_webidl();
    var assert = require("node:assert");
    var util = require("node:util");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (getHeadersGuard(headers) === "immutable") {
        throw new TypeError("immutable");
      }
      return getHeadersList(headers).append(name, value, false);
    }
    function headersListSortAndCombine(target) {
      const headersList = getHeadersList(target);
      if (!headersList) {
        return [];
      }
      if (headersList.sortedMap) {
        return headersList.sortedMap;
      }
      const headers = [];
      const names = headersList.toSortedArray();
      const cookies = headersList.cookies;
      if (cookies === null || cookies.length === 1) {
        return headersList.sortedMap = names;
      }
      for (let i = 0; i < names.length; ++i) {
        const { 0: name, 1: value } = names[i];
        if (name === "set-cookie") {
          for (let j = 0; j < cookies.length; ++j) {
            headers.push([name, cookies[j]]);
          }
        } else {
          headers.push([name, value]);
        }
      }
      return headersList.sortedMap = headers;
    }
    function compareHeaderName(a, b) {
      return a[0] < b[0] ? -1 : 1;
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      sortedMap;
      headersMap;
      constructor(init) {
        if (init instanceof _HeadersList) {
          this.headersMap = new Map(init.headersMap);
          this.sortedMap = init.sortedMap;
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this.headersMap = new Map(init);
          this.sortedMap = null;
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#header-list-contains
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      contains(name, isLowerCase) {
        return this.headersMap.has(isLowerCase ? name : name.toLowerCase());
      }
      clear() {
        this.headersMap.clear();
        this.sortedMap = null;
        this.cookies = null;
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-append
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      append(name, value, isLowerCase) {
        this.sortedMap = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        const exists = this.headersMap.get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this.headersMap.set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this.headersMap.set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          (this.cookies ??= []).push(value);
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-set
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      set(name, value, isLowerCase) {
        this.sortedMap = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this.headersMap.set(lowercaseName, { name, value });
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      delete(name, isLowerCase) {
        this.sortedMap = null;
        if (!isLowerCase) name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this.headersMap.delete(name);
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-get
       * @param {string} name
       * @param {boolean} isLowerCase
       * @returns {string | null}
       */
      get(name, isLowerCase) {
        return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
      }
      *[Symbol.iterator]() {
        for (const { 0: name, 1: { value } } of this.headersMap) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this.headersMap.size !== 0) {
          for (const { name, value } of this.headersMap.values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
      rawValues() {
        return this.headersMap.values();
      }
      get entriesList() {
        const headers = [];
        if (this.headersMap.size !== 0) {
          for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {
            if (lowerName === "set-cookie") {
              for (const cookie of this.cookies) {
                headers.push([name, cookie]);
              }
            } else {
              headers.push([name, value]);
            }
          }
        }
        return headers;
      }
      // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
      toSortedArray() {
        const size = this.headersMap.size;
        const array = new Array(size);
        if (size <= 32) {
          if (size === 0) {
            return array;
          }
          const iterator = this.headersMap[Symbol.iterator]();
          const firstValue = iterator.next().value;
          array[0] = [firstValue[0], firstValue[1].value];
          assert(firstValue[1].value !== null);
          for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
            value = iterator.next().value;
            x = array[i] = [value[0], value[1].value];
            assert(x[1] !== null);
            left = 0;
            right = i;
            while (left < right) {
              pivot = left + (right - left >> 1);
              if (array[pivot][0] <= x[0]) {
                left = pivot + 1;
              } else {
                right = pivot;
              }
            }
            if (i !== pivot) {
              j = i;
              while (j > left) {
                array[j] = array[--j];
              }
              array[left] = x;
            }
          }
          if (!iterator.next().done) {
            throw new TypeError("Unreachable");
          }
          return array;
        } else {
          let i = 0;
          for (const { 0: name, 1: { value } } of this.headersMap) {
            array[i++] = [name, value];
            assert(value !== null);
          }
          return array.sort(compareHeaderName);
        }
      }
    };
    var Headers = class _Headers {
      #guard;
      /**
       * @type {HeadersList}
       */
      #headersList;
      /**
       * @param {HeadersInit|Symbol} [init]
       * @returns
       */
      constructor(init = void 0) {
        webidl.util.markAsUncloneable(this);
        if (init === kConstruct) {
          return;
        }
        this.#headersList = new HeadersList();
        this.#guard = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init, "Headers constructor", "init");
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.append");
        const prefix = "Headers.append";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
        const prefix = "Headers.delete";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this.#guard === "immutable") {
          throw new TypeError("immutable");
        }
        if (!this.#headersList.contains(name, false)) {
          return;
        }
        this.#headersList.delete(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.get");
        const prefix = "Headers.get";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return this.#headersList.get(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.has");
        const prefix = "Headers.has";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return this.#headersList.contains(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.set");
        const prefix = "Headers.set";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value,
            type: "header value"
          });
        }
        if (this.#guard === "immutable") {
          throw new TypeError("immutable");
        }
        this.#headersList.set(name, value, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this.#headersList.cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      [util.inspect.custom](depth, options) {
        options.depth ??= depth;
        return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;
      }
      static getHeadersGuard(o) {
        return o.#guard;
      }
      static setHeadersGuard(o, guard) {
        o.#guard = guard;
      }
      /**
       * @param {Headers} o
       */
      static getHeadersList(o) {
        return o.#headersList;
      }
      /**
       * @param {Headers} target
       * @param {HeadersList} list
       */
      static setHeadersList(target, list) {
        target.#headersList = list;
      }
    };
    var { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;
    Reflect.deleteProperty(Headers, "getHeadersGuard");
    Reflect.deleteProperty(Headers, "setHeadersGuard");
    Reflect.deleteProperty(Headers, "getHeadersList");
    Reflect.deleteProperty(Headers, "setHeadersList");
    iteratorMixin("Headers", Headers, headersListSortAndCombine, 0, 1);
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V, prefix, argument) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
        const iterator = Reflect.get(V, Symbol.iterator);
        if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) {
          try {
            return getHeadersList(V).entriesList;
          } catch {
          }
        }
        if (typeof iterator === "function") {
          return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
        }
        return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      // for test.
      compareHeaderName,
      Headers,
      HeadersList,
      getHeadersGuard,
      setHeadersGuard,
      setHeadersList,
      getHeadersList
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/response.js
var require_response = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require_headers();
    var { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = require_body();
    var util = require_util();
    var nodeUtil = require("node:util");
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode,
      environmentSettingsObject: relevantRealm
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus
    } = require_constants3();
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols2();
    var assert = require("node:assert");
    var { types } = require("node:util");
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      /** @type {Headers} */
      #headers;
      #state;
      // Creates network error Response.
      static error() {
        const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = void 0) {
        webidl.argumentLengthCheck(arguments, 1, "Response.json");
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const responseObject = fromInnerResponse(makeResponse({}), "response");
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
        } catch (err) {
          throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError(`Invalid status code ${status}`);
        }
        const responseObject = fromInnerResponse(makeResponse({}), "immutable");
        responseObject.#state.status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject.#state.headersList.append("location", value, true);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = void 0) {
        webidl.util.markAsUncloneable(this);
        if (body === kConstruct) {
          return;
        }
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this.#state = makeResponse({});
        this.#headers = new Headers(kConstruct);
        setHeadersGuard(this.#headers, "response");
        setHeadersList(this.#headers, this.#state.headersList);
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this.#state.type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this.#state.urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this.#state.urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this.#state.status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this.#state.status >= 200 && this.#state.status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this.#state.statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this.#headers;
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this.#state.body ? this.#state.body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (bodyUnusable(this.#state)) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this.#state);
        return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ??= true;
        const properties = {
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          body: this.body,
          bodyUsed: this.bodyUsed,
          ok: this.ok,
          redirected: this.redirected,
          type: this.type,
          url: this.url
        };
        return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
      }
      /**
       * @param {Response} response
       */
      static getResponseHeaders(response) {
        return response.#headers;
      }
      /**
       * @param {Response} response
       * @param {Headers} newHeaders
       */
      static setResponseHeaders(response, newHeaders) {
        response.#headers = newHeaders;
      }
      /**
       * @param {Response} response
       */
      static getResponseState(response) {
        return response.#state;
      }
      /**
       * @param {Response} response
       * @param {any} newState
       */
      static setResponseState(response, newState) {
        response.#state = newState;
      }
    };
    var { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response;
    Reflect.deleteProperty(Response, "getResponseHeaders");
    Reflect.deleteProperty(Response, "setResponseHeaders");
    Reflect.deleteProperty(Response, "getResponseState");
    Reflect.deleteProperty(Response, "setResponseState");
    mixinBody(Response, getResponseState);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(newResponse, response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),
        urlList: init?.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function isNetworkError(response) {
      return (
        // A network error is a response whose type is "error",
        response.type === "error" && // status is 0
        response.status === 0
      );
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        getResponseState(response).status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        getResponseState(response).statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(getResponseHeaders(response), init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: `Invalid response status code ${response.status}`
          });
        }
        getResponseState(response).body = body.body;
        if (body.type != null && !getResponseState(response).headersList.contains("content-type", true)) {
          getResponseState(response).headersList.append("content-type", body.type, true);
        }
      }
    }
    function fromInnerResponse(innerResponse, guard) {
      const response = new Response(kConstruct);
      setResponseState(response, innerResponse);
      const headers = new Headers(kConstruct);
      setResponseHeaders(response, headers);
      setHeadersList(headers, innerResponse.headersList);
      setHeadersGuard(headers, guard);
      if (hasFinalizationRegistry && innerResponse.body?.stream) {
        streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
      }
      return response;
    }
    webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V, prefix, name);
      }
      if (webidl.is.Blob(V)) {
        return V;
      }
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
        return V;
      }
      if (webidl.is.FormData(V)) {
        return V;
      }
      if (webidl.is.URLSearchParams(V)) {
        return V;
      }
      return webidl.converters.DOMString(V, prefix, name);
    };
    webidl.converters.BodyInit = function(V, prefix, argument) {
      if (webidl.is.ReadableStream(V)) {
        return V;
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: () => ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    webidl.is.Response = webidl.util.MakeTypeAssertion(Response);
    module2.exports = {
      isNetworkError,
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse,
      fromInnerResponse,
      getResponseState
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols2();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
      unregister(key) {
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE && process.version.startsWith("v18")) {
        process._rawDebug("Using compatibility WeakRef and FinalizationRegistry");
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return { WeakRef, FinalizationRegistry };
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody, bodyUnusable } = require_body();
    var { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require_headers();
    var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
    var util = require_util();
    var nodeUtil = require("node:util");
    var {
      isValidHTTPToken,
      sameOrigin,
      environmentSettingsObject
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants3();
    var { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols2();
    var assert = require("node:assert");
    var { getMaxListeners, setMaxListeners, defaultMaxListeners } = require("node:events");
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var dependentControllerMap = /* @__PURE__ */ new WeakMap();
    var abortSignalHasEventHandlerLeakWarning;
    try {
      abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0;
    } catch {
      abortSignalHasEventHandlerLeakWarning = false;
    }
    function buildAbort(acRef) {
      return abort;
      function abort() {
        const ac = acRef.deref();
        if (ac !== void 0) {
          requestFinalizer.unregister(abort);
          this.removeEventListener("abort", abort);
          ac.abort(this.reason);
          const controllerList = dependentControllerMap.get(ac.signal);
          if (controllerList !== void 0) {
            if (controllerList.size !== 0) {
              for (const ref of controllerList) {
                const ctrl = ref.deref();
                if (ctrl !== void 0) {
                  ctrl.abort(this.reason);
                }
              }
              controllerList.clear();
            }
            dependentControllerMap.delete(ac.signal);
          }
        }
      }
    }
    var patchMethodWarning = false;
    var Request = class _Request {
      /** @type {AbortSignal} */
      #signal;
      /** @type {import('../../dispatcher/dispatcher')} */
      #dispatcher;
      /** @type {Headers} */
      #headers;
      #state;
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = void 0) {
        webidl.util.markAsUncloneable(this);
        if (input === kConstruct) {
          return;
        }
        const prefix = "Request constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        input = webidl.converters.RequestInfo(input, prefix, "input");
        init = webidl.converters.RequestInit(init, prefix, "init");
        let request = null;
        let fallbackMode = null;
        const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          this.#dispatcher = init.dispatcher;
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(webidl.is.Request(input));
          request = input.#state;
          signal = input.#signal;
          this.#dispatcher = init.dispatcher || input.#dispatcher;
        }
        const origin = environmentSettingsObject.settingsObject.origin;
        let window4 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window4 = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window4}' must be null`);
        }
        if ("window" in init) {
          window4 = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: environmentSettingsObject.settingsObject,
          // window window.
          window: window4,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          const mayBeNormalized = normalizedMethodRecords[method];
          if (mayBeNormalized !== void 0) {
            request.method = mayBeNormalized;
          } else {
            if (!isValidHTTPToken(method)) {
              throw new TypeError(`'${method}' is not a valid HTTP method.`);
            }
            const upperCase = method.toUpperCase();
            if (forbiddenMethodsSet.has(upperCase)) {
              throw new TypeError(`'${method}' HTTP method is unsupported.`);
            }
            method = normalizedMethodRecordsBase[upperCase] ?? method;
            request.method = method;
          }
          if (!patchMethodWarning && request.method === "patch") {
            process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
              code: "UNDICI-FETCH-patch"
            });
            patchMethodWarning = true;
          }
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this.#state = request;
        const ac = new AbortController();
        this.#signal = ac.signal;
        if (signal != null) {
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = buildAbort(acRef);
            if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(1500, signal);
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort }, abort);
          }
        }
        this.#headers = new Headers(kConstruct);
        setHeadersList(this.#headers, request.headersList);
        setHeadersGuard(this.#headers, "request");
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          setHeadersGuard(this.#headers, "request-no-cors");
        }
        if (initHasKey) {
          const headersList = getHeadersList(this.#headers);
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const { name, value } of headers.rawValues()) {
              headersList.append(name, value, false);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this.#headers, headers);
          }
        }
        const inputBody = webidl.is.Request(input) ? input.#state.body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !getHeadersList(this.#headers).contains("content-type", true)) {
            this.#headers.append("content-type", contentType, true);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (bodyUnusable(input.#state)) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this.#state.body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this.#state.method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this.#state.url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this.#headers;
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this.#state.destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this.#state.referrer === "no-referrer") {
          return "";
        }
        if (this.#state.referrer === "client") {
          return "about:client";
        }
        return this.#state.referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this.#state.referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this.#state.mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        webidl.brandCheck(this, _Request);
        return this.#state.credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this.#state.cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this.#state.redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this.#state.integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this.#state.keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this.#state.reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-forward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this.#state.historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this.#signal;
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this.#state.body ? this.#state.body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (bodyUnusable(this.#state)) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this.#state);
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          let list = dependentControllerMap.get(this.signal);
          if (list === void 0) {
            list = /* @__PURE__ */ new Set();
            dependentControllerMap.set(this.signal, list);
          }
          const acRef = new WeakRef(ac);
          list.add(acRef);
          util.addAbortListener(
            ac.signal,
            buildAbort(acRef)
          );
        }
        return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ??= true;
        const properties = {
          method: this.method,
          url: this.url,
          headers: this.headers,
          destination: this.destination,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          mode: this.mode,
          credentials: this.credentials,
          cache: this.cache,
          redirect: this.redirect,
          integrity: this.integrity,
          keepalive: this.keepalive,
          isReloadNavigation: this.isReloadNavigation,
          isHistoryNavigation: this.isHistoryNavigation,
          signal: this.signal
        };
        return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
      }
      /**
       * @param {Request} request
       * @param {AbortSignal} newSignal
       */
      static setRequestSignal(request, newSignal) {
        request.#signal = newSignal;
        return request;
      }
      /**
       * @param {Request} request
       */
      static getRequestDispatcher(request) {
        return request.#dispatcher;
      }
      /**
       * @param {Request} request
       * @param {import('../../dispatcher/dispatcher')} newDispatcher
       */
      static setRequestDispatcher(request, newDispatcher) {
        request.#dispatcher = newDispatcher;
      }
      /**
       * @param {Request} request
       * @param {Headers} newHeaders
       */
      static setRequestHeaders(request, newHeaders) {
        request.#headers = newHeaders;
      }
      /**
       * @param {Request} request
       */
      static getRequestState(request) {
        return request.#state;
      }
      /**
       * @param {Request} request
       * @param {any} newState
       */
      static setRequestState(request, newState) {
        request.#state = newState;
      }
    };
    var { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request;
    Reflect.deleteProperty(Request, "setRequestSignal");
    Reflect.deleteProperty(Request, "getRequestDispatcher");
    Reflect.deleteProperty(Request, "setRequestDispatcher");
    Reflect.deleteProperty(Request, "setRequestHeaders");
    Reflect.deleteProperty(Request, "getRequestState");
    Reflect.deleteProperty(Request, "setRequestState");
    mixinBody(Request, getRequestState);
    function makeRequest(init) {
      return {
        method: init.method ?? "GET",
        localURLsOnly: init.localURLsOnly ?? false,
        unsafeRequest: init.unsafeRequest ?? false,
        body: init.body ?? null,
        client: init.client ?? null,
        reservedClient: init.reservedClient ?? null,
        replacesClientId: init.replacesClientId ?? "",
        window: init.window ?? "client",
        keepalive: init.keepalive ?? false,
        serviceWorkers: init.serviceWorkers ?? "all",
        initiator: init.initiator ?? "",
        destination: init.destination ?? "",
        priority: init.priority ?? null,
        origin: init.origin ?? "client",
        policyContainer: init.policyContainer ?? "client",
        referrer: init.referrer ?? "client",
        referrerPolicy: init.referrerPolicy ?? "",
        mode: init.mode ?? "no-cors",
        useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
        credentials: init.credentials ?? "same-origin",
        useCredentials: init.useCredentials ?? false,
        cache: init.cache ?? "default",
        redirect: init.redirect ?? "follow",
        integrity: init.integrity ?? "",
        cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
        parserMetadata: init.parserMetadata ?? "",
        reloadNavigation: init.reloadNavigation ?? false,
        historyNavigation: init.historyNavigation ?? false,
        userActivation: init.userActivation ?? false,
        taintedOrigin: init.taintedOrigin ?? false,
        redirectCount: init.redirectCount ?? 0,
        responseTainting: init.responseTainting ?? "basic",
        preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
        done: init.done ?? false,
        timingAllowFailed: init.timingAllowFailed ?? false,
        urlList: init.urlList,
        url: init.urlList[0],
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(newRequest, request.body);
      }
      return newRequest;
    }
    function fromInnerRequest(innerRequest, dispatcher, signal, guard) {
      const request = new Request(kConstruct);
      setRequestState(request, innerRequest);
      setRequestDispatcher(request, dispatcher);
      setRequestSignal(request, signal);
      const headers = new Headers(kConstruct);
      setRequestHeaders(request, headers);
      setHeadersList(headers, innerRequest.headersList);
      setHeadersGuard(headers, guard);
      return request;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.is.Request = webidl.util.MakeTypeAssertion(Request);
    webidl.converters.RequestInfo = function(V, prefix, argument) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (webidl.is.Request(V)) {
        return V;
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            "RequestInit",
            "signal"
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      },
      {
        key: "dispatcher",
        // undici specific option
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      Request,
      makeRequest,
      fromInnerRequest,
      cloneRequest,
      getRequestDispatcher,
      getRequestState
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse,
      fromInnerResponse,
      getResponseState
    } = require_response();
    var { HeadersList } = require_headers();
    var { Request, cloneRequest, getRequestDispatcher, getRequestState } = require_request2();
    var zlib = require("node:zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme,
      clampAndCoarsenConnectionTimingInfo,
      simpleRangeHeaderValue,
      buildContentRange,
      createInflate,
      extractMimeType
    } = require_util2();
    var assert = require("node:assert");
    var { safelyExtractBody, extractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet
    } = require_constants3();
    var EE = require("node:events");
    var { Readable, pipeline, finished, isErrored, isReadable } = require("node:stream");
    var { addAbortListener, bufferToLowerCasedHeaderName } = require_util();
    var { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require_data_url();
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("node:http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
    var resolveObjectURL;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    };
    function handleFetchDone(response) {
      finalizeAndReportTiming(response, "fetch");
    }
    function fetch(input, init = void 0) {
      webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
      let p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = getRequestState(requestObject);
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          const realResponse = responseObject?.deref();
          abortFetch(p, request, realResponse, requestObject.signal.reason);
        }
      );
      const processResponse = (response) => {
        if (locallyAborted) {
          return;
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return;
        }
        if (response.type === "error") {
          p.reject(new TypeError("fetch failed", { cause: response.error }));
          return;
        }
        responseObject = new WeakRef(fromInnerResponse(response, "immutable"));
        p.resolve(responseObject.deref());
        p = null;
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: getRequestDispatcher(requestObject)
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL.href,
        initiatorType,
        globalThis,
        cacheState,
        "",
        // bodyType
        response.status
      );
    }
    var markResourceTiming = performance.markResourceTiming;
    function abortFetch(p, request, responseObject, error) {
      if (p) {
        p.reject(error);
      }
      if (request.body?.stream != null && isReadable(request.body.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = getResponseState(responseObject);
      if (response.body?.stream != null && isReadable(response.body.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher = getGlobalDispatcher()
      // undici
    }) {
      assert(dispatcher);
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currentTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept", true)) {
        const value = "*/*";
        request.headersList.append("accept", value, true);
      }
      if (!request.headersList.contains("accept-language", true)) {
        request.headersList.append("accept-language", "*", true);
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        const currentURL = requestCurrentURL(request);
        if (
          // - requests current URLs origin is same origin with requests origin,
          //   and requests response tainting is "basic"
          sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
          currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
          (request.mode === "navigate" || request.mode === "websocket")
        ) {
          request.responseTainting = "basic";
          response = await schemeFetch(fetchParams);
        } else if (request.mode === "same-origin") {
          response = makeNetworkError('request mode cannot be "same-origin"');
        } else if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            response = makeNetworkError(
              'redirect mode cannot be "follow" for "no-cors" request'
            );
          } else {
            request.responseTainting = "opaque";
            response = await schemeFetch(fetchParams);
          }
        } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          response = makeNetworkError("URL scheme must be a HTTP(S) scheme");
        } else {
          request.responseTainting = "cors";
          response = await httpFetch(fetchParams);
        }
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range", true)) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("node:buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blob = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !webidl.is.Blob(blob)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const response = makeResponse();
          const fullLength = blob.size;
          const serializedFullLength = isomorphicEncode(`${fullLength}`);
          const type = blob.type;
          if (!request.headersList.contains("range", true)) {
            const bodyWithType = extractBody(blob);
            response.statusText = "OK";
            response.body = bodyWithType[0];
            response.headersList.set("content-length", serializedFullLength, true);
            response.headersList.set("content-type", type, true);
          } else {
            response.rangeRequested = true;
            const rangeHeader = request.headersList.get("range", true);
            const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
            if (rangeValue === "failure") {
              return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
            }
            let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
            if (rangeStart === null) {
              rangeStart = fullLength - rangeEnd;
              rangeEnd = rangeStart + rangeEnd - 1;
            } else {
              if (rangeStart >= fullLength) {
                return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
              }
              if (rangeEnd === null || rangeEnd >= fullLength) {
                rangeEnd = fullLength - 1;
              }
            }
            const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
            const slicedBodyWithType = extractBody(slicedBlob);
            response.body = slicedBodyWithType[0];
            const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
            const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
            response.status = 206;
            response.statusText = "Partial Content";
            response.headersList.set("content-length", serializedSlicedLength, true);
            response.headersList.set("content-type", type, true);
            response.headersList.set("content-range", contentRange, true);
          }
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      let timingInfo = fetchParams.timingInfo;
      const processResponseEndOfBody = () => {
        const unsafeEndTime = Date.now();
        if (fetchParams.request.destination === "document") {
          fetchParams.controller.fullTimingInfo = timingInfo;
        }
        fetchParams.controller.reportTimingSteps = () => {
          if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {
            return;
          }
          timingInfo.endTime = unsafeEndTime;
          let cacheState = response.cacheState;
          const bodyInfo = response.bodyInfo;
          if (!response.timingAllowPassed) {
            timingInfo = createOpaqueTimingInfo(timingInfo);
            cacheState = "";
          }
          let responseStatus = 0;
          if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
            responseStatus = response.status;
            const mimeType = extractMimeType(response.headersList);
            if (mimeType !== "failure") {
              bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
            }
          }
          if (fetchParams.request.initiatorType != null) {
            markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
          }
        };
        const processResponseEndOfBodyTask = () => {
          fetchParams.request.done = true;
          if (fetchParams.processResponseEndOfBody != null) {
            queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
          }
          if (fetchParams.request.initiatorType != null) {
            fetchParams.controller.reportTimingSteps();
          }
        };
        queueMicrotask(() => processResponseEndOfBodyTask());
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => {
          fetchParams.processResponse(response);
          fetchParams.processResponse = null;
        });
      }
      const internalResponse = response.type === "error" ? response : response.internalResponse ?? response;
      if (internalResponse.body == null) {
        processResponseEndOfBody();
      } else {
        finished(internalResponse.body.stream, () => {
          processResponseEndOfBody();
        });
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy(void 0, false);
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization", true);
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie", true);
        request.headersList.delete("host", true);
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = cloneRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (webidl.is.URL(httpRequest.referrer)) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent", true)) {
        httpRequest.headersList.append("user-agent", defaultUserAgent, true);
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "max-age=0", true);
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma", true)) {
          httpRequest.headersList.append("pragma", "no-cache", true);
        }
        if (!httpRequest.headersList.contains("cache-control", true)) {
          httpRequest.headersList.append("cache-control", "no-cache", true);
        }
      }
      if (httpRequest.headersList.contains("range", true)) {
        httpRequest.headersList.append("accept-encoding", "identity", true);
      }
      if (!httpRequest.headersList.contains("accept-encoding", true)) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
        }
      }
      httpRequest.headersList.delete("host", true);
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") {
      }
      if (response == null) {
        if (httpRequest.cache === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range", true)) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err, abort = true) {
          if (!this.destroyed) {
            this.destroyed = true;
            if (abort) {
              this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
            }
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        return fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        if (!isCancelled(fetchParams)) {
          fetchParams.controller.abort(reason);
        }
      };
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          },
          type: "bytes"
        }
      );
      response.body = { stream, source: null, length: null };
      if (!fetchParams.controller.resume) {
        fetchParams.controller.on("terminated", onAborted);
      }
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          const buffer = new Uint8Array(bytes);
          if (buffer.byteLength) {
            fetchParams.controller.controller.enqueue(buffer);
          }
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (fetchParams.controller.controller.desiredSize <= 0) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
              if (connection.destroyed) {
                abort(new DOMException("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
              timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onResponseStarted() {
              timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onHeaders(status, rawHeaders, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              const contentEncoding = headersList.get("content-encoding", true);
              if (contentEncoding) {
                codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
              }
              location = headersList.get("location", true);
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = location && request.redirect === "follow" && redirectStatusSet.has(status);
              if (codings.length !== 0 && request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (let i = codings.length - 1; i >= 0; --i) {
                  const coding = codings[i];
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(createInflate({
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress({
                      flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                      finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                    }));
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              const onError = this.onError.bind(this);
              resolve({
                status,
                statusText,
                headersList,
                body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
                  if (err) {
                    this.onError(err);
                  }
                }).on("error", onError) : this.body.on("error", onError)
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, rawHeaders, socket) {
              if (status !== 101) {
                return;
              }
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList,
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/cache/util.js
var require_util3 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { URLSerializer } = require_data_url();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function getFieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (isValidHeaderName(value)) {
          values.push(value);
        }
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      getFieldValues
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/cache/cache.js
var require_cache3 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols2();
    var { urlEquals, getFieldValues } = require_util3();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { webidl } = require_webidl();
    var { cloneResponse, fromInnerResponse, getResponseState } = require_response();
    var { Request, fromInnerRequest, getRequestState } = require_request2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert = require("node:assert");
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.match";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        const p = this.#internalMatchAll(request, options, 1);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.matchAll";
        if (request !== void 0) request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        return this.#internalMatchAll(request, options);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.add";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.addAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const responsePromises = [];
        const requestList = [];
        for (let request of requests) {
          if (request === void 0) {
            throw webidl.errors.conversionFailed({
              prefix,
              argument: "Argument 1",
              types: ["undefined is not allowed"]
            });
          }
          request = webidl.converters.RequestInfo(request);
          if (typeof request === "string") {
            continue;
          }
          const r = getRequestState(request);
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = getRequestState(new Request(request));
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.put";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        response = webidl.converters.Response(response, prefix, "response");
        let innerRequest = null;
        if (webidl.is.Request(request)) {
          innerRequest = getRequestState(request);
        } else {
          innerRequest = getRequestState(new Request(request));
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = getResponseState(response);
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: prefix,
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (webidl.is.Request(request)) {
          r = getRequestState(request);
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = getRequestState(new Request(request));
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {Promise<readonly Request[]>}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.keys";
        if (request !== void 0) request = webidl.converters.RequestInfo(request, prefix, "request");
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (request !== void 0) {
          if (webidl.is.Request(request)) {
            r = getRequestState(request);
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = getRequestState(new Request(request));
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = fromInnerRequest(
              request2,
              void 0,
              new AbortController().signal,
              "immutable"
            );
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache = this.#relevantRequestResponseList;
        const backupCache = [...cache];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
              cache.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
      #internalMatchAll(request, options, maxResponses = Infinity) {
        let r = null;
        if (request !== void 0) {
          if (webidl.is.Request(request)) {
            r = getRequestState(request);
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = getRequestState(new Request(request));
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = fromInnerResponse(response, "immutable");
          responseList.push(responseObject.clone());
          if (responseList.length >= maxResponses) {
            break;
          }
        }
        return Object.freeze(responseList);
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(
      webidl.is.Response,
      "Response"
    );
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { Cache } = require_cache3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { kConstruct } = require_symbols2();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.open";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        if (this.#caches.has(cacheName)) {
          const cache2 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        this.#caches.set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {Promise<string[]>}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = this.#caches.keys();
        return [...keys];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/constants.js
var require_constants4 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/util.js
var require_util4 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/util.js"(exports2, module2) {
    "use strict";
    function isCTLExcludingHtab(value) {
      for (let i = 0; i < value.length; ++i) {
        const code = value.charCodeAt(i);
        if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
          return true;
        }
      }
      return false;
    }
    function validateCookieName(name) {
      for (let i = 0; i < name.length; ++i) {
        const code = name.charCodeAt(i);
        if (code < 33 || // exclude CTLs (0-31), SP and HT
        code > 126 || // exclude non-ascii and DEL
        code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 60 || // <
        code === 62 || // >
        code === 64 || // @
        code === 44 || // ,
        code === 59 || // ;
        code === 58 || // :
        code === 92 || // \
        code === 47 || // /
        code === 91 || // [
        code === 93 || // ]
        code === 63 || // ?
        code === 61 || // =
        code === 123 || // {
        code === 125) {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      let len = value.length;
      let i = 0;
      if (value[0] === '"') {
        if (len === 1 || value[len - 1] !== '"') {
          throw new Error("Invalid cookie value");
        }
        --len;
        ++i;
      }
      while (i < len) {
        const code = value.charCodeAt(i++);
        if (code < 33 || // exclude CTLs (0-31)
        code > 126 || // non-ascii and DEL (127)
        code === 34 || // "
        code === 44 || // ,
        code === 59 || // ;
        code === 92) {
          throw new Error("Invalid cookie value");
        }
      }
    }
    function validateCookiePath(path) {
      for (let i = 0; i < path.length; ++i) {
        const code = path.charCodeAt(i);
        if (code < 32 || // exclude CTLs (0-31)
        code === 127 || // DEL
        code === 59) {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    var IMFDays = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var IMFMonths = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module2.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util4();
    var { collectASequenceOfCodePointsFast } = require_data_url();
    var assert = require("node:assert");
    var { unescape } = require("node:querystring");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value: unescape(value),
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify } = require_util4();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    var brandChecks = webidl.brandCheckMultiple([Headers, globalThis.Headers].filter(Boolean));
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getCookies");
      brandChecks(headers);
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      brandChecks(headers);
      const prefix = "deleteCookie";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.DOMString(name, prefix, "name");
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
      brandChecks(headers);
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function parseCookie(cookie) {
      cookie = webidl.converters.DOMString(cookie);
      return parseSetCookie(cookie);
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, "setCookie");
      brandChecks(headers);
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("set-cookie", str, true);
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: () => null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: () => new Array(0)
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie,
      parseCookie
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/events.js
var require_events = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { kConstruct } = require_symbols2();
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        if (type === kConstruct) {
          super(arguments[1], arguments[2]);
          webidl.util.markAsUncloneable(this);
          return;
        }
        const prefix = "MessageEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
        webidl.util.markAsUncloneable(this);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
      static createFastMessageEvent(type, init) {
        const messageEvent = new _MessageEvent(kConstruct, type, init);
        messageEvent.#eventInit = init;
        messageEvent.#eventInit.data ??= null;
        messageEvent.#eventInit.origin ??= "";
        messageEvent.#eventInit.lastEventId ??= "";
        messageEvent.#eventInit.source ??= null;
        messageEvent.#eventInit.ports ??= [];
        return messageEvent;
      }
    };
    var { createFastMessageEvent } = MessageEvent;
    delete MessageEvent.createFastMessageEvent;
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        const prefix = "CloseEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
        webidl.util.markAsUncloneable(this);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        const prefix = "ErrorEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        super(type, eventInitDict);
        webidl.util.markAsUncloneable(this);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(
      webidl.is.MessagePort,
      "MessagePort"
    );
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: () => null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: () => null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        defaultValue: () => new Array(0)
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent,
      createFastMessageEvent
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/constants.js
var require_constants5 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var sentCloseFrameState = {
      SENT: 1,
      RECEIVED: 2
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 65535;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    var sendHints = {
      text: 1,
      typedArray: 2,
      arrayBuffer: 3,
      blob: 4
    };
    module2.exports = {
      uid,
      sentCloseFrameState,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer,
      sendHints
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/util.js
var require_util5 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/util.js"(exports2, module2) {
    "use strict";
    var { states, opcodes } = require_constants5();
    var { isUtf8 } = require("node:buffer");
    var { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require_data_url();
    function isConnecting(readyState) {
      return readyState === states.CONNECTING;
    }
    function isEstablished(readyState) {
      return readyState === states.OPEN;
    }
    function isClosing(readyState) {
      return readyState === states.CLOSING;
    }
    function isClosed(readyState) {
      return readyState === states.CLOSED;
    }
    function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
      const event = eventFactory(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(handler, type, data) {
      handler.onMessage(type, data);
    }
    function toArrayBuffer(buffer) {
      if (buffer.byteLength === buffer.buffer.byteLength) {
        return buffer.buffer;
      }
      return new Uint8Array(buffer).buffer;
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (let i = 0; i < protocol.length; ++i) {
        const code = protocol.charCodeAt(i);
        if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
        code > 126 || code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 44 || // ,
        code === 47 || // /
        code === 58 || // :
        code === 59 || // ;
        code === 60 || // <
        code === 61 || // =
        code === 62 || // >
        code === 63 || // ?
        code === 64 || // @
        code === 91 || // [
        code === 92 || // \
        code === 93 || // ]
        code === 123 || // {
        code === 125) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function isControlFrame(opcode) {
      return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
    }
    function isContinuationFrame(opcode) {
      return opcode === opcodes.CONTINUATION;
    }
    function isTextBinaryFrame(opcode) {
      return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
    }
    function isValidOpcode(opcode) {
      return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
    }
    function parseExtensions(extensions) {
      const position = { position: 0 };
      const extensionList = /* @__PURE__ */ new Map();
      while (position.position < extensions.length) {
        const pair = collectASequenceOfCodePointsFast(";", extensions, position);
        const [name, value = ""] = pair.split("=", 2);
        extensionList.set(
          removeHTTPWhitespace(name, true, false),
          removeHTTPWhitespace(value, false, true)
        );
        position.position++;
      }
      return extensionList;
    }
    function isValidClientWindowBits(value) {
      for (let i = 0; i < value.length; i++) {
        const byte = value.charCodeAt(i);
        if (byte < 48 || byte > 57) {
          return false;
        }
      }
      return true;
    }
    function getURLRecord(url, baseURL) {
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException("expected a ws: or wss: url", "SyntaxError");
      }
      if (urlRecord.hash.length || urlRecord.href.endsWith("#")) {
        throw new DOMException("hash", "SyntaxError");
      }
      return urlRecord;
    }
    function validateCloseCodeAndReason(code, reason) {
      if (code !== null) {
        if (code !== 1e3 && (code < 3e3 || code > 4999)) {
          throw new DOMException("invalid code", "InvalidAccessError");
        }
      }
      if (reason !== null) {
        const reasonBytesLength = Buffer.byteLength(reason);
        if (reasonBytesLength > 123) {
          throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, "SyntaxError");
        }
      }
    }
    var utf8Decode = (() => {
      if (typeof process.versions.icu === "string") {
        const fatalDecoder = new TextDecoder("utf-8", { fatal: true });
        return fatalDecoder.decode.bind(fatalDecoder);
      }
      return function(buffer) {
        if (isUtf8(buffer)) {
          return buffer.toString("utf-8");
        }
        throw new TypeError("Invalid utf-8 received.");
      };
    })();
    module2.exports = {
      isConnecting,
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isContinuationFrame,
      isTextBinaryFrame,
      isValidOpcode,
      parseExtensions,
      isValidClientWindowBits,
      toArrayBuffer,
      getURLRecord,
      validateCloseCodeAndReason
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit, opcodes } = require_constants5();
    var BUFFER_SIZE = 8 * 1024;
    var crypto;
    var buffer = null;
    var bufIdx = BUFFER_SIZE;
    try {
      crypto = require("node:crypto");
    } catch {
      crypto = {
        // not full compatibility, but minimum.
        randomFillSync: function randomFillSync(buffer2, _offset, _size) {
          for (let i = 0; i < buffer2.length; ++i) {
            buffer2[i] = Math.random() * 255 | 0;
          }
          return buffer2;
        }
      };
    }
    function generateMask() {
      if (bufIdx === BUFFER_SIZE) {
        bufIdx = 0;
        crypto.randomFillSync(buffer ??= Buffer.allocUnsafeSlow(BUFFER_SIZE), 0, BUFFER_SIZE);
      }
      return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
      }
      createFrame(opcode) {
        const frameData = this.frameData;
        const maskKey = generateMask();
        const bodyLength = frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
        buffer2[0] = buffer2[1] = 0;
        buffer2[0] |= 128;
        buffer2[0] = (buffer2[0] & 240) + opcode;
        buffer2[offset - 4] = maskKey[0];
        buffer2[offset - 3] = maskKey[1];
        buffer2[offset - 2] = maskKey[2];
        buffer2[offset - 1] = maskKey[3];
        buffer2[1] = payloadLength;
        if (payloadLength === 126) {
          buffer2.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer2[2] = buffer2[3] = 0;
          buffer2.writeUIntBE(bodyLength, 4, 6);
        }
        buffer2[1] |= 128;
        for (let i = 0; i < bodyLength; ++i) {
          buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
        }
        return buffer2;
      }
      /**
       * @param {Uint8Array} buffer
       */
      static createFastTextFrame(buffer2) {
        const maskKey = generateMask();
        const bodyLength = buffer2.length;
        for (let i = 0; i < bodyLength; ++i) {
          buffer2[i] ^= maskKey[i & 3];
        }
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const head = Buffer.allocUnsafeSlow(offset);
        head[0] = 128 | opcodes.TEXT;
        head[1] = payloadLength | 128;
        head[offset - 4] = maskKey[0];
        head[offset - 3] = maskKey[1];
        head[offset - 2] = maskKey[2];
        head[offset - 1] = maskKey[3];
        if (payloadLength === 126) {
          head.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          head[2] = head[3] = 0;
          head.writeUIntBE(bodyLength, 4, 6);
        }
        return [head, buffer2];
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/connection.js"(exports2, module2) {
    "use strict";
    var { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require_constants5();
    var { parseExtensions, isClosed, isClosing, isEstablished, validateCloseCodeAndReason } = require_util5();
    var { channels } = require_diagnostics();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers, getHeadersList } = require_headers();
    var { getDecodeSplit } = require_util2();
    var { WebsocketFrameSend } = require_frame();
    var assert = require("node:assert");
    var crypto;
    try {
      crypto = require("node:crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, client, handler, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        client,
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = getHeadersList(new Headers(options.headers));
        request.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue, true);
      request.headersList.append("sec-websocket-version", "13", true);
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol, true);
      }
      const permessageDeflate = "permessage-deflate; client_max_window_bits";
      request.headersList.append("sec-websocket-extensions", permessageDeflate, true);
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher,
        processResponse(response) {
          if (response.type === "error") {
            handler.readyState = states.CLOSED;
          }
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(handler, 1002, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(handler, 1002, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(handler, 1002, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(handler, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          let extensions;
          if (secExtension !== null) {
            extensions = parseExtensions(secExtension);
            if (!extensions.has("permessage-deflate")) {
              failWebsocketConnection(handler, 1002, "Sec-WebSocket-Extensions header does not match.");
              return;
            }
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null) {
            const requestProtocols = getDecodeSplit("sec-websocket-protocol", request.headersList);
            if (!requestProtocols.includes(secProtocol)) {
              failWebsocketConnection(handler, 1002, "Protocol was not set in the opening handshake.");
              return;
            }
          }
          response.socket.on("data", handler.onSocketData);
          response.socket.on("close", handler.onSocketClose);
          response.socket.on("error", handler.onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          handler.wasEverConnected = true;
          handler.onConnectionEstablished(response, extensions);
        }
      });
      return controller;
    }
    function closeWebSocketConnection(object, code, reason, validate = false) {
      code ??= null;
      reason ??= "";
      if (validate) validateCloseCodeAndReason(code, reason);
      if (isClosed(object.readyState) || isClosing(object.readyState)) {
      } else if (!isEstablished(object.readyState)) {
        failWebsocketConnection(object);
        object.readyState = states.CLOSING;
      } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {
        const frame = new WebsocketFrameSend();
        if (reason.length !== 0 && code === null) {
          code = 1e3;
        }
        assert(code === null || Number.isInteger(code));
        if (code === null && reason.length === 0) {
          frame.frameData = emptyBuffer;
        } else if (code !== null && reason === null) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== null && reason !== null) {
          frame.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason));
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        object.socket.write(frame.createFrame(opcodes.CLOSE));
        object.closeState.add(sentCloseFrameState.SENT);
        object.readyState = states.CLOSING;
      } else {
        object.readyState = states.CLOSING;
      }
    }
    function failWebsocketConnection(handler, code, reason) {
      if (isEstablished(handler.readyState)) {
        closeWebSocketConnection(handler, code, reason, false);
      }
      handler.controller.abort();
      if (handler.socket?.destroyed === false) {
        handler.socket.destroy();
      }
      handler.onFail(code, reason);
    }
    module2.exports = {
      establishWebSocketConnection,
      failWebsocketConnection,
      closeWebSocketConnection
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require("node:zlib");
    var { isValidClientWindowBits } = require_util5();
    var tail = Buffer.from([0, 0, 255, 255]);
    var kBuffer = Symbol("kBuffer");
    var kLength = Symbol("kLength");
    var PerMessageDeflate = class {
      /** @type {import('node:zlib').InflateRaw} */
      #inflate;
      #options = {};
      constructor(extensions) {
        this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
        this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
      }
      decompress(chunk, fin, callback) {
        if (!this.#inflate) {
          let windowBits = Z_DEFAULT_WINDOWBITS;
          if (this.#options.serverMaxWindowBits) {
            if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
              callback(new Error("Invalid server_max_window_bits"));
              return;
            }
            windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
          }
          this.#inflate = createInflateRaw({ windowBits });
          this.#inflate[kBuffer] = [];
          this.#inflate[kLength] = 0;
          this.#inflate.on("data", (data) => {
            this.#inflate[kBuffer].push(data);
            this.#inflate[kLength] += data.length;
          });
          this.#inflate.on("error", (err) => {
            this.#inflate = null;
            callback(err);
          });
        }
        this.#inflate.write(chunk);
        if (fin) {
          this.#inflate.write(tail);
        }
        this.#inflate.flush(() => {
          const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
          this.#inflate[kBuffer].length = 0;
          this.#inflate[kLength] = 0;
          callback(null, full);
        });
      }
    };
    module2.exports = { PerMessageDeflate };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("node:stream");
    var assert = require("node:assert");
    var { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require_constants5();
    var { channels } = require_diagnostics();
    var {
      isValidStatusCode,
      isValidOpcode,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isTextBinaryFrame,
      isContinuationFrame
    } = require_util5();
    var { failWebsocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { PerMessageDeflate } = require_permessage_deflate();
    var ByteParser = class extends Writable {
      #buffers = [];
      #fragmentsBytes = 0;
      #byteOffset = 0;
      #loop = false;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      /** @type {Map<string, PerMessageDeflate>} */
      #extensions;
      /** @type {import('./websocket').Handler} */
      #handler;
      constructor(handler, extensions) {
        super();
        this.#handler = handler;
        this.#extensions = extensions == null ? /* @__PURE__ */ new Map() : extensions;
        if (this.#extensions.has("permessage-deflate")) {
          this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;
        this.#loop = true;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (this.#loop) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            const fin = (buffer[0] & 128) !== 0;
            const opcode = buffer[0] & 15;
            const masked = (buffer[1] & 128) === 128;
            const fragmented = !fin && opcode !== opcodes.CONTINUATION;
            const payloadLength = buffer[1] & 127;
            const rsv1 = buffer[0] & 64;
            const rsv2 = buffer[0] & 32;
            const rsv3 = buffer[0] & 16;
            if (!isValidOpcode(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Invalid opcode received");
              return callback();
            }
            if (masked) {
              failWebsocketConnection(this.#handler, 1002, "Frame cannot be masked");
              return callback();
            }
            if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
              failWebsocketConnection(this.#handler, 1002, "Expected RSV1 to be clear.");
              return;
            }
            if (rsv2 !== 0 || rsv3 !== 0) {
              failWebsocketConnection(this.#handler, 1002, "RSV1, RSV2, RSV3 must be clear");
              return;
            }
            if (fragmented && !isTextBinaryFrame(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Invalid frame type was fragmented.");
              return;
            }
            if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
              failWebsocketConnection(this.#handler, 1002, "Expected continuation frame");
              return;
            }
            if (this.#info.fragmented && fragmented) {
              failWebsocketConnection(this.#handler, 1002, "Fragmented frame exceeded 125 bytes.");
              return;
            }
            if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Control frame either too large or fragmented");
              return;
            }
            if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
              failWebsocketConnection(this.#handler, 1002, "Unexpected continuation frame");
              return;
            }
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (isTextBinaryFrame(opcode)) {
              this.#info.binaryType = opcode;
              this.#info.compressed = rsv1 !== 0;
            }
            this.#info.opcode = opcode;
            this.#info.masked = masked;
            this.#info.fin = fin;
            this.#info.fragmented = fragmented;
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.#handler, 1009, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            }
            const body = this.consume(this.#info.payloadLength);
            if (isControlFrame(this.#info.opcode)) {
              this.#loop = this.parseControlFrame(body);
              this.#state = parserStates.INFO;
            } else {
              if (!this.#info.compressed) {
                this.writeFragments(body);
                if (!this.#info.fragmented && this.#info.fin) {
                  websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                }
                this.#state = parserStates.INFO;
              } else {
                this.#extensions.get("permessage-deflate").decompress(body, this.#info.fin, (error, data) => {
                  if (error) {
                    failWebsocketConnection(this.#handler, 1007, error.message);
                    return;
                  }
                  this.writeFragments(data);
                  if (!this.#info.fin) {
                    this.#state = parserStates.INFO;
                    this.#loop = true;
                    this.run(callback);
                    return;
                  }
                  websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                  this.#loop = true;
                  this.#state = parserStates.INFO;
                  this.run(callback);
                });
                this.#loop = false;
                break;
              }
            }
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer}
       */
      consume(n) {
        if (n > this.#byteOffset) {
          throw new Error("Called consume() before buffers satiated.");
        } else if (n === 0) {
          return emptyBuffer;
        }
        this.#byteOffset -= n;
        const first = this.#buffers[0];
        if (first.length > n) {
          this.#buffers[0] = first.subarray(n, first.length);
          return first.subarray(0, n);
        } else if (first.length === n) {
          return this.#buffers.shift();
        } else {
          let offset = 0;
          const buffer = Buffer.allocUnsafeSlow(n);
          while (offset !== n) {
            const next = this.#buffers[0];
            const length = next.length;
            if (length + offset === n) {
              buffer.set(this.#buffers.shift(), offset);
              break;
            } else if (length + offset > n) {
              buffer.set(next.subarray(0, n - offset), offset);
              this.#buffers[0] = next.subarray(n - offset);
              break;
            } else {
              buffer.set(this.#buffers.shift(), offset);
              offset += length;
            }
          }
          return buffer;
        }
      }
      writeFragments(fragment) {
        this.#fragmentsBytes += fragment.length;
        this.#fragments.push(fragment);
      }
      consumeFragments() {
        const fragments = this.#fragments;
        if (fragments.length === 1) {
          this.#fragmentsBytes = 0;
          return fragments.shift();
        }
        let offset = 0;
        const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes);
        for (let i = 0; i < fragments.length; ++i) {
          const buffer = fragments[i];
          output.set(buffer, offset);
          offset += buffer.length;
        }
        this.#fragments = [];
        this.#fragmentsBytes = 0;
        return output;
      }
      parseCloseBody(data) {
        assert(data.length !== 1);
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return { code: 1002, reason: "Invalid status code", error: true };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        try {
          reason = utf8Decode(reason);
        } catch {
          return { code: 1007, reason: "Invalid UTF-8", error: true };
        }
        return { code, reason, error: false };
      }
      /**
       * Parses control frames.
       * @param {Buffer} body
       */
      parseControlFrame(body) {
        const { opcode, payloadLength } = this.#info;
        if (opcode === opcodes.CLOSE) {
          if (payloadLength === 1) {
            failWebsocketConnection(this.#handler, 1002, "Received close frame with a 1-byte body.");
            return false;
          }
          this.#info.closeInfo = this.parseCloseBody(body);
          if (this.#info.closeInfo.error) {
            const { code, reason } = this.#info.closeInfo;
            failWebsocketConnection(this.#handler, code, reason);
            return false;
          }
          if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
            let body2 = emptyBuffer;
            if (this.#info.closeInfo.code) {
              body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
            }
            const closeFrame = new WebsocketFrameSend(body2);
            this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE));
            this.#handler.closeState.add(sentCloseFrameState.SENT);
          }
          this.#handler.readyState = states.CLOSING;
          this.#handler.closeState.add(sentCloseFrameState.RECEIVED);
          return false;
        } else if (opcode === opcodes.PING) {
          if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
            const frame = new WebsocketFrameSend(body);
            this.#handler.socket.write(frame.createFrame(opcodes.PONG));
            if (channels.ping.hasSubscribers) {
              channels.ping.publish({
                payload: body
              });
            }
          }
        } else if (opcode === opcodes.PONG) {
          if (channels.pong.hasSubscribers) {
            channels.pong.publish({
              payload: body
            });
          }
        }
        return true;
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/sender.js
var require_sender = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/sender.js"(exports2, module2) {
    "use strict";
    var { WebsocketFrameSend } = require_frame();
    var { opcodes, sendHints } = require_constants5();
    var FixedQueue = require_fixed_queue();
    var SendQueue = class {
      /**
       * @type {FixedQueue}
       */
      #queue = new FixedQueue();
      /**
       * @type {boolean}
       */
      #running = false;
      /** @type {import('node:net').Socket} */
      #socket;
      constructor(socket) {
        this.#socket = socket;
      }
      add(item, cb, hint) {
        if (hint !== sendHints.blob) {
          if (!this.#running) {
            if (hint === sendHints.text) {
              const { 0: head, 1: body } = WebsocketFrameSend.createFastTextFrame(item);
              this.#socket.cork();
              this.#socket.write(head);
              this.#socket.write(body, cb);
              this.#socket.uncork();
            } else {
              this.#socket.write(createFrame(item, hint), cb);
            }
          } else {
            const node2 = {
              promise: null,
              callback: cb,
              frame: createFrame(item, hint)
            };
            this.#queue.push(node2);
          }
          return;
        }
        const node = {
          promise: item.arrayBuffer().then((ab) => {
            node.promise = null;
            node.frame = createFrame(ab, hint);
          }),
          callback: cb,
          frame: null
        };
        this.#queue.push(node);
        if (!this.#running) {
          this.#run();
        }
      }
      async #run() {
        this.#running = true;
        const queue = this.#queue;
        while (!queue.isEmpty()) {
          const node = queue.shift();
          if (node.promise !== null) {
            await node.promise;
          }
          this.#socket.write(node.frame, node.callback);
          node.callback = node.frame = null;
        }
        this.#running = false;
      }
    };
    function createFrame(data, hint) {
      return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY);
    }
    function toBuffer(data, hint) {
      switch (hint) {
        case sendHints.text:
        case sendHints.typedArray:
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        case sendHints.arrayBuffer:
        case sendHints.blob:
          return new Uint8Array(data);
      }
    }
    module2.exports = { SendQueue };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { environmentSettingsObject } = require_util2();
    var { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = require_constants5();
    var {
      isConnecting,
      isEstablished,
      isClosing,
      isValidSubprotocol,
      fireEvent,
      utf8Decode,
      toArrayBuffer,
      getURLRecord
    } = require_util5();
    var { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = require_connection();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require("node:util");
    var { ErrorEvent, CloseEvent, createFastMessageEvent } = require_events();
    var { SendQueue } = require_sender();
    var { channels } = require_diagnostics();
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /** @type {SendQueue} */
      #sendQueue;
      /** @type {Handler} */
      #handler = {
        onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
        onFail: (code, reason) => this.#onFail(code, reason),
        onMessage: (opcode, data) => this.#onMessage(opcode, data),
        onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
        onParserDrain: () => this.#onParserDrain(),
        onSocketData: (chunk) => {
          if (!this.#parser.write(chunk)) {
            this.#handler.socket.pause();
          }
        },
        onSocketError: (err) => {
          this.#handler.readyState = states.CLOSING;
          if (channels.socketError.hasSubscribers) {
            channels.socketError.publish(err);
          }
          this.#handler.socket.destroy();
        },
        onSocketClose: () => this.#onSocketClose(),
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      };
      #url;
      #binaryType;
      /** @type {import('./receiver').ByteParser} */
      #parser;
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        webidl.util.markAsUncloneable(this);
        const prefix = "WebSocket constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = environmentSettingsObject.settingsObject.baseUrl;
        const urlRecord = getURLRecord(url, baseURL);
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this.#url = new URL(urlRecord.href);
        const client = environmentSettingsObject.settingsObject;
        this.#handler.controller = establishWebSocketConnection(
          urlRecord,
          protocols,
          client,
          this.#handler,
          options
        );
        this.#handler.readyState = _WebSocket.CONNECTING;
        this.#binaryType = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.close";
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        code ??= null;
        reason ??= "";
        closeWebSocketConnection(this.#handler, code, reason, true);
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.send";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        data = webidl.converters.WebSocketSendData(data, prefix, "data");
        if (isConnecting(this.#handler.readyState)) {
          throw new DOMException("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {
          return;
        }
        if (typeof data === "string") {
          const buffer = Buffer.from(data);
          this.#bufferedAmount += buffer.byteLength;
          this.#sendQueue.add(buffer, () => {
            this.#bufferedAmount -= buffer.byteLength;
          }, sendHints.text);
        } else if (types.isArrayBuffer(data)) {
          this.#bufferedAmount += data.byteLength;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.byteLength;
          }, sendHints.arrayBuffer);
        } else if (ArrayBuffer.isView(data)) {
          this.#bufferedAmount += data.byteLength;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.byteLength;
          }, sendHints.typedArray);
        } else if (webidl.is.Blob(data)) {
          this.#bufferedAmount += data.size;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.size;
          }, sendHints.blob);
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this.#handler.readyState;
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this.#url);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this.#binaryType;
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this.#binaryType = "blob";
        } else {
          this.#binaryType = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response, parsedExtensions) {
        this.#handler.socket = response.socket;
        const parser = new ByteParser(this.#handler, parsedExtensions);
        parser.on("drain", () => this.#handler.onParserDrain());
        parser.on("error", (err) => this.#handler.onParserError(err));
        this.#parser = parser;
        this.#sendQueue = new SendQueue(response.socket);
        this.#handler.readyState = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
      #onFail(code, reason) {
        if (reason) {
          fireEvent("error", this, (type, init) => new ErrorEvent(type, init), {
            error: new Error(reason),
            message: reason
          });
        }
        if (!this.#handler.wasEverConnected) {
          this.#handler.readyState = states.CLOSED;
          fireEvent("close", this, (type, init) => new CloseEvent(type, init), {
            wasClean: false,
            code,
            reason
          });
        }
      }
      #onMessage(type, data) {
        if (this.#handler.readyState !== states.OPEN) {
          return;
        }
        let dataForEvent;
        if (type === opcodes.TEXT) {
          try {
            dataForEvent = utf8Decode(data);
          } catch {
            failWebsocketConnection(this.#handler, 1007, "Received invalid UTF-8 in text frame.");
            return;
          }
        } else if (type === opcodes.BINARY) {
          if (this.#binaryType === "blob") {
            dataForEvent = new Blob([data]);
          } else {
            dataForEvent = toArrayBuffer(data);
          }
        }
        fireEvent("message", this, createFastMessageEvent, {
          origin: this.#url.origin,
          data: dataForEvent
        });
      }
      #onParserDrain() {
        this.#handler.socket.resume();
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
       */
      #onSocketClose() {
        const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
        let code = 1005;
        let reason = "";
        const result = this.#parser.closingInfo;
        if (result && !result.error) {
          code = result.code ?? 1005;
          reason = result.reason;
        } else if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          code = 1006;
        }
        this.#handler.readyState = states.CLOSED;
        fireEvent("close", this, (type, init) => new CloseEvent(type, init), {
          wasClean,
          code,
          reason
        });
        if (channels.close.hasSubscribers) {
          channels.close.publish({
            websocket: this,
            code,
            reason
          });
        }
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V, prefix, argument);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        defaultValue: () => new Array(0)
      },
      {
        key: "dispatcher",
        converter: webidl.converters.any,
        defaultValue: () => getGlobalDispatcher()
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
        if (webidl.is.Blob(V)) {
          return V;
        }
        if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
          return V;
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/stream/websocketerror.js
var require_websocketerror = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/stream/websocketerror.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { validateCloseCodeAndReason } = require_util5();
    var { kConstruct } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var WebSocketError = class _WebSocketError extends DOMException {
      #closeCode;
      #reason;
      constructor(message = "", init = void 0) {
        message = webidl.converters.DOMString(message, "WebSocketError", "message");
        super(message, "WebSocketError");
        if (init === kConstruct) {
          return;
        } else if (init !== null) {
          init = webidl.converters.WebSocketCloseInfo(init);
        }
        let code = init.closeCode ?? null;
        const reason = init.reason ?? "";
        validateCloseCodeAndReason(code, reason);
        if (reason.length !== 0 && code === null) {
          code = 1e3;
        }
        this.#closeCode = code;
        this.#reason = reason;
      }
      get closeCode() {
        return this.#closeCode;
      }
      get reason() {
        return this.#reason;
      }
      /**
       * @param {string} message
       * @param {number|null} code
       * @param {string} reason
       */
      static createUnvalidatedWebSocketError(message, code, reason) {
        const error = new _WebSocketError(message, kConstruct);
        error.#closeCode = code;
        error.#reason = reason;
        return error;
      }
    };
    var { createUnvalidatedWebSocketError } = WebSocketError;
    delete WebSocketError.createUnvalidatedWebSocketError;
    Object.defineProperties(WebSocketError.prototype, {
      closeCode: kEnumerableProperty,
      reason: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocketError",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    webidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError);
    module2.exports = { WebSocketError, createUnvalidatedWebSocketError };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/stream/websocketstream.js
var require_websocketstream = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/websocket/stream/websocketstream.js"(exports2, module2) {
    "use strict";
    var { createDeferredPromise, environmentSettingsObject } = require_util2();
    var { states, opcodes, sentCloseFrameState } = require_constants5();
    var { webidl } = require_webidl();
    var { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = require_util5();
    var { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = require_connection();
    var { types } = require("node:util");
    var { channels } = require_diagnostics();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { WebSocketError, createUnvalidatedWebSocketError } = require_websocketerror();
    var { utf8DecodeBytes } = require_util2();
    var { kEnumerableProperty } = require_util();
    var emittedExperimentalWarning = false;
    var WebSocketStream = class {
      // Each WebSocketStream object has an associated url , which is a URL record .
      /** @type {URL} */
      #url;
      // Each WebSocketStream object has an associated opened promise , which is a promise.
      /** @type {ReturnType<typeof createDeferredPromise>} */
      #openedPromise;
      // Each WebSocketStream object has an associated closed promise , which is a promise.
      /** @type {ReturnType<typeof createDeferredPromise>} */
      #closedPromise;
      // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .
      /** @type {ReadableStream} */
      #readableStream;
      /** @type {ReadableStreamDefaultController} */
      #readableStreamController;
      // Each WebSocketStream object has an associated writable stream , which is a WritableStream .
      /** @type {WritableStream} */
      #writableStream;
      // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.
      #handshakeAborted = false;
      /** @type {import('../websocket').Handler} */
      #handler = {
        // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol
        onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
        onFail: (_code, _reason) => {
        },
        onMessage: (opcode, data) => this.#onMessage(opcode, data),
        onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
        onParserDrain: () => this.#handler.socket.resume(),
        onSocketData: (chunk) => {
          if (!this.#parser.write(chunk)) {
            this.#handler.socket.pause();
          }
        },
        onSocketError: (err) => {
          this.#handler.readyState = states.CLOSING;
          if (channels.socketError.hasSubscribers) {
            channels.socketError.publish(err);
          }
          this.#handler.socket.destroy();
        },
        onSocketClose: () => this.#onSocketClose(),
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      };
      /** @type {import('../receiver').ByteParser} */
      #parser;
      constructor(url, options = void 0) {
        if (!emittedExperimentalWarning) {
          process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", {
            code: "UNDICI-WSS"
          });
          emittedExperimentalWarning = true;
        }
        webidl.argumentLengthCheck(arguments, 1, "WebSocket");
        url = webidl.converters.USVString(url);
        if (options !== null) {
          options = webidl.converters.WebSocketStreamOptions(options);
        }
        const baseURL = environmentSettingsObject.settingsObject.baseUrl;
        const urlRecord = getURLRecord(url, baseURL);
        const protocols = options.protocols;
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this.#url = urlRecord.toString();
        this.#openedPromise = createDeferredPromise();
        this.#closedPromise = createDeferredPromise();
        if (options.signal != null) {
          const signal = options.signal;
          if (signal.aborted) {
            this.#openedPromise.reject(signal.reason);
            this.#closedPromise.reject(signal.reason);
            return;
          }
          signal.addEventListener("abort", () => {
            if (!isEstablished(this.#handler.readyState)) {
              failWebsocketConnection(this.#handler);
              this.#handler.readyState = states.CLOSING;
              this.#openedPromise.reject(signal.reason);
              this.#closedPromise.reject(signal.reason);
              this.#handshakeAborted = true;
            }
          }, { once: true });
        }
        const client = environmentSettingsObject.settingsObject;
        this.#handler.controller = establishWebSocketConnection(
          urlRecord,
          protocols,
          client,
          this.#handler,
          options
        );
      }
      // The url getter steps are to return this 's url , serialized .
      get url() {
        return this.#url.toString();
      }
      // The opened getter steps are to return this 's opened promise .
      get opened() {
        return this.#openedPromise.promise;
      }
      // The closed getter steps are to return this 's closed promise .
      get closed() {
        return this.#closedPromise.promise;
      }
      // The close( closeInfo ) method steps are:
      close(closeInfo = void 0) {
        if (closeInfo !== null) {
          closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo);
        }
        const code = closeInfo.closeCode ?? null;
        const reason = closeInfo.reason;
        closeWebSocketConnection(this.#handler, code, reason, true);
      }
      #write(chunk) {
        const promise = createDeferredPromise();
        let data = null;
        let opcode = null;
        if (ArrayBuffer.isView(chunk) || types.isArrayBuffer(chunk)) {
          data = new Uint8Array(ArrayBuffer.isView(chunk) ? new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength) : chunk);
          opcode = opcodes.BINARY;
        } else {
          let string;
          try {
            string = webidl.converters.DOMString(chunk);
          } catch (e) {
            promise.reject(e);
            return;
          }
          data = new TextEncoder().encode(string);
          opcode = opcodes.TEXT;
        }
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          const frame = new WebsocketFrameSend(data);
          this.#handler.socket.write(frame.createFrame(opcode), () => {
            promise.resolve(void 0);
          });
        }
        return promise;
      }
      /** @type {import('../websocket').Handler['onConnectionEstablished']} */
      #onConnectionEstablished(response, parsedExtensions) {
        this.#handler.socket = response.socket;
        const parser = new ByteParser(this.#handler, parsedExtensions);
        parser.on("drain", () => this.#handler.onParserDrain());
        parser.on("error", (err) => this.#handler.onParserError(err));
        this.#parser = parser;
        this.#handler.readyState = states.OPEN;
        const extensions = parsedExtensions ?? "";
        const protocol = response.headersList.get("sec-websocket-protocol") ?? "";
        const readable = new ReadableStream({
          start: (controller) => {
            this.#readableStreamController = controller;
          },
          pull(controller) {
            let chunk;
            while (controller.desiredSize > 0 && (chunk = response.socket.read()) !== null) {
              controller.enqueue(chunk);
            }
          },
          cancel: (reason) => this.#cancel(reason)
        });
        const writable = new WritableStream({
          write: (chunk) => this.#write(chunk),
          close: () => closeWebSocketConnection(this.#handler, null, null),
          abort: (reason) => this.#closeUsingReason(reason)
        });
        this.#readableStream = readable;
        this.#writableStream = writable;
        this.#openedPromise.resolve({
          extensions,
          protocol,
          readable,
          writable
        });
      }
      /** @type {import('../websocket').Handler['onMessage']} */
      #onMessage(type, data) {
        if (this.#handler.readyState !== states.OPEN) {
          return;
        }
        let chunk;
        if (type === opcodes.TEXT) {
          try {
            chunk = utf8Decode(data);
          } catch {
            failWebsocketConnection(this.#handler, "Received invalid UTF-8 in text frame.");
            return;
          }
        } else if (type === opcodes.BINARY) {
          chunk = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        }
        this.#readableStreamController.enqueue(chunk);
      }
      /** @type {import('../websocket').Handler['onSocketClose']} */
      #onSocketClose() {
        const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
        this.#handler.readyState = states.CLOSED;
        if (this.#handshakeAborted) {
          return;
        }
        if (!this.#handler.wasEverConnected) {
          this.#openedPromise.reject(new WebSocketError("Socket never opened"));
        }
        const result = this.#parser.closingInfo;
        let code = result?.code ?? 1005;
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          code = 1006;
        }
        const reason = result?.reason == null ? "" : utf8DecodeBytes(Buffer.from(result.reason));
        if (wasClean) {
          this.#readableStream.cancel().catch(() => {
          });
          if (!this.#writableStream.locked) {
            this.#writableStream.abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError"));
          }
          this.#closedPromise.resolve({
            closeCode: code,
            reason
          });
        } else {
          const error = createUnvalidatedWebSocketError("unclean close", code, reason);
          this.#readableStreamController.error(error);
          this.#writableStream.abort(error);
          this.#closedPromise.reject(error);
        }
      }
      #closeUsingReason(reason) {
        let code = null;
        let reasonString = "";
        if (webidl.is.WebSocketError(reason)) {
          code = reason.closeCode;
          reasonString = reason.reason;
        }
        closeWebSocketConnection(this.#handler, code, reasonString);
      }
      //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .
      #cancel(reason) {
        this.#closeUsingReason(reason);
      }
    };
    Object.defineProperties(WebSocketStream.prototype, {
      url: kEnumerableProperty,
      opened: kEnumerableProperty,
      closed: kEnumerableProperty,
      close: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocketStream",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    webidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.sequenceConverter(webidl.converters.USVString),
        defaultValue: () => []
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(webidl.converters.AbortSignal),
        defaultValue: () => null
      }
    ]);
    webidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([
      {
        key: "closeCode",
        converter: (V) => webidl.converters["unsigned short"](V, { enforceRange: true })
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      }
    ]);
    module2.exports = { WebSocketStream };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/eventsource/util.js
var require_util6 = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/eventsource/util.js"(exports2, module2) {
    "use strict";
    function isValidLastEventId(value) {
      return value.indexOf("\0") === -1;
    }
    function isASCIINumber(value) {
      if (value.length === 0) return false;
      for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
      }
      return true;
    }
    function delay(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms).unref();
      });
    }
    module2.exports = {
      isValidLastEventId,
      isASCIINumber,
      delay
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/eventsource/eventsource-stream.js
var require_eventsource_stream = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/eventsource/eventsource-stream.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("node:stream");
    var { isASCIINumber, isValidLastEventId } = require_util6();
    var BOM = [239, 187, 191];
    var LF = 10;
    var CR = 13;
    var COLON = 58;
    var SPACE = 32;
    var EventSourceStream = class extends Transform {
      /**
       * @type {eventSourceSettings}
       */
      state;
      /**
       * Leading byte-order-mark check.
       * @type {boolean}
       */
      checkBOM = true;
      /**
       * @type {boolean}
       */
      crlfCheck = false;
      /**
       * @type {boolean}
       */
      eventEndCheck = false;
      /**
       * @type {Buffer|null}
       */
      buffer = null;
      pos = 0;
      event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
      /**
       * @param {object} options
       * @param {boolean} [options.readableObjectMode]
       * @param {eventSourceSettings} [options.eventSourceSettings]
       * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]
       */
      constructor(options = {}) {
        options.readableObjectMode = true;
        super(options);
        this.state = options.eventSourceSettings || {};
        if (options.push) {
          this.push = options.push;
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {string} _encoding
       * @param {Function} callback
       * @returns {void}
       */
      _transform(chunk, _encoding, callback) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        if (this.buffer) {
          this.buffer = Buffer.concat([this.buffer, chunk]);
        } else {
          this.buffer = chunk;
        }
        if (this.checkBOM) {
          switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === BOM[0]) {
                callback();
                return;
              }
              this.checkBOM = false;
              callback();
              return;
            case 2:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = Buffer.alloc(0);
                this.checkBOM = false;
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = this.buffer.subarray(3);
              }
              this.checkBOM = false;
              break;
          }
        }
        while (this.pos < this.buffer.length) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === LF) {
                this.buffer = this.buffer.subarray(this.pos + 1);
                this.pos = 0;
                this.crlfCheck = false;
                continue;
              }
              this.crlfCheck = false;
            }
            if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
              if (this.buffer[this.pos] === CR) {
                this.crlfCheck = true;
              }
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              if (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) {
                this.processEvent(this.event);
              }
              this.clearEvent();
              continue;
            }
            this.eventEndCheck = false;
            continue;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.parseLine(this.buffer.subarray(0, this.pos), this.event);
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            this.eventEndCheck = true;
            continue;
          }
          this.pos++;
        }
        callback();
      }
      /**
       * @param {Buffer} line
       * @param {EventSourceStreamEvent} event
       */
      parseLine(line, event) {
        if (line.length === 0) {
          return;
        }
        const colonPosition = line.indexOf(COLON);
        if (colonPosition === 0) {
          return;
        }
        let field = "";
        let value = "";
        if (colonPosition !== -1) {
          field = line.subarray(0, colonPosition).toString("utf8");
          let valueStart = colonPosition + 1;
          if (line[valueStart] === SPACE) {
            ++valueStart;
          }
          value = line.subarray(valueStart).toString("utf8");
        } else {
          field = line.toString("utf8");
          value = "";
        }
        switch (field) {
          case "data":
            if (event[field] === void 0) {
              event[field] = value;
            } else {
              event[field] += `
${value}`;
            }
            break;
          case "retry":
            if (isASCIINumber(value)) {
              event[field] = value;
            }
            break;
          case "id":
            if (isValidLastEventId(value)) {
              event[field] = value;
            }
            break;
          case "event":
            if (value.length > 0) {
              event[field] = value;
            }
            break;
        }
      }
      /**
       * @param {EventSourceStreamEvent} event
       */
      processEvent(event) {
        if (event.retry && isASCIINumber(event.retry)) {
          this.state.reconnectionTime = parseInt(event.retry, 10);
        }
        if (event.id && isValidLastEventId(event.id)) {
          this.state.lastEventId = event.id;
        }
        if (event.data !== void 0) {
          this.push({
            type: event.event || "message",
            options: {
              data: event.data,
              lastEventId: this.state.lastEventId,
              origin: this.state.origin
            }
          });
        }
      }
      clearEvent() {
        this.event = {
          data: void 0,
          event: void 0,
          id: void 0,
          retry: void 0
        };
      }
    };
    module2.exports = {
      EventSourceStream
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/lib/web/eventsource/eventsource.js
var require_eventsource = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/lib/web/eventsource/eventsource.js"(exports2, module2) {
    "use strict";
    var { pipeline } = require("node:stream");
    var { fetching } = require_fetch();
    var { makeRequest } = require_request2();
    var { webidl } = require_webidl();
    var { EventSourceStream } = require_eventsource_stream();
    var { parseMIMEType } = require_data_url();
    var { createFastMessageEvent } = require_events();
    var { isNetworkError } = require_response();
    var { delay } = require_util6();
    var { kEnumerableProperty } = require_util();
    var { environmentSettingsObject } = require_util2();
    var experimentalWarned = false;
    var defaultReconnectionTime = 3e3;
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSED = 2;
    var ANONYMOUS = "anonymous";
    var USE_CREDENTIALS = "use-credentials";
    var EventSource = class _EventSource extends EventTarget {
      #events = {
        open: null,
        error: null,
        message: null
      };
      #url;
      #withCredentials = false;
      /**
       * @type {ReadyState}
       */
      #readyState = CONNECTING;
      #request = null;
      #controller = null;
      #dispatcher;
      /**
       * @type {import('./eventsource-stream').eventSourceSettings}
       */
      #state;
      /**
       * Creates a new EventSource object.
       * @param {string} url
       * @param {EventSourceInit} [eventSourceInitDict={}]
       * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
       */
      constructor(url, eventSourceInitDict = {}) {
        super();
        webidl.util.markAsUncloneable(this);
        const prefix = "EventSource constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("EventSource is experimental, expect them to change at any time.", {
            code: "UNDICI-ES"
          });
        }
        url = webidl.converters.USVString(url);
        eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
        this.#dispatcher = eventSourceInitDict.dispatcher;
        this.#state = {
          lastEventId: "",
          reconnectionTime: defaultReconnectionTime
        };
        const settings = environmentSettingsObject;
        let urlRecord;
        try {
          urlRecord = new URL(url, settings.settingsObject.baseUrl);
          this.#state.origin = urlRecord.origin;
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        this.#url = urlRecord.href;
        let corsAttributeState = ANONYMOUS;
        if (eventSourceInitDict.withCredentials === true) {
          corsAttributeState = USE_CREDENTIALS;
          this.#withCredentials = true;
        }
        const initRequest = {
          redirect: "follow",
          keepalive: true,
          // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
          mode: "cors",
          credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
          referrer: "no-referrer"
        };
        initRequest.client = environmentSettingsObject.settingsObject;
        initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
        initRequest.cache = "no-store";
        initRequest.initiator = "other";
        initRequest.urlList = [new URL(this.#url)];
        this.#request = makeRequest(initRequest);
        this.#connect();
      }
      /**
       * Returns the state of this EventSource object's connection. It can have the
       * values described below.
       * @returns {ReadyState}
       * @readonly
       */
      get readyState() {
        return this.#readyState;
      }
      /**
       * Returns the URL providing the event stream.
       * @readonly
       * @returns {string}
       */
      get url() {
        return this.#url;
      }
      /**
       * Returns a boolean indicating whether the EventSource object was
       * instantiated with CORS credentials set (true), or not (false, the default).
       */
      get withCredentials() {
        return this.#withCredentials;
      }
      #connect() {
        if (this.#readyState === CLOSED) return;
        this.#readyState = CONNECTING;
        const fetchParams = {
          request: this.#request,
          dispatcher: this.#dispatcher
        };
        const processEventSourceEndOfBody = (response) => {
          if (isNetworkError(response)) {
            this.dispatchEvent(new Event("error"));
            this.close();
          }
          this.#reconnect();
        };
        fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
        fetchParams.processResponse = (response) => {
          if (isNetworkError(response)) {
            if (response.aborted) {
              this.close();
              this.dispatchEvent(new Event("error"));
              return;
            } else {
              this.#reconnect();
              return;
            }
          }
          const contentType = response.headersList.get("content-type", true);
          const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
          const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
          if (response.status !== 200 || contentTypeValid === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          }
          this.#readyState = OPEN;
          this.dispatchEvent(new Event("open"));
          this.#state.origin = response.urlList[response.urlList.length - 1].origin;
          const eventSourceStream = new EventSourceStream({
            eventSourceSettings: this.#state,
            push: (event) => {
              this.dispatchEvent(createFastMessageEvent(
                event.type,
                event.options
              ));
            }
          });
          pipeline(
            response.body.stream,
            eventSourceStream,
            (error) => {
              if (error?.aborted === false) {
                this.close();
                this.dispatchEvent(new Event("error"));
              }
            }
          );
        };
        this.#controller = fetching(fetchParams);
      }
      /**
       * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
       * @returns {Promise<void>}
       */
      async #reconnect() {
        if (this.#readyState === CLOSED) return;
        this.#readyState = CONNECTING;
        this.dispatchEvent(new Event("error"));
        await delay(this.#state.reconnectionTime);
        if (this.#readyState !== CONNECTING) return;
        if (this.#state.lastEventId.length) {
          this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
        }
        this.#connect();
      }
      /**
       * Closes the connection, if any, and sets the readyState attribute to
       * CLOSED.
       */
      close() {
        webidl.brandCheck(this, _EventSource);
        if (this.#readyState === CLOSED) return;
        this.#readyState = CLOSED;
        this.#controller.abort();
        this.#request = null;
      }
      get onopen() {
        return this.#events.open;
      }
      set onopen(fn) {
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onmessage() {
        return this.#events.message;
      }
      set onmessage(fn) {
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get onerror() {
        return this.#events.error;
      }
      set onerror(fn) {
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
    };
    var constantsPropertyDescriptors = {
      CONNECTING: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CONNECTING,
        writable: false
      },
      OPEN: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: OPEN,
        writable: false
      },
      CLOSED: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CLOSED,
        writable: false
      }
    };
    Object.defineProperties(EventSource, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, {
      close: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      onopen: kEnumerableProperty,
      readyState: kEnumerableProperty,
      url: kEnumerableProperty,
      withCredentials: kEnumerableProperty
    });
    webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
      {
        key: "withCredentials",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "dispatcher",
        // undici only
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      EventSource,
      defaultReconnectionTime
    };
  }
});

// node_modules/@elastic/transport/node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/@elastic/transport/node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client3 = require_client();
    var Dispatcher = require_dispatcher();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var ProxyAgent = require_proxy_agent();
    var EnvHttpProxyAgent = require_env_http_proxy_agent();
    var RetryAgent = require_retry_agent();
    var H2CClient = require_h2c_client();
    var errors = require_errors2();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var { MockCallHistory, MockCallHistoryLog } = require_mock_call_history();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var RetryHandler = require_retry_handler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_decorator_handler();
    var RedirectHandler = require_redirect_handler();
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client3;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
    module2.exports.RetryAgent = RetryAgent;
    module2.exports.H2CClient = H2CClient;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.interceptors = {
      redirect: require_redirect(),
      responseError: require_response_error(),
      retry: require_retry(),
      dump: require_dump(),
      dns: require_dns(),
      cache: require_cache2()
    };
    module2.exports.cacheStores = {
      MemoryCacheStore: require_memory_cache_store()
    };
    var SqliteCacheStore = require_sqlite_cache_store();
    module2.exports.cacheStores.SqliteCacheStore = SqliteCacheStore;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    module2.exports.util = {
      parseHeaders: util.parseHeaders,
      headerNameToString: util.headerNameToString
    };
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    var fetchImpl = require_fetch().fetch;
    module2.exports.fetch = async function fetch(init, options = void 0) {
      try {
        return await fetchImpl(init, options);
      } catch (err) {
        if (err && typeof err === "object") {
          Error.captureStackTrace(err);
        }
        throw err;
      }
    };
    module2.exports.Headers = require_headers().Headers;
    module2.exports.Response = require_response().Response;
    module2.exports.Request = require_request2().Request;
    module2.exports.FormData = require_formdata().FormData;
    var { setGlobalOrigin, getGlobalOrigin } = require_global();
    module2.exports.setGlobalOrigin = setGlobalOrigin;
    module2.exports.getGlobalOrigin = getGlobalOrigin;
    var { CacheStorage } = require_cachestorage();
    var { kConstruct } = require_symbols2();
    module2.exports.caches = new CacheStorage(kConstruct);
    var { deleteCookie, getCookies, getSetCookies, setCookie, parseCookie } = require_cookies();
    module2.exports.deleteCookie = deleteCookie;
    module2.exports.getCookies = getCookies;
    module2.exports.getSetCookies = getSetCookies;
    module2.exports.setCookie = setCookie;
    module2.exports.parseCookie = parseCookie;
    var { parseMIMEType, serializeAMimeType } = require_data_url();
    module2.exports.parseMIMEType = parseMIMEType;
    module2.exports.serializeAMimeType = serializeAMimeType;
    var { CloseEvent, ErrorEvent, MessageEvent } = require_events();
    module2.exports.WebSocket = require_websocket().WebSocket;
    module2.exports.CloseEvent = CloseEvent;
    module2.exports.ErrorEvent = ErrorEvent;
    module2.exports.MessageEvent = MessageEvent;
    module2.exports.WebSocketStream = require_websocketstream().WebSocketStream;
    module2.exports.WebSocketError = require_websocketerror().WebSocketError;
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockCallHistory = MockCallHistory;
    module2.exports.MockCallHistoryLog = MockCallHistoryLog;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
    var { EventSource } = require_eventsource();
    module2.exports.EventSource = EventSource;
  }
});

// node_modules/@elastic/transport/lib/connection/UndiciConnection.js
var require_UndiciConnection = __commonJS({
  "node_modules/@elastic/transport/lib/connection/UndiciConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var debug_1 = tslib_1.__importDefault(require_src());
    var node_buffer_1 = tslib_1.__importDefault(require("node:buffer"));
    var BaseConnection_1 = tslib_1.__importStar(require_BaseConnection());
    var undici_1 = require_undici();
    var errors_1 = require_errors();
    var symbols_1 = require_symbols();
    var debug = (0, debug_1.default)("elasticsearch");
    var INVALID_PATH_REGEX = /[^\u0021-\u00ff]/;
    var MAX_BUFFER_LENGTH = node_buffer_1.default.constants.MAX_LENGTH;
    var MAX_STRING_LENGTH = node_buffer_1.default.constants.MAX_STRING_LENGTH;
    var Connection = class extends BaseConnection_1.default {
      constructor(opts) {
        var _a, _b, _c;
        super(opts);
        Object.defineProperty(this, "pool", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        if (opts.proxy != null) {
          throw new errors_1.ConfigurationError("Undici connection can't work with proxies");
        }
        if (typeof opts.agent === "function" || typeof opts.agent === "boolean") {
          throw new errors_1.ConfigurationError("Undici connection agent options can't be a function or a boolean");
        }
        if (opts.agent != null && !isUndiciAgentOptions(opts.agent)) {
          throw new errors_1.ConfigurationError("Bad agent configuration for Undici agent");
        }
        const undiciOptions = {
          keepAliveTimeout: 6e5,
          keepAliveMaxTimeout: 6e5,
          keepAliveTimeoutThreshold: 1e3,
          pipelining: 1,
          maxHeaderSize: 16384,
          connections: 256,
          // only set a timeout if it has a value; default to no timeout
          // see https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-network.html#_http_client_configuration
          headersTimeout: (_a = this.timeout) !== null && _a !== void 0 ? _a : 0,
          bodyTimeout: (_b = this.timeout) !== null && _b !== void 0 ? _b : 0,
          ...opts.agent
        };
        if (this[symbols_1.kCaFingerprint] !== null) {
          const caFingerprint = this[symbols_1.kCaFingerprint];
          const connector = (0, undici_1.buildConnector)((_c = this.tls) !== null && _c !== void 0 ? _c : {});
          undiciOptions.connect = function(opts2, cb) {
            connector(opts2, (err, socket) => {
              if (err != null) {
                return cb(err, null);
              }
              if (caFingerprint !== null && isTlsSocket(opts2, socket)) {
                const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);
                if (issuerCertificate == null) {
                  socket.destroy();
                  return cb(new Error("Invalid or malformed certificate"), null);
                }
                if (Object.keys(issuerCertificate).length === 0 && socket.isSessionReused()) {
                  return cb(null, socket);
                }
                if (!(0, BaseConnection_1.isCaFingerprintMatch)(caFingerprint, issuerCertificate.fingerprint256)) {
                  socket.destroy();
                  return cb(new Error("Server certificate CA fingerprint does not match the value configured in caFingerprint"), null);
                }
              }
              return cb(null, socket);
            });
          };
        } else if (this.tls !== null) {
          undiciOptions.connect = this.tls;
        }
        this.pool = new undici_1.Pool(this.url.toString(), undiciOptions);
      }
      async request(params, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const maxResponseSize = (_a = options.maxResponseSize) !== null && _a !== void 0 ? _a : MAX_STRING_LENGTH;
        const maxCompressedResponseSize = (_b = options.maxCompressedResponseSize) !== null && _b !== void 0 ? _b : MAX_BUFFER_LENGTH;
        const requestParams = {
          method: params.method,
          path: params.path + (params.querystring == null || params.querystring === "" ? "" : `?${params.querystring}`),
          headers: Object.assign({}, this.headers, params.headers),
          body: params.body,
          signal: (_c = options.signal) !== null && _c !== void 0 ? _c : new AbortController().signal
        };
        if (requestParams.path[0] !== "/") {
          requestParams.path = `/${requestParams.path}`;
        }
        let timedout = false;
        let timeoutId;
        if (options.timeout != null && options.timeout !== this.timeout) {
          timeoutId = setTimeout(() => {
            timedout = true;
            requestParams.signal.dispatchEvent(new Event("abort"));
          }, options.timeout);
        }
        if (INVALID_PATH_REGEX.test(requestParams.path)) {
          throw new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`);
        }
        debug("Starting a new request", params);
        let response;
        try {
          response = await this.pool.request(requestParams);
          if (timeoutId != null)
            clearTimeout(timeoutId);
        } catch (err) {
          if (timeoutId != null)
            clearTimeout(timeoutId);
          switch (err.code) {
            case "UND_ERR_ABORTED":
            case DOMException.ABORT_ERR:
              throw timedout ? new errors_1.TimeoutError("Request timed out") : new errors_1.RequestAbortedError("Request aborted");
            case "UND_ERR_HEADERS_TIMEOUT":
              throw new errors_1.TimeoutError("Request timed out");
            case "UND_ERR_SOCKET":
              throw new errors_1.ConnectionError(`${err.message} - Local: ${(_e = (_d = err.socket) === null || _d === void 0 ? void 0 : _d.localAddress) !== null && _e !== void 0 ? _e : "unknown"}:${(_g = (_f = err.socket) === null || _f === void 0 ? void 0 : _f.localPort) !== null && _g !== void 0 ? _g : "unknown"}, Remote: ${(_j = (_h = err.socket) === null || _h === void 0 ? void 0 : _h.remoteAddress) !== null && _j !== void 0 ? _j : "unknown"}:${(_l = (_k = err.socket) === null || _k === void 0 ? void 0 : _k.remotePort) !== null && _l !== void 0 ? _l : "unknown"}`);
            // eslint-disable-line
            default:
              throw new errors_1.ConnectionError(err.message);
          }
        }
        if (options.asStream === true) {
          return {
            statusCode: response.statusCode,
            headers: response.headers,
            body: response.body
          };
        }
        const contentEncoding = ((_m = response.headers["content-encoding"]) !== null && _m !== void 0 ? _m : "").toLowerCase();
        const isCompressed = contentEncoding.includes("gzip") || contentEncoding.includes("deflate");
        const bodyIsBinary = (0, BaseConnection_1.isBinary)((_o = response.headers["content-type"]) !== null && _o !== void 0 ? _o : "");
        if (response.headers["content-length"] !== void 0) {
          const contentLength = Number(response.headers["content-length"]);
          if (isCompressed && contentLength > maxCompressedResponseSize) {
            response.body.destroy();
            throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`);
          } else if (contentLength > maxResponseSize) {
            response.body.destroy();
            throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`);
          }
        }
        this.diagnostic.emit("deserialization", null, options);
        try {
          if (isCompressed || bodyIsBinary) {
            let currentLength = 0;
            const payload = [];
            for await (const chunk of response.body) {
              currentLength += Buffer.byteLength(chunk);
              if (currentLength > maxCompressedResponseSize) {
                response.body.destroy();
                throw new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`);
              }
              payload.push(chunk);
            }
            return {
              statusCode: response.statusCode,
              headers: response.headers,
              body: Buffer.concat(payload)
            };
          } else {
            let payload = "";
            let currentLength = 0;
            response.body.setEncoding("utf8");
            for await (const chunk of response.body) {
              currentLength += Buffer.byteLength(chunk);
              if (currentLength > maxResponseSize) {
                response.body.destroy();
                throw new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed string (${maxResponseSize})`);
              }
              payload += chunk;
            }
            return {
              statusCode: response.statusCode,
              headers: response.headers,
              body: payload
            };
          }
        } catch (err) {
          if (err.name === "RequestAbortedError") {
            throw err;
          }
          throw new errors_1.ConnectionError(err.message);
        }
      }
      async close() {
        debug("Closing connection", this.id);
        await this.pool.close();
      }
    };
    exports2.default = Connection;
    function isUndiciAgentOptions(opts) {
      if (opts.keepAlive != null)
        return false;
      if (opts.keepAliveMsecs != null)
        return false;
      if (opts.maxSockets != null)
        return false;
      if (opts.maxFreeSockets != null)
        return false;
      if (opts.scheduling != null)
        return false;
      if (opts.proxy != null)
        return false;
      return true;
    }
    function isTlsSocket(opts, socket) {
      return socket !== null && opts.protocol === "https:";
    }
  }
});

// node_modules/@elastic/transport/lib/connection/index.js
var require_connection2 = __commonJS({
  "node_modules/@elastic/transport/lib/connection/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UndiciConnection = exports2.HttpConnection = exports2.BaseConnection = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var BaseConnection_1 = tslib_1.__importDefault(require_BaseConnection());
    exports2.BaseConnection = BaseConnection_1.default;
    var HttpConnection_1 = tslib_1.__importDefault(require_HttpConnection());
    exports2.HttpConnection = HttpConnection_1.default;
    var UndiciConnection_1 = tslib_1.__importDefault(require_UndiciConnection());
    exports2.UndiciConnection = UndiciConnection_1.default;
  }
});

// node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js
var require_BaseConnectionPool = __commonJS({
  "node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultNodeFilter = defaultNodeFilter;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_url_1 = require("node:url");
    var debug_1 = tslib_1.__importDefault(require_src());
    var Diagnostic_1 = tslib_1.__importDefault(require_Diagnostic());
    var symbols_1 = require_symbols();
    var connection_1 = require_connection2();
    var errors_1 = require_errors();
    var debug = (0, debug_1.default)("elasticsearch");
    function defaultNodeFilter(conn) {
      if (conn.roles != null) {
        if (
          // avoid master-only nodes
          conn.roles.master && !conn.roles.data && !conn.roles.ingest && !conn.roles.ml
        )
          return false;
      }
      return true;
    }
    var BaseConnectionPool = class {
      constructor(opts) {
        var _b;
        Object.defineProperty(this, "connections", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "Connection", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "diagnostic", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "auth", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_agent", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_proxy", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_tls", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _a, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.connections = [];
        this.size = this.connections.length;
        this.Connection = opts.Connection;
        this.diagnostic = (_b = opts.diagnostic) !== null && _b !== void 0 ? _b : new Diagnostic_1.default();
        this.auth = opts.auth;
        this._tls = opts.tls;
        this._agent = opts.agent;
        this._proxy = opts.proxy;
        this[symbols_1.kCaFingerprint] = opts.caFingerprint;
      }
      markAlive(connection) {
        connection.status = connection_1.BaseConnection.statuses.ALIVE;
        return this;
      }
      markDead(connection) {
        connection.status = connection_1.BaseConnection.statuses.DEAD;
        return this;
      }
      getConnection(opts) {
        throw new errors_1.ConfigurationError("The getConnection method should be implemented by extended classes");
      }
      /**
       * Creates a new connection instance.
       */
      createConnection(opts) {
        if (typeof opts === "string") {
          opts = this.urlToHost(opts);
        }
        if (this.auth != null) {
          opts.auth = this.auth;
        } else if (opts.url.username !== "" && opts.url.password !== "") {
          opts.auth = {
            username: decodeURIComponent(opts.url.username),
            password: decodeURIComponent(opts.url.password)
          };
        }
        if (opts.tls == null)
          opts.tls = this._tls;
        if (opts.agent == null)
          opts.agent = this._agent;
        if (opts.proxy == null)
          opts.proxy = this._proxy;
        if (opts.diagnostic == null)
          opts.diagnostic = this.diagnostic;
        if (opts.caFingerprint == null)
          opts.caFingerprint = this[symbols_1.kCaFingerprint];
        const connection = new this.Connection(opts);
        for (const conn of this.connections) {
          if (conn.id === connection.id) {
            throw new Error(`Connection with id '${connection.id}' is already present`);
          }
        }
        return connection;
      }
      /**
       * Adds a new connection to the pool.
       *
       * @param connection Connection options, or the URL of a node
       * @returns This ConnectionPool instance
       */
      addConnection(connection) {
        if (Array.isArray(connection)) {
          const connections = [];
          for (const conn of connection) {
            connections.push(this.createConnection(conn));
          }
          return this.update([...this.connections, ...connections]);
        } else {
          return this.update([...this.connections, this.createConnection(connection)]);
        }
      }
      /**
       * Removes a connection from the pool.
       *
       * @param connection The connection to remove
       * @returns This ConnectionPool instance
       */
      removeConnection(connection) {
        debug("Removing connection", connection);
        return this.update(this.connections.filter((c) => c.id !== connection.id));
      }
      /**
       * Empties the connection pool.
       *
       * @returns {ConnectionPool}
       */
      async empty() {
        debug("Emptying the connection pool");
        const connections = this.connections;
        this.connections = [];
        this.size = 0;
        for (const connection of connections) {
          await connection.close();
        }
      }
      /**
       * Update the ConnectionPool with new connections.
       *
       * @param nodes array of connections
       * @returns {ConnectionPool}
       */
      update(nodes) {
        debug("Updating the connection pool");
        const newConnections = [];
        const oldConnections = [];
        for (const node of nodes) {
          const connectionById = this.connections.find((c) => c.id === node.id);
          const connectionByUrl = this.connections.find((c) => c.id === node.url.href);
          if (connectionById != null) {
            debug(`The connection with id '${node.id}' is already present`);
            this.markAlive(connectionById);
            newConnections.push(connectionById);
          } else if (connectionByUrl != null) {
            connectionByUrl.id = node.id;
            this.markAlive(connectionByUrl);
            newConnections.push(connectionByUrl);
          } else {
            if (node instanceof connection_1.BaseConnection) {
              newConnections.push(node);
            } else {
              newConnections.push(this.createConnection(node));
            }
          }
        }
        const ids = nodes.map((c) => c.id);
        for (const connection of this.connections) {
          if (!ids.includes(connection.id)) {
            oldConnections.push(connection);
          }
        }
        for (const connection of oldConnections) {
          connection.close().catch(
            /* istanbul ignore next */
            () => {
            }
          );
        }
        this.connections = newConnections;
        this.size = this.connections.length;
        return this;
      }
      /**
       * Transforms the nodes objects to a host object.
       *
       * @param {object} nodes
       * @returns {array} hosts
       */
      nodesToHost(nodes, protocol) {
        const ids = Object.keys(nodes);
        const hosts = [];
        for (let i = 0, len = ids.length; i < len; i++) {
          const node = nodes[ids[i]];
          if (node.http === void 0)
            continue;
          let address = node.http.publish_address;
          const parts = address.split("/");
          if (parts.length > 1) {
            const hostname = parts[0];
            const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);
            address = `${hostname}:${port}`;
          }
          address = address.slice(0, 4) === "http" ? address : `${protocol}//${address}`;
          hosts.push({
            url: new node_url_1.URL(address),
            id: ids[i]
          });
        }
        return hosts;
      }
      /**
       * Transforms an url string to a host object
       *
       * @param {string} url
       * @returns {object} host
       */
      urlToHost(url) {
        return {
          url: new node_url_1.URL(url)
        };
      }
    };
    _a = symbols_1.kCaFingerprint;
    exports2.default = BaseConnectionPool;
  }
});

// node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js
var require_WeightedConnectionPool = __commonJS({
  "node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var connection_1 = require_connection2();
    var BaseConnectionPool_1 = tslib_1.__importStar(require_BaseConnectionPool());
    var WeightedConnectionPool = class extends BaseConnectionPool_1.default {
      constructor(opts) {
        super(opts);
        Object.defineProperty(this, "index", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "maxWeight", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "greatestCommonDivisor", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "currentWeight", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.index = -1;
        this.maxWeight = 0;
        this.greatestCommonDivisor = 0;
        this.currentWeight = 0;
      }
      /**
       * Returns a connection, even if the connection might be dead.
       *
       * @param {object} options (filter)
       * @returns {object|null} connection
       */
      getConnection(opts) {
        const filter = opts.filter != null ? opts.filter : BaseConnectionPool_1.defaultNodeFilter;
        let counter = 0;
        while (counter++ < this.size) {
          this.index = (this.index + 1) % this.size;
          if (this.index === 0) {
            this.currentWeight = this.currentWeight - this.greatestCommonDivisor;
            if (this.currentWeight <= 0) {
              this.currentWeight = this.maxWeight;
              if (this.currentWeight === 0) {
                return null;
              }
            }
          }
          const connection = this.connections[this.index];
          if (connection.weight >= this.currentWeight && filter(connection)) {
            return connection;
          }
        }
        return null;
      }
      /**
       * Set the weight of a connection to the maximum value.
       * If sniffing is not enabled and there is only
       * one node, this method is a noop.
       *
       * @param {object} connection
       */
      markAlive(connection) {
        if (this.size === 1 || connection.status === connection_1.BaseConnection.statuses.ALIVE)
          return this;
        connection.status = connection_1.BaseConnection.statuses.ALIVE;
        connection.deadCount = 0;
        connection.weight = Math.round(1e3 / this.size);
        this.maxWeight = Math.max(...this.connections.map((c) => c.weight));
        this.greatestCommonDivisor = this.connections.map((c) => c.weight).reduce(getGreatestCommonDivisor, 0);
        return this;
      }
      /**
       * Decreases the connection weight.
       * If sniffing is not enabled and there is only
       * one node, this method is a noop.
       *
       * @param {object} connection
       */
      markDead(connection) {
        if (this.size === 1)
          return this;
        connection.status = connection_1.BaseConnection.statuses.DEAD;
        connection.deadCount++;
        connection.weight -= Math.round(Math.pow(Math.log2(connection.weight), connection.deadCount));
        if (connection.weight <= 0)
          connection.weight = 1;
        this.maxWeight = Math.max(...this.connections.map((c) => c.weight));
        this.greatestCommonDivisor = this.connections.map((c) => c.weight).reduce(getGreatestCommonDivisor, 0);
        return this;
      }
      /**
       * Empties the connection pool.
       *
       * @returns {ConnectionPool}
       */
      async empty() {
        await super.empty();
        this.maxWeight = 0;
        this.greatestCommonDivisor = 0;
        this.index = -1;
        this.currentWeight = 0;
      }
      /**
       * Update the ConnectionPool with new connections.
       *
       * @param {array} array of connections
       * @returns {ConnectionPool}
       */
      update(connections) {
        super.update(connections);
        this.connections.forEach((connection) => {
          connection.weight = Math.round(1e3 / this.size);
        });
        this.maxWeight = Math.max(...this.connections.map((c) => c.weight));
        this.greatestCommonDivisor = this.connections.map((c) => c.weight).reduce(getGreatestCommonDivisor, 0);
        this.index = -1;
        this.currentWeight = 0;
        return this;
      }
    };
    exports2.default = WeightedConnectionPool;
    function getGreatestCommonDivisor(a, b) {
      if (b === 0)
        return a;
      return getGreatestCommonDivisor(b, a % b);
    }
  }
});

// node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js
var require_ClusterConnectionPool = __commonJS({
  "node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var BaseConnectionPool_1 = tslib_1.__importStar(require_BaseConnectionPool());
    var node_assert_1 = tslib_1.__importDefault(require("node:assert"));
    var debug_1 = tslib_1.__importDefault(require_src());
    var connection_1 = require_connection2();
    var debug = (0, debug_1.default)("elasticsearch");
    var ClusterConnectionPool = class _ClusterConnectionPool extends BaseConnectionPool_1.default {
      constructor(opts) {
        var _a, _b;
        super(opts);
        Object.defineProperty(this, "dead", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "resurrectTimeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "resurrectTimeoutCutoff", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "pingTimeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "resurrectStrategy", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.dead = [];
        this.resurrectTimeout = 1e3 * 60;
        this.resurrectTimeoutCutoff = 5;
        this.pingTimeout = (_a = opts.pingTimeout) !== null && _a !== void 0 ? _a : 3e3;
        const resurrectStrategy = (_b = opts.resurrectStrategy) !== null && _b !== void 0 ? _b : "ping";
        this.resurrectStrategy = _ClusterConnectionPool.resurrectStrategies[resurrectStrategy];
        (0, node_assert_1.default)(this.resurrectStrategy != null, `Invalid resurrection strategy: '${resurrectStrategy}'`);
      }
      /**
       * Marks a connection as 'alive'.
       * If needed removes the connection from the dead list
       * and then resets the `deadCount`.
       *
       * @param {object} connection
       */
      markAlive(connection) {
        const { id } = connection;
        debug(`Marking as 'alive' connection '${id}'`);
        const index = this.dead.indexOf(id);
        if (index > -1)
          this.dead.splice(index, 1);
        connection.status = connection_1.BaseConnection.statuses.ALIVE;
        connection.deadCount = 0;
        connection.resurrectTimeout = 0;
        return this;
      }
      /**
       * Marks a connection as 'dead'.
       * If needed adds the connection to the dead list
       * and then increments the `deadCount`.
       *
       * @param {object} connection
       */
      markDead(connection) {
        const { id } = connection;
        debug(`Marking as 'dead' connection '${id}'`);
        if (!this.dead.includes(id)) {
          for (let i = 0; i < this.size; i++) {
            if (this.connections[i].id === id) {
              this.dead.push(id);
              break;
            }
          }
        }
        connection.status = connection_1.BaseConnection.statuses.DEAD;
        connection.deadCount++;
        connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff));
        this.dead.sort((a, b) => {
          const conn1 = this.connections.find((c) => c.id === a);
          const conn2 = this.connections.find((c) => c.id === b);
          return conn1.resurrectTimeout - conn2.resurrectTimeout;
        });
        return this;
      }
      /**
       * If enabled, tries to resurrect a connection with the given
       * resurrect strategy ('ping', 'optimistic', 'none').
       *
       * @param {object} { now, requestId }
       */
      resurrect(opts) {
        if (this.resurrectStrategy === 0 || this.dead.length === 0) {
          debug("Nothing to resurrect");
          return;
        }
        const connection = this.connections.find((c) => c.id === this.dead[0]);
        if (opts.now < connection.resurrectTimeout) {
          debug("Nothing to resurrect");
          return;
        }
        const { id } = connection;
        if (this.resurrectStrategy === 1) {
          connection.request({ method: "HEAD", path: "/" }, { timeout: this.pingTimeout, requestId: opts.requestId, name: opts.name, context: opts.context }).then(({ statusCode }) => {
            let isAlive = true;
            if (statusCode === 502 || statusCode === 503 || statusCode === 504) {
              debug(`Resurrect: connection '${id}' is still dead`);
              this.markDead(connection);
              isAlive = false;
            } else {
              debug(`Resurrect: connection '${id}' is now alive`);
              this.markAlive(connection);
            }
            this.diagnostic.emit("resurrect", null, {
              strategy: "ping",
              name: opts.name,
              request: { id: opts.requestId },
              isAlive,
              connection
            });
          }).catch((err) => {
            this.markDead(connection);
            this.diagnostic.emit("resurrect", err, {
              strategy: "ping",
              name: opts.name,
              request: { id: opts.requestId },
              isAlive: false,
              connection
            });
          });
        } else {
          debug(`Resurrect: optimistic resurrection for connection '${id}'`);
          this.dead.splice(this.dead.indexOf(id), 1);
          connection.status = connection_1.BaseConnection.statuses.ALIVE;
          this.diagnostic.emit("resurrect", null, {
            strategy: "optimistic",
            name: opts.name,
            request: { id: opts.requestId },
            isAlive: true,
            connection
          });
        }
      }
      /**
       * Returns an alive connection if present,
       * otherwise returns a dead connection.
       * By default it filters the `master` only nodes.
       * It uses the selector to choose which
       * connection return.
       *
       * @param {object} options (filter and selector)
       * @returns {object|null} connection
       */
      getConnection(opts) {
        const filter = opts.filter != null ? opts.filter : BaseConnectionPool_1.defaultNodeFilter;
        const selector = opts.selector != null ? opts.selector : (c) => c[0];
        this.resurrect({
          now: opts.now,
          requestId: opts.requestId,
          name: opts.name,
          context: opts.context
        });
        const noAliveConnections = this.size === this.dead.length;
        const connections = [];
        for (let i = 0; i < this.size; i++) {
          const connection = this.connections[i];
          if (noAliveConnections || connection.status === connection_1.BaseConnection.statuses.ALIVE) {
            if (filter(connection)) {
              connections.push(connection);
            }
          }
        }
        if (connections.length === 0)
          return null;
        return selector(connections);
      }
      /**
       * Empties the connection pool.
       *
       * @returns {ConnectionPool}
       */
      async empty() {
        await super.empty();
        this.dead = [];
      }
      /**
       * Update the ConnectionPool with new connections.
       *
       * @param {array} array of connections
       * @returns {ConnectionPool}
       */
      update(connections) {
        super.update(connections);
        this.dead = [];
        return this;
      }
    };
    Object.defineProperty(ClusterConnectionPool, "resurrectStrategies", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        none: 0,
        ping: 1,
        optimistic: 2
      }
    });
    exports2.default = ClusterConnectionPool;
  }
});

// node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js
var require_CloudConnectionPool = __commonJS({
  "node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var BaseConnectionPool_1 = tslib_1.__importDefault(require_BaseConnectionPool());
    var CloudConnectionPool = class extends BaseConnectionPool_1.default {
      constructor(opts) {
        super(opts);
        Object.defineProperty(this, "cloudConnection", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.cloudConnection = null;
      }
      /**
       * Returns the only cloud connection.
       *
       * @returns {object} connection
       */
      getConnection(opts) {
        return this.cloudConnection;
      }
      /**
       * Empties the connection pool.
       *
       * @returns {ConnectionPool}
       */
      async empty() {
        await super.empty();
        this.cloudConnection = null;
      }
      /**
       * Update the ConnectionPool with new connections.
       *
       * @param {array} array of connections
       * @returns {ConnectionPool}
       */
      update(connections) {
        super.update(connections);
        this.cloudConnection = this.connections[0];
        return this;
      }
    };
    exports2.default = CloudConnectionPool;
  }
});

// node_modules/@elastic/transport/lib/pool/index.js
var require_pool2 = __commonJS({
  "node_modules/@elastic/transport/lib/pool/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CloudConnectionPool = exports2.ClusterConnectionPool = exports2.WeightedConnectionPool = exports2.BaseConnectionPool = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var BaseConnectionPool_1 = tslib_1.__importDefault(require_BaseConnectionPool());
    exports2.BaseConnectionPool = BaseConnectionPool_1.default;
    var WeightedConnectionPool_1 = tslib_1.__importDefault(require_WeightedConnectionPool());
    exports2.WeightedConnectionPool = WeightedConnectionPool_1.default;
    var ClusterConnectionPool_1 = tslib_1.__importDefault(require_ClusterConnectionPool());
    exports2.ClusterConnectionPool = ClusterConnectionPool_1.default;
    var CloudConnectionPool_1 = tslib_1.__importDefault(require_CloudConnectionPool());
    exports2.CloudConnectionPool = CloudConnectionPool_1.default;
  }
});

// node_modules/@elastic/transport/index.js
var require_transport = __commonJS({
  "node_modules/@elastic/transport/index.js"(exports2, module2) {
    "use strict";
    var { default: Diagnostic, events } = require_Diagnostic();
    var Transport = require_Transport().default;
    var {
      BaseConnection,
      HttpConnection,
      UndiciConnection
    } = require_connection2();
    var {
      BaseConnectionPool,
      ClusterConnectionPool,
      CloudConnectionPool,
      WeightedConnectionPool
    } = require_pool2();
    var Serializer = require_Serializer().default;
    var errors = require_errors();
    module2.exports = {
      Diagnostic,
      Transport,
      BaseConnection,
      HttpConnection,
      UndiciConnection,
      BaseConnectionPool,
      ClusterConnectionPool,
      CloudConnectionPool,
      WeightedConnectionPool,
      Serializer,
      errors,
      events
    };
  }
});

// node_modules/@elastic/elasticsearch/lib/sniffingTransport.js
var require_sniffingTransport = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/sniffingTransport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_assert_1 = tslib_1.__importDefault(require("node:assert"));
    var transport_1 = require_transport();
    var SniffingTransport = class extends transport_1.Transport {
      sniff(opts) {
        var _a;
        if (this.isSniffing)
          return;
        this.isSniffing = true;
        const request = {
          method: "GET",
          path: (_a = this.sniffEndpoint) !== null && _a !== void 0 ? _a : "/_nodes/_all/http"
        };
        this.request(request, { id: opts.requestId, meta: true }).then((result) => {
          var _a2, _b;
          (0, node_assert_1.default)(isObject(result.body), "The body should be an object");
          this.isSniffing = false;
          const protocol = (_b = (_a2 = result.meta.connection) === null || _a2 === void 0 ? void 0 : _a2.url.protocol) !== null && _b !== void 0 ? _b : "http:";
          const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol);
          this.connectionPool.update(hosts);
          result.meta.sniff = { hosts, reason: opts.reason };
          this.diagnostic.emit("sniff", null, result);
        }).catch((err) => {
          this.isSniffing = false;
          err.meta.sniff = { hosts: [], reason: opts.reason };
          this.diagnostic.emit("sniff", err, null);
        });
      }
    };
    exports2.default = SniffingTransport;
    function isObject(obj) {
      return typeof obj === "object";
    }
  }
});

// node_modules/apache-arrow/util/utf8.js
var require_utf8 = __commonJS({
  "node_modules/apache-arrow/util/utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeUtf8 = exports2.decodeUtf8 = void 0;
    var decoder = new TextDecoder("utf-8");
    var decodeUtf8 = (buffer) => decoder.decode(buffer);
    exports2.decodeUtf8 = decodeUtf8;
    var encoder = new TextEncoder();
    var encodeUtf8 = (value) => encoder.encode(value);
    exports2.encodeUtf8 = encodeUtf8;
  }
});

// node_modules/apache-arrow/util/compat.js
var require_compat = __commonJS({
  "node_modules/apache-arrow/util/compat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFlatbuffersByteBuffer = exports2.isReadableNodeStream = exports2.isWritableNodeStream = exports2.isReadableDOMStream = exports2.isWritableDOMStream = exports2.isFetchResponse = exports2.isFSReadStream = exports2.isFileHandle = exports2.isUnderlyingSink = exports2.isIteratorResult = exports2.isArrayLike = exports2.isArrowJSON = exports2.isAsyncIterable = exports2.isIterable = exports2.isObservable = exports2.isPromise = exports2.isObject = void 0;
    var isNumber = (x) => typeof x === "number";
    var isBoolean = (x) => typeof x === "boolean";
    var isFunction = (x) => typeof x === "function";
    var isObject = (x) => x != null && Object(x) === x;
    exports2.isObject = isObject;
    var isPromise = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x.then);
    };
    exports2.isPromise = isPromise;
    var isObservable = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x.subscribe);
    };
    exports2.isObservable = isObservable;
    var isIterable = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x[Symbol.iterator]);
    };
    exports2.isIterable = isIterable;
    var isAsyncIterable = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x[Symbol.asyncIterator]);
    };
    exports2.isAsyncIterable = isAsyncIterable;
    var isArrowJSON = (x) => {
      return (0, exports2.isObject)(x) && (0, exports2.isObject)(x["schema"]);
    };
    exports2.isArrowJSON = isArrowJSON;
    var isArrayLike = (x) => {
      return (0, exports2.isObject)(x) && isNumber(x["length"]);
    };
    exports2.isArrayLike = isArrayLike;
    var isIteratorResult = (x) => {
      return (0, exports2.isObject)(x) && "done" in x && "value" in x;
    };
    exports2.isIteratorResult = isIteratorResult;
    var isUnderlyingSink = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x["abort"]) && isFunction(x["close"]) && isFunction(x["start"]) && isFunction(x["write"]);
    };
    exports2.isUnderlyingSink = isUnderlyingSink;
    var isFileHandle = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
    };
    exports2.isFileHandle = isFileHandle;
    var isFSReadStream = (x) => {
      return (0, exports2.isReadableNodeStream)(x) && isNumber(x["bytesRead"]);
    };
    exports2.isFSReadStream = isFSReadStream;
    var isFetchResponse = (x) => {
      return (0, exports2.isObject)(x) && (0, exports2.isReadableDOMStream)(x["body"]);
    };
    exports2.isFetchResponse = isFetchResponse;
    var isReadableInterop = (x) => "_getDOMStream" in x && "_getNodeStream" in x;
    var isWritableDOMStream = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !isReadableInterop(x);
    };
    exports2.isWritableDOMStream = isWritableDOMStream;
    var isReadableDOMStream = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !isReadableInterop(x);
    };
    exports2.isReadableDOMStream = isReadableDOMStream;
    var isWritableNodeStream = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !isReadableInterop(x);
    };
    exports2.isWritableNodeStream = isWritableNodeStream;
    var isReadableNodeStream = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !isReadableInterop(x);
    };
    exports2.isReadableNodeStream = isReadableNodeStream;
    var isFlatbuffersByteBuffer = (x) => {
      return (0, exports2.isObject)(x) && isFunction(x["clear"]) && isFunction(x["bytes"]) && isFunction(x["position"]) && isFunction(x["setPosition"]) && isFunction(x["capacity"]) && isFunction(x["getBufferIdentifier"]) && isFunction(x["createLong"]);
    };
    exports2.isFlatbuffersByteBuffer = isFlatbuffersByteBuffer;
  }
});

// node_modules/apache-arrow/util/buffer.js
var require_buffer = __commonJS({
  "node_modules/apache-arrow/util/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compareArrayLike = exports2.rebaseValueOffsets = exports2.toUint8ClampedArrayAsyncIterator = exports2.toFloat64ArrayAsyncIterator = exports2.toFloat32ArrayAsyncIterator = exports2.toUint32ArrayAsyncIterator = exports2.toUint16ArrayAsyncIterator = exports2.toUint8ArrayAsyncIterator = exports2.toInt32ArrayAsyncIterator = exports2.toInt16ArrayAsyncIterator = exports2.toInt8ArrayAsyncIterator = exports2.toArrayBufferViewAsyncIterator = exports2.toUint8ClampedArrayIterator = exports2.toFloat64ArrayIterator = exports2.toFloat32ArrayIterator = exports2.toUint32ArrayIterator = exports2.toUint16ArrayIterator = exports2.toUint8ArrayIterator = exports2.toInt32ArrayIterator = exports2.toInt16ArrayIterator = exports2.toInt8ArrayIterator = exports2.toArrayBufferViewIterator = exports2.toUint8ClampedArray = exports2.toFloat64Array = exports2.toFloat32Array = exports2.toBigUint64Array = exports2.toUint32Array = exports2.toUint16Array = exports2.toUint8Array = exports2.toBigInt64Array = exports2.toInt32Array = exports2.toInt16Array = exports2.toInt8Array = exports2.toArrayBufferView = exports2.joinUint8Arrays = exports2.memcpy = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utf8_js_1 = require_utf8();
    var compat_js_1 = require_compat();
    var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
    function collapseContiguousByteRanges(chunks) {
      const result = chunks[0] ? [chunks[0]] : [];
      let xOffset, yOffset, xLen, yLen;
      for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n; ) {
        x = result[j];
        y = chunks[i];
        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
          y && (result[++j] = y);
          continue;
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
          y && (result[++j] = y);
          continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
      }
      return result;
    }
    function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
      const targetByteLength = target.byteLength;
      const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
      const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
      dst.set(src, targetByteOffset);
      return target;
    }
    exports2.memcpy = memcpy;
    function joinUint8Arrays(chunks, size) {
      const result = collapseContiguousByteRanges(chunks);
      const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
      let source, sliced, buffer;
      let offset = 0, index = -1;
      const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
      for (const n = result.length; ++index < n; ) {
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= offset + sliced.length) {
          if (sliced.length < source.length) {
            result[index] = source.subarray(sliced.length);
          } else if (sliced.length === source.length) {
            index++;
          }
          buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
          break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
      }
      return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
    }
    exports2.joinUint8Arrays = joinUint8Arrays;
    function toArrayBufferView(ArrayBufferViewCtor, input) {
      let value = (0, compat_js_1.isIteratorResult)(input) ? input.value : input;
      if (value instanceof ArrayBufferViewCtor) {
        if (ArrayBufferViewCtor === Uint8Array) {
          return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
        }
        return value;
      }
      if (!value) {
        return new ArrayBufferViewCtor(0);
      }
      if (typeof value === "string") {
        value = (0, utf8_js_1.encodeUtf8)(value);
      }
      if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
      }
      if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
      }
      if ((0, compat_js_1.isFlatbuffersByteBuffer)(value)) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
      }
      return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
    }
    exports2.toArrayBufferView = toArrayBufferView;
    var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
    exports2.toInt8Array = toInt8Array;
    var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
    exports2.toInt16Array = toInt16Array;
    var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
    exports2.toInt32Array = toInt32Array;
    var toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);
    exports2.toBigInt64Array = toBigInt64Array;
    var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
    exports2.toUint8Array = toUint8Array;
    var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
    exports2.toUint16Array = toUint16Array;
    var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
    exports2.toUint32Array = toUint32Array;
    var toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);
    exports2.toBigUint64Array = toBigUint64Array;
    var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
    exports2.toFloat32Array = toFloat32Array;
    var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
    exports2.toFloat64Array = toFloat64Array;
    var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
    exports2.toUint8ClampedArray = toUint8ClampedArray;
    var pump = (iterator) => {
      iterator.next();
      return iterator;
    };
    function* toArrayBufferViewIterator(ArrayCtor, source) {
      const wrap = function* (x) {
        yield x;
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !(0, compat_js_1.isIterable)(source) ? wrap(source) : source;
      yield* pump(function* (it) {
        let r = null;
        do {
          r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
      }(buffers[Symbol.iterator]()));
      return new ArrayCtor();
    }
    exports2.toArrayBufferViewIterator = toArrayBufferViewIterator;
    var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
    exports2.toInt8ArrayIterator = toInt8ArrayIterator;
    var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
    exports2.toInt16ArrayIterator = toInt16ArrayIterator;
    var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
    exports2.toInt32ArrayIterator = toInt32ArrayIterator;
    var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
    exports2.toUint8ArrayIterator = toUint8ArrayIterator;
    var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
    exports2.toUint16ArrayIterator = toUint16ArrayIterator;
    var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
    exports2.toUint32ArrayIterator = toUint32ArrayIterator;
    var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
    exports2.toFloat32ArrayIterator = toFloat32ArrayIterator;
    var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
    exports2.toFloat64ArrayIterator = toFloat64ArrayIterator;
    var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
    exports2.toUint8ClampedArrayIterator = toUint8ClampedArrayIterator;
    function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
      return tslib_1.__asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
        if ((0, compat_js_1.isPromise)(source)) {
          return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield tslib_1.__await(source))))));
        }
        const wrap = function(x) {
          return tslib_1.__asyncGenerator(this, arguments, function* () {
            yield yield tslib_1.__await(yield tslib_1.__await(x));
          });
        };
        const emit = function(source2) {
          return tslib_1.__asyncGenerator(this, arguments, function* () {
            yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump(function* (it) {
              let r = null;
              do {
                r = it.next(yield r === null || r === void 0 ? void 0 : r.value);
              } while (!r.done);
            }(source2[Symbol.iterator]())))));
          });
        };
        const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : (0, compat_js_1.isIterable)(source) ? emit(source) : !(0, compat_js_1.isAsyncIterable)(source) ? wrap(source) : source;
        yield tslib_1.__await(
          // otherwise if AsyncIterable, use it
          yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump(function(it) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
              let r = null;
              do {
                r = yield tslib_1.__await(it.next(yield yield tslib_1.__await(toArrayBufferView(ArrayCtor, r))));
              } while (!r.done);
            });
          }(buffers[Symbol.asyncIterator]()))))
        );
        return yield tslib_1.__await(new ArrayCtor());
      });
    }
    exports2.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
    var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
    exports2.toInt8ArrayAsyncIterator = toInt8ArrayAsyncIterator;
    var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
    exports2.toInt16ArrayAsyncIterator = toInt16ArrayAsyncIterator;
    var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
    exports2.toInt32ArrayAsyncIterator = toInt32ArrayAsyncIterator;
    var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
    exports2.toUint8ArrayAsyncIterator = toUint8ArrayAsyncIterator;
    var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
    exports2.toUint16ArrayAsyncIterator = toUint16ArrayAsyncIterator;
    var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
    exports2.toUint32ArrayAsyncIterator = toUint32ArrayAsyncIterator;
    var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
    exports2.toFloat32ArrayAsyncIterator = toFloat32ArrayAsyncIterator;
    var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
    exports2.toFloat64ArrayAsyncIterator = toFloat64ArrayAsyncIterator;
    var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
    exports2.toUint8ClampedArrayAsyncIterator = toUint8ClampedArrayAsyncIterator;
    function rebaseValueOffsets(offset, length, valueOffsets) {
      if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length);
        for (let i = -1, n = valueOffsets.length; ++i < n; ) {
          valueOffsets[i] += offset;
        }
      }
      return valueOffsets.subarray(0, length);
    }
    exports2.rebaseValueOffsets = rebaseValueOffsets;
    function compareArrayLike(a, b) {
      let i = 0;
      const n = a.length;
      if (n !== b.length) {
        return false;
      }
      if (n > 0) {
        do {
          if (a[i] !== b[i]) {
            return false;
          }
        } while (++i < n);
      }
      return true;
    }
    exports2.compareArrayLike = compareArrayLike;
  }
});

// node_modules/apache-arrow/io/adapters.js
var require_adapters = __commonJS({
  "node_modules/apache-arrow/io/adapters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var buffer_js_1 = require_buffer();
    exports2.default = {
      fromIterable(source) {
        return pump(fromIterable(source));
      },
      fromAsyncIterable(source) {
        return pump(fromAsyncIterable(source));
      },
      fromDOMStream(source) {
        return pump(fromDOMStream(source));
      },
      fromNodeStream(stream) {
        return pump(fromNodeStream(stream));
      },
      // @ts-ignore
      toDOMStream(source, options) {
        throw new Error(`"toDOMStream" not available in this environment`);
      },
      // @ts-ignore
      toNodeStream(source, options) {
        throw new Error(`"toNodeStream" not available in this environment`);
      }
    };
    var pump = (iterator) => {
      iterator.next();
      return iterator;
    };
    function* fromIterable(source) {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
        return buffer;
      }
      ({ cmd, size } = (yield /* @__PURE__ */ (() => null)()) || { cmd: "read", size: 0 });
      const it = (0, buffer_js_1.toUint8ArrayIterator)(source)[Symbol.iterator]();
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it.throw === "function" && it.throw(e);
      } finally {
        threw === false && typeof it.return === "function" && it.return(null);
      }
      return null;
    }
    function fromAsyncIterable(source) {
      return tslib_1.__asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
        let done, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
          if (cmd === "peek") {
            return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
          }
          [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
          return buffer;
        }
        ({ cmd, size } = (yield yield tslib_1.__await(/* @__PURE__ */ (() => null)())) || { cmd: "read", size: 0 });
        const it = (0, buffer_js_1.toUint8ArrayAsyncIterator)(source)[Symbol.asyncIterator]();
        try {
          do {
            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield tslib_1.__await(it.next()) : yield tslib_1.__await(it.next(size - bufferLength)));
            if (!done && buffer.byteLength > 0) {
              buffers.push(buffer);
              bufferLength += buffer.byteLength;
            }
            if (done || size <= bufferLength) {
              do {
                ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
              } while (size < bufferLength);
            }
          } while (!done);
        } catch (e) {
          (threw = true) && typeof it.throw === "function" && (yield tslib_1.__await(it.throw(e)));
        } finally {
          threw === false && typeof it.return === "function" && (yield tslib_1.__await(it.return(new Uint8Array(0))));
        }
        return yield tslib_1.__await(null);
      });
    }
    function fromDOMStream(source) {
      return tslib_1.__asyncGenerator(this, arguments, function* fromDOMStream_1() {
        let done = false, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
          if (cmd === "peek") {
            return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
          }
          [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
          return buffer;
        }
        ({ cmd, size } = (yield yield tslib_1.__await(/* @__PURE__ */ (() => null)())) || { cmd: "read", size: 0 });
        const it = new AdaptiveByteReader(source);
        try {
          do {
            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield tslib_1.__await(it["read"]()) : yield tslib_1.__await(it["read"](size - bufferLength)));
            if (!done && buffer.byteLength > 0) {
              buffers.push((0, buffer_js_1.toUint8Array)(buffer));
              bufferLength += buffer.byteLength;
            }
            if (done || size <= bufferLength) {
              do {
                ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
              } while (size < bufferLength);
            }
          } while (!done);
        } catch (e) {
          (threw = true) && (yield tslib_1.__await(it["cancel"](e)));
        } finally {
          threw === false ? yield tslib_1.__await(it["cancel"]()) : source["locked"] && it.releaseLock();
        }
        return yield tslib_1.__await(null);
      });
    }
    var AdaptiveByteReader = class {
      constructor(source) {
        this.source = source;
        this.reader = null;
        this.reader = this.source["getReader"]();
        this.reader["closed"].catch(() => {
        });
      }
      get closed() {
        return this.reader ? this.reader["closed"].catch(() => {
        }) : Promise.resolve();
      }
      releaseLock() {
        if (this.reader) {
          this.reader.releaseLock();
        }
        this.reader = null;
      }
      cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { reader, source } = this;
          reader && (yield reader["cancel"](reason).catch(() => {
          }));
          source && (source["locked"] && this.releaseLock());
        });
      }
      read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (size === 0) {
            return { done: this.reader == null, value: new Uint8Array(0) };
          }
          const result = yield this.reader.read();
          !result.done && (result.value = (0, buffer_js_1.toUint8Array)(result));
          return result;
        });
      }
    };
    var onEvent = (stream, event) => {
      const handler = (_) => resolve([event, _]);
      let resolve;
      return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
    };
    function fromNodeStream(stream) {
      return tslib_1.__asyncGenerator(this, arguments, function* fromNodeStream_1() {
        const events = [];
        let event = "error";
        let done = false, err = null;
        let cmd, size, bufferLength = 0;
        let buffers = [], buffer;
        function byteRange() {
          if (cmd === "peek") {
            return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
          }
          [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
          return buffer;
        }
        ({ cmd, size } = (yield yield tslib_1.__await(/* @__PURE__ */ (() => null)())) || { cmd: "read", size: 0 });
        if (stream["isTTY"]) {
          yield yield tslib_1.__await(new Uint8Array(0));
          return yield tslib_1.__await(null);
        }
        try {
          events[0] = onEvent(stream, "end");
          events[1] = onEvent(stream, "error");
          do {
            events[2] = onEvent(stream, "readable");
            [event, err] = yield tslib_1.__await(Promise.race(events.map((x) => x[2])));
            if (event === "error") {
              break;
            }
            if (!(done = event === "end")) {
              if (!Number.isFinite(size - bufferLength)) {
                buffer = (0, buffer_js_1.toUint8Array)(stream["read"]());
              } else {
                buffer = (0, buffer_js_1.toUint8Array)(stream["read"](size - bufferLength));
                if (buffer.byteLength < size - bufferLength) {
                  buffer = (0, buffer_js_1.toUint8Array)(stream["read"]());
                }
              }
              if (buffer.byteLength > 0) {
                buffers.push(buffer);
                bufferLength += buffer.byteLength;
              }
            }
            if (done || size <= bufferLength) {
              do {
                ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
              } while (size < bufferLength);
            }
          } while (!done);
        } finally {
          yield tslib_1.__await(cleanup(events, event === "error" ? err : null));
        }
        return yield tslib_1.__await(null);
        function cleanup(events2, err2) {
          buffer = buffers = null;
          return new Promise((resolve, reject) => {
            for (const [evt, fn] of events2) {
              stream["off"](evt, fn);
            }
            try {
              const destroy = stream["destroy"];
              destroy && destroy.call(stream, err2);
              err2 = void 0;
            } catch (e) {
              err2 = e || err2;
            } finally {
              err2 != null ? reject(err2) : resolve();
            }
          });
        }
      });
    }
  }
});

// node_modules/apache-arrow/fb/metadata-version.js
var require_metadata_version = __commonJS({
  "node_modules/apache-arrow/fb/metadata-version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataVersion = void 0;
    var MetadataVersion;
    (function(MetadataVersion2) {
      MetadataVersion2[MetadataVersion2["V1"] = 0] = "V1";
      MetadataVersion2[MetadataVersion2["V2"] = 1] = "V2";
      MetadataVersion2[MetadataVersion2["V3"] = 2] = "V3";
      MetadataVersion2[MetadataVersion2["V4"] = 3] = "V4";
      MetadataVersion2[MetadataVersion2["V5"] = 4] = "V5";
    })(MetadataVersion || (exports2.MetadataVersion = MetadataVersion = {}));
  }
});

// node_modules/apache-arrow/fb/union-mode.js
var require_union_mode = __commonJS({
  "node_modules/apache-arrow/fb/union-mode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnionMode = void 0;
    var UnionMode;
    (function(UnionMode2) {
      UnionMode2[UnionMode2["Sparse"] = 0] = "Sparse";
      UnionMode2[UnionMode2["Dense"] = 1] = "Dense";
    })(UnionMode || (exports2.UnionMode = UnionMode = {}));
  }
});

// node_modules/apache-arrow/fb/precision.js
var require_precision = __commonJS({
  "node_modules/apache-arrow/fb/precision.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Precision = void 0;
    var Precision;
    (function(Precision2) {
      Precision2[Precision2["HALF"] = 0] = "HALF";
      Precision2[Precision2["SINGLE"] = 1] = "SINGLE";
      Precision2[Precision2["DOUBLE"] = 2] = "DOUBLE";
    })(Precision || (exports2.Precision = Precision = {}));
  }
});

// node_modules/apache-arrow/fb/date-unit.js
var require_date_unit = __commonJS({
  "node_modules/apache-arrow/fb/date-unit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DateUnit = void 0;
    var DateUnit;
    (function(DateUnit2) {
      DateUnit2[DateUnit2["DAY"] = 0] = "DAY";
      DateUnit2[DateUnit2["MILLISECOND"] = 1] = "MILLISECOND";
    })(DateUnit || (exports2.DateUnit = DateUnit = {}));
  }
});

// node_modules/apache-arrow/fb/time-unit.js
var require_time_unit = __commonJS({
  "node_modules/apache-arrow/fb/time-unit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeUnit = void 0;
    var TimeUnit;
    (function(TimeUnit2) {
      TimeUnit2[TimeUnit2["SECOND"] = 0] = "SECOND";
      TimeUnit2[TimeUnit2["MILLISECOND"] = 1] = "MILLISECOND";
      TimeUnit2[TimeUnit2["MICROSECOND"] = 2] = "MICROSECOND";
      TimeUnit2[TimeUnit2["NANOSECOND"] = 3] = "NANOSECOND";
    })(TimeUnit || (exports2.TimeUnit = TimeUnit = {}));
  }
});

// node_modules/apache-arrow/fb/interval-unit.js
var require_interval_unit = __commonJS({
  "node_modules/apache-arrow/fb/interval-unit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntervalUnit = void 0;
    var IntervalUnit;
    (function(IntervalUnit2) {
      IntervalUnit2[IntervalUnit2["YEAR_MONTH"] = 0] = "YEAR_MONTH";
      IntervalUnit2[IntervalUnit2["DAY_TIME"] = 1] = "DAY_TIME";
      IntervalUnit2[IntervalUnit2["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
    })(IntervalUnit || (exports2.IntervalUnit = IntervalUnit = {}));
  }
});

// node_modules/flatbuffers/js/constants.js
var require_constants6 = __commonJS({
  "node_modules/flatbuffers/js/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SIZE_PREFIX_LENGTH = exports2.FILE_IDENTIFIER_LENGTH = exports2.SIZEOF_INT = exports2.SIZEOF_SHORT = void 0;
    exports2.SIZEOF_SHORT = 2;
    exports2.SIZEOF_INT = 4;
    exports2.FILE_IDENTIFIER_LENGTH = 4;
    exports2.SIZE_PREFIX_LENGTH = 4;
  }
});

// node_modules/flatbuffers/js/utils.js
var require_utils2 = __commonJS({
  "node_modules/flatbuffers/js/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isLittleEndian = exports2.float64 = exports2.float32 = exports2.int32 = void 0;
    exports2.int32 = new Int32Array(2);
    exports2.float32 = new Float32Array(exports2.int32.buffer);
    exports2.float64 = new Float64Array(exports2.int32.buffer);
    exports2.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
  }
});

// node_modules/flatbuffers/js/encoding.js
var require_encoding = __commonJS({
  "node_modules/flatbuffers/js/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Encoding = void 0;
    var Encoding;
    (function(Encoding2) {
      Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
      Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
    })(Encoding || (exports2.Encoding = Encoding = {}));
  }
});

// node_modules/flatbuffers/js/byte-buffer.js
var require_byte_buffer = __commonJS({
  "node_modules/flatbuffers/js/byte-buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ByteBuffer = void 0;
    var constants_js_1 = require_constants6();
    var utils_js_1 = require_utils2();
    var encoding_js_1 = require_encoding();
    var ByteBuffer = class _ByteBuffer {
      /**
       * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
       */
      constructor(bytes_) {
        this.bytes_ = bytes_;
        this.position_ = 0;
        this.text_decoder_ = new TextDecoder();
      }
      /**
       * Create and allocate a new ByteBuffer with a given size.
       */
      static allocate(byte_size) {
        return new _ByteBuffer(new Uint8Array(byte_size));
      }
      clear() {
        this.position_ = 0;
      }
      /**
       * Get the underlying `Uint8Array`.
       */
      bytes() {
        return this.bytes_;
      }
      /**
       * Get the buffer's position.
       */
      position() {
        return this.position_;
      }
      /**
       * Set the buffer's position.
       */
      setPosition(position) {
        this.position_ = position;
      }
      /**
       * Get the buffer's capacity.
       */
      capacity() {
        return this.bytes_.length;
      }
      readInt8(offset) {
        return this.readUint8(offset) << 24 >> 24;
      }
      readUint8(offset) {
        return this.bytes_[offset];
      }
      readInt16(offset) {
        return this.readUint16(offset) << 16 >> 16;
      }
      readUint16(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
      }
      readInt32(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
      }
      readUint32(offset) {
        return this.readInt32(offset) >>> 0;
      }
      readInt64(offset) {
        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
      }
      readUint64(offset) {
        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
      }
      readFloat32(offset) {
        utils_js_1.int32[0] = this.readInt32(offset);
        return utils_js_1.float32[0];
      }
      readFloat64(offset) {
        utils_js_1.int32[utils_js_1.isLittleEndian ? 0 : 1] = this.readInt32(offset);
        utils_js_1.int32[utils_js_1.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return utils_js_1.float64[0];
      }
      writeInt8(offset, value) {
        this.bytes_[offset] = value;
      }
      writeUint8(offset, value) {
        this.bytes_[offset] = value;
      }
      writeInt16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
      }
      writeUint16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
      }
      writeInt32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
      }
      writeUint32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
      }
      writeInt64(offset, value) {
        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
      }
      writeUint64(offset, value) {
        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
      }
      writeFloat32(offset, value) {
        utils_js_1.float32[0] = value;
        this.writeInt32(offset, utils_js_1.int32[0]);
      }
      writeFloat64(offset, value) {
        utils_js_1.float64[0] = value;
        this.writeInt32(offset, utils_js_1.int32[utils_js_1.isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, utils_js_1.int32[utils_js_1.isLittleEndian ? 1 : 0]);
      }
      /**
       * Return the file identifier.   Behavior is undefined for FlatBuffers whose
       * schema does not include a file_identifier (likely points at padding or the
       * start of a the root vtable).
       */
      getBufferIdentifier() {
        if (this.bytes_.length < this.position_ + constants_js_1.SIZEOF_INT + constants_js_1.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
        }
        let result = "";
        for (let i = 0; i < constants_js_1.FILE_IDENTIFIER_LENGTH; i++) {
          result += String.fromCharCode(this.readInt8(this.position_ + constants_js_1.SIZEOF_INT + i));
        }
        return result;
      }
      /**
       * Look up a field in the vtable, return an offset into the object, or 0 if the
       * field is not present.
       */
      __offset(bb_pos, vtable_offset) {
        const vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
      }
      /**
       * Initialize any Table-derived type to point to the union at the given offset.
       */
      __union(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
      }
      /**
       * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
       * This allocates a new string and converts to wide chars upon each access.
       *
       * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
       * "optionalEncoding" argument. This is useful for avoiding conversion when
       * the data will just be packaged back up in another FlatBuffer later on.
       *
       * @param offset
       * @param opt_encoding Defaults to UTF16_STRING
       */
      __string(offset, opt_encoding) {
        offset += this.readInt32(offset);
        const length = this.readInt32(offset);
        offset += constants_js_1.SIZEOF_INT;
        const utf8bytes = this.bytes_.subarray(offset, offset + length);
        if (opt_encoding === encoding_js_1.Encoding.UTF8_BYTES)
          return utf8bytes;
        else
          return this.text_decoder_.decode(utf8bytes);
      }
      /**
       * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
       * if a string then return a new one
       *
       * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
       * makes the behaviour of __union_with_string different compared to __union
       */
      __union_with_string(o, offset) {
        if (typeof o === "string") {
          return this.__string(offset);
        }
        return this.__union(o, offset);
      }
      /**
       * Retrieve the relative offset stored at "offset"
       */
      __indirect(offset) {
        return offset + this.readInt32(offset);
      }
      /**
       * Get the start of data of a vector whose offset is stored at "offset" in this object.
       */
      __vector(offset) {
        return offset + this.readInt32(offset) + constants_js_1.SIZEOF_INT;
      }
      /**
       * Get the length of a vector whose offset is stored at "offset" in this object.
       */
      __vector_len(offset) {
        return this.readInt32(offset + this.readInt32(offset));
      }
      __has_identifier(ident) {
        if (ident.length != constants_js_1.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + constants_js_1.FILE_IDENTIFIER_LENGTH);
        }
        for (let i = 0; i < constants_js_1.FILE_IDENTIFIER_LENGTH; i++) {
          if (ident.charCodeAt(i) != this.readInt8(this.position() + constants_js_1.SIZEOF_INT + i)) {
            return false;
          }
        }
        return true;
      }
      /**
       * A helper function for generating list for obj api
       */
      createScalarList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
          const val = listAccessor(i);
          if (val !== null) {
            ret.push(val);
          }
        }
        return ret;
      }
      /**
       * A helper function for generating list for obj api
       * @param listAccessor function that accepts an index and return data at that index
       * @param listLength listLength
       * @param res result list
       */
      createObjList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
          const val = listAccessor(i);
          if (val !== null) {
            ret.push(val.unpack());
          }
        }
        return ret;
      }
    };
    exports2.ByteBuffer = ByteBuffer;
  }
});

// node_modules/flatbuffers/js/builder.js
var require_builder = __commonJS({
  "node_modules/flatbuffers/js/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Builder = void 0;
    var byte_buffer_js_1 = require_byte_buffer();
    var constants_js_1 = require_constants6();
    var Builder = class _Builder {
      /**
       * Create a FlatBufferBuilder.
       */
      constructor(opt_initial_size) {
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
        this.text_encoder = new TextEncoder();
        let initial_size;
        if (!opt_initial_size) {
          initial_size = 1024;
        } else {
          initial_size = opt_initial_size;
        }
        this.bb = byte_buffer_js_1.ByteBuffer.allocate(initial_size);
        this.space = initial_size;
      }
      clear() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
      }
      /**
       * In order to save space, fields that are set to their default value
       * don't get serialized into the buffer. Forcing defaults provides a
       * way to manually disable this optimization.
       *
       * @param forceDefaults true always serializes default values
       */
      forceDefaults(forceDefaults) {
        this.force_defaults = forceDefaults;
      }
      /**
       * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
       * called finish(). The actual data starts at the ByteBuffer's current position,
       * not necessarily at 0.
       */
      dataBuffer() {
        return this.bb;
      }
      /**
       * Get the bytes representing the FlatBuffer. Only call this after you've
       * called finish().
       */
      asUint8Array() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
      }
      /**
       * Prepare to write an element of `size` after `additional_bytes` have been
       * written, e.g. if you write a string, you need to align such the int length
       * field is aligned to 4 bytes, and the string data follows it directly. If all
       * you need to do is alignment, `additional_bytes` will be 0.
       *
       * @param size This is the of the new element to write
       * @param additional_bytes The padding size
       */
      prep(size, additional_bytes) {
        if (size > this.minalign) {
          this.minalign = size;
        }
        const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
        while (this.space < align_size + size + additional_bytes) {
          const old_buf_size = this.bb.capacity();
          this.bb = _Builder.growByteBuffer(this.bb);
          this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
      }
      pad(byte_size) {
        for (let i = 0; i < byte_size; i++) {
          this.bb.writeInt8(--this.space, 0);
        }
      }
      writeInt8(value) {
        this.bb.writeInt8(this.space -= 1, value);
      }
      writeInt16(value) {
        this.bb.writeInt16(this.space -= 2, value);
      }
      writeInt32(value) {
        this.bb.writeInt32(this.space -= 4, value);
      }
      writeInt64(value) {
        this.bb.writeInt64(this.space -= 8, value);
      }
      writeFloat32(value) {
        this.bb.writeFloat32(this.space -= 4, value);
      }
      writeFloat64(value) {
        this.bb.writeFloat64(this.space -= 8, value);
      }
      /**
       * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
       * @param value The `int8` to add the buffer.
       */
      addInt8(value) {
        this.prep(1, 0);
        this.writeInt8(value);
      }
      /**
       * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
       * @param value The `int16` to add the buffer.
       */
      addInt16(value) {
        this.prep(2, 0);
        this.writeInt16(value);
      }
      /**
       * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
       * @param value The `int32` to add the buffer.
       */
      addInt32(value) {
        this.prep(4, 0);
        this.writeInt32(value);
      }
      /**
       * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
       * @param value The `int64` to add the buffer.
       */
      addInt64(value) {
        this.prep(8, 0);
        this.writeInt64(value);
      }
      /**
       * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
       * @param value The `float32` to add the buffer.
       */
      addFloat32(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
      }
      /**
       * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
       * @param value The `float64` to add the buffer.
       */
      addFloat64(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
      }
      addFieldInt8(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt8(value);
          this.slot(voffset);
        }
      }
      addFieldInt16(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt16(value);
          this.slot(voffset);
        }
      }
      addFieldInt32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addInt32(value);
          this.slot(voffset);
        }
      }
      addFieldInt64(voffset, value, defaultValue) {
        if (this.force_defaults || value !== defaultValue) {
          this.addInt64(value);
          this.slot(voffset);
        }
      }
      addFieldFloat32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addFloat32(value);
          this.slot(voffset);
        }
      }
      addFieldFloat64(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addFloat64(value);
          this.slot(voffset);
        }
      }
      addFieldOffset(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
          this.addOffset(value);
          this.slot(voffset);
        }
      }
      /**
       * Structs are stored inline, so nothing additional is being added. `d` is always 0.
       */
      addFieldStruct(voffset, value, defaultValue) {
        if (value != defaultValue) {
          this.nested(value);
          this.slot(voffset);
        }
      }
      /**
       * Structures are always stored inline, they need to be created right
       * where they're used.  You'll get this assertion failure if you
       * created it elsewhere.
       */
      nested(obj) {
        if (obj != this.offset()) {
          throw new TypeError("FlatBuffers: struct must be serialized inline.");
        }
      }
      /**
       * Should not be creating any other object, string or vector
       * while an object is being constructed
       */
      notNested() {
        if (this.isNested) {
          throw new TypeError("FlatBuffers: object serialization must not be nested.");
        }
      }
      /**
       * Set the current vtable at `voffset` to the current location in the buffer.
       */
      slot(voffset) {
        if (this.vtable !== null)
          this.vtable[voffset] = this.offset();
      }
      /**
       * @returns Offset relative to the end of the buffer.
       */
      offset() {
        return this.bb.capacity() - this.space;
      }
      /**
       * Doubles the size of the backing ByteBuffer and copies the old data towards
       * the end of the new buffer (since we build the buffer backwards).
       *
       * @param bb The current buffer with the existing data
       * @returns A new byte buffer with the old data copied
       * to it. The data is located at the end of the buffer.
       *
       * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
       * it a uint8Array we need to suppress the type check:
       * @suppress {checkTypes}
       */
      static growByteBuffer(bb) {
        const old_buf_size = bb.capacity();
        if (old_buf_size & 3221225472) {
          throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
        }
        const new_buf_size = old_buf_size << 1;
        const nbb = byte_buffer_js_1.ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
      }
      /**
       * Adds on offset, relative to where it will be written.
       *
       * @param offset The offset to add.
       */
      addOffset(offset) {
        this.prep(constants_js_1.SIZEOF_INT, 0);
        this.writeInt32(this.offset() - offset + constants_js_1.SIZEOF_INT);
      }
      /**
       * Start encoding a new object in the buffer.  Users will not usually need to
       * call this directly. The FlatBuffers compiler will generate helper methods
       * that call this method internally.
       */
      startObject(numfields) {
        this.notNested();
        if (this.vtable == null) {
          this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (let i = 0; i < numfields; i++) {
          this.vtable[i] = 0;
        }
        this.isNested = true;
        this.object_start = this.offset();
      }
      /**
       * Finish off writing the object that is under construction.
       *
       * @returns The offset to the object inside `dataBuffer`
       */
      endObject() {
        if (this.vtable == null || !this.isNested) {
          throw new Error("FlatBuffers: endObject called without startObject");
        }
        this.addInt32(0);
        const vtableloc = this.offset();
        let i = this.vtable_in_use - 1;
        for (; i >= 0 && this.vtable[i] == 0; i--) {
        }
        const trimmed_size = i + 1;
        for (; i >= 0; i--) {
          this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        const standard_fields = 2;
        this.addInt16(vtableloc - this.object_start);
        const len = (trimmed_size + standard_fields) * constants_js_1.SIZEOF_SHORT;
        this.addInt16(len);
        let existing_vtable = 0;
        const vt1 = this.space;
        outer_loop: for (i = 0; i < this.vtables.length; i++) {
          const vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (let j = constants_js_1.SIZEOF_SHORT; j < len; j += constants_js_1.SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
        if (existing_vtable) {
          this.space = this.bb.capacity() - vtableloc;
          this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        } else {
          this.vtables.push(this.offset());
          this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
      }
      /**
       * Finalize a buffer, poiting to the given `root_table`.
       */
      finish(root_table, opt_file_identifier, opt_size_prefix) {
        const size_prefix = opt_size_prefix ? constants_js_1.SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
          const file_identifier = opt_file_identifier;
          this.prep(this.minalign, constants_js_1.SIZEOF_INT + constants_js_1.FILE_IDENTIFIER_LENGTH + size_prefix);
          if (file_identifier.length != constants_js_1.FILE_IDENTIFIER_LENGTH) {
            throw new TypeError("FlatBuffers: file identifier must be length " + constants_js_1.FILE_IDENTIFIER_LENGTH);
          }
          for (let i = constants_js_1.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
            this.writeInt8(file_identifier.charCodeAt(i));
          }
        }
        this.prep(this.minalign, constants_js_1.SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
          this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
      }
      /**
       * Finalize a size prefixed buffer, pointing to the given `root_table`.
       */
      finishSizePrefixed(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
      }
      /**
       * This checks a required field has been set in a given table that has
       * just been constructed.
       */
      requiredField(table, field) {
        const table_start = this.bb.capacity() - table;
        const vtable_start = table_start - this.bb.readInt32(table_start);
        const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
        if (!ok) {
          throw new TypeError("FlatBuffers: field " + field + " must be set");
        }
      }
      /**
       * Start a new array/vector of objects.  Users usually will not call
       * this directly. The FlatBuffers compiler will create a start/end
       * method for vector types in generated code.
       *
       * @param elem_size The size of each element in the array
       * @param num_elems The number of elements in the array
       * @param alignment The alignment of the array
       */
      startVector(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(constants_js_1.SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems);
      }
      /**
       * Finish off the creation of an array and all its elements. The array must be
       * created with `startVector`.
       *
       * @returns The offset at which the newly created array
       * starts.
       */
      endVector() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
      }
      /**
       * Encode the string `s` in the buffer using UTF-8. If the string passed has
       * already been seen, we return the offset of the already written string
       *
       * @param s The string to encode
       * @return The offset in the buffer where the encoded string starts
       */
      createSharedString(s) {
        if (!s) {
          return 0;
        }
        if (!this.string_maps) {
          this.string_maps = /* @__PURE__ */ new Map();
        }
        if (this.string_maps.has(s)) {
          return this.string_maps.get(s);
        }
        const offset = this.createString(s);
        this.string_maps.set(s, offset);
        return offset;
      }
      /**
       * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
       * instead of a string, it is assumed to contain valid UTF-8 encoded data.
       *
       * @param s The string to encode
       * @return The offset in the buffer where the encoded string starts
       */
      createString(s) {
        if (s === null || s === void 0) {
          return 0;
        }
        let utf8;
        if (s instanceof Uint8Array) {
          utf8 = s;
        } else {
          utf8 = this.text_encoder.encode(s);
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        this.bb.bytes().set(utf8, this.space);
        return this.endVector();
      }
      /**
       * Create a byte vector.
       *
       * @param v The bytes to add
       * @returns The offset in the buffer where the byte vector starts
       */
      createByteVector(v) {
        if (v === null || v === void 0) {
          return 0;
        }
        this.startVector(1, v.length, 1);
        this.bb.setPosition(this.space -= v.length);
        this.bb.bytes().set(v, this.space);
        return this.endVector();
      }
      /**
       * A helper function to pack an object
       *
       * @returns offset of obj
       */
      createObjectOffset(obj) {
        if (obj === null) {
          return 0;
        }
        if (typeof obj === "string") {
          return this.createString(obj);
        } else {
          return obj.pack(this);
        }
      }
      /**
       * A helper function to pack a list of object
       *
       * @returns list of offsets of each non null object
       */
      createObjectOffsetList(list) {
        const ret = [];
        for (let i = 0; i < list.length; ++i) {
          const val = list[i];
          if (val !== null) {
            ret.push(this.createObjectOffset(val));
          } else {
            throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
          }
        }
        return ret;
      }
      createStructOffsetList(list, startFunc) {
        startFunc(this, list.length);
        this.createObjectOffsetList(list.slice().reverse());
        return this.endVector();
      }
    };
    exports2.Builder = Builder;
  }
});

// node_modules/flatbuffers/js/flatbuffers.js
var require_flatbuffers = __commonJS({
  "node_modules/flatbuffers/js/flatbuffers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ByteBuffer = exports2.Builder = exports2.Encoding = exports2.isLittleEndian = exports2.float64 = exports2.float32 = exports2.int32 = exports2.SIZE_PREFIX_LENGTH = exports2.FILE_IDENTIFIER_LENGTH = exports2.SIZEOF_INT = exports2.SIZEOF_SHORT = void 0;
    var constants_js_1 = require_constants6();
    Object.defineProperty(exports2, "SIZEOF_SHORT", { enumerable: true, get: function() {
      return constants_js_1.SIZEOF_SHORT;
    } });
    var constants_js_2 = require_constants6();
    Object.defineProperty(exports2, "SIZEOF_INT", { enumerable: true, get: function() {
      return constants_js_2.SIZEOF_INT;
    } });
    var constants_js_3 = require_constants6();
    Object.defineProperty(exports2, "FILE_IDENTIFIER_LENGTH", { enumerable: true, get: function() {
      return constants_js_3.FILE_IDENTIFIER_LENGTH;
    } });
    var constants_js_4 = require_constants6();
    Object.defineProperty(exports2, "SIZE_PREFIX_LENGTH", { enumerable: true, get: function() {
      return constants_js_4.SIZE_PREFIX_LENGTH;
    } });
    var utils_js_1 = require_utils2();
    Object.defineProperty(exports2, "int32", { enumerable: true, get: function() {
      return utils_js_1.int32;
    } });
    Object.defineProperty(exports2, "float32", { enumerable: true, get: function() {
      return utils_js_1.float32;
    } });
    Object.defineProperty(exports2, "float64", { enumerable: true, get: function() {
      return utils_js_1.float64;
    } });
    Object.defineProperty(exports2, "isLittleEndian", { enumerable: true, get: function() {
      return utils_js_1.isLittleEndian;
    } });
    var encoding_js_1 = require_encoding();
    Object.defineProperty(exports2, "Encoding", { enumerable: true, get: function() {
      return encoding_js_1.Encoding;
    } });
    var builder_js_1 = require_builder();
    Object.defineProperty(exports2, "Builder", { enumerable: true, get: function() {
      return builder_js_1.Builder;
    } });
    var byte_buffer_js_1 = require_byte_buffer();
    Object.defineProperty(exports2, "ByteBuffer", { enumerable: true, get: function() {
      return byte_buffer_js_1.ByteBuffer;
    } });
  }
});

// node_modules/apache-arrow/fb/body-compression-method.js
var require_body_compression_method = __commonJS({
  "node_modules/apache-arrow/fb/body-compression-method.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BodyCompressionMethod = void 0;
    var BodyCompressionMethod;
    (function(BodyCompressionMethod2) {
      BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
    })(BodyCompressionMethod || (exports2.BodyCompressionMethod = BodyCompressionMethod = {}));
  }
});

// node_modules/apache-arrow/fb/compression-type.js
var require_compression_type = __commonJS({
  "node_modules/apache-arrow/fb/compression-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressionType = void 0;
    var CompressionType;
    (function(CompressionType2) {
      CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
      CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
    })(CompressionType || (exports2.CompressionType = CompressionType = {}));
  }
});

// node_modules/apache-arrow/fb/body-compression.js
var require_body_compression = __commonJS({
  "node_modules/apache-arrow/fb/body-compression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BodyCompression = void 0;
    var flatbuffers = require_flatbuffers();
    var body_compression_method_js_1 = require_body_compression_method();
    var compression_type_js_1 = require_compression_type();
    var BodyCompression = class _BodyCompression {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsBodyCompression(bb, obj) {
        return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsBodyCompression(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * Compressor library.
       * For LZ4_FRAME, each compressed buffer must consist of a single frame.
       */
      codec() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : compression_type_js_1.CompressionType.LZ4_FRAME;
      }
      /**
       * Indicates the way the record batch body was compressed
       */
      method() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : body_compression_method_js_1.BodyCompressionMethod.BUFFER;
      }
      static startBodyCompression(builder) {
        builder.startObject(2);
      }
      static addCodec(builder, codec) {
        builder.addFieldInt8(0, codec, compression_type_js_1.CompressionType.LZ4_FRAME);
      }
      static addMethod(builder, method) {
        builder.addFieldInt8(1, method, body_compression_method_js_1.BodyCompressionMethod.BUFFER);
      }
      static endBodyCompression(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createBodyCompression(builder, codec, method) {
        _BodyCompression.startBodyCompression(builder);
        _BodyCompression.addCodec(builder, codec);
        _BodyCompression.addMethod(builder, method);
        return _BodyCompression.endBodyCompression(builder);
      }
    };
    exports2.BodyCompression = BodyCompression;
  }
});

// node_modules/apache-arrow/fb/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/apache-arrow/fb/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Buffer = void 0;
    var Buffer2 = class {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      /**
       * The relative offset into the shared memory page where the bytes for this
       * buffer starts
       */
      offset() {
        return this.bb.readInt64(this.bb_pos);
      }
      /**
       * The absolute length (in bytes) of the memory buffer. The memory is found
       * from offset (inclusive) to offset + length (non-inclusive). When building
       * messages using the encapsulated IPC message, padding bytes may be written
       * after a buffer, but such padding bytes do not need to be accounted for in
       * the size here.
       */
      length() {
        return this.bb.readInt64(this.bb_pos + 8);
      }
      static sizeOf() {
        return 16;
      }
      static createBuffer(builder, offset, length) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
      }
    };
    exports2.Buffer = Buffer2;
  }
});

// node_modules/apache-arrow/fb/field-node.js
var require_field_node = __commonJS({
  "node_modules/apache-arrow/fb/field-node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FieldNode = void 0;
    var FieldNode = class {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      /**
       * The number of value slots in the Arrow array at this level of a nested
       * tree
       */
      length() {
        return this.bb.readInt64(this.bb_pos);
      }
      /**
       * The number of observed nulls. Fields with null_count == 0 may choose not
       * to write their physical validity bitmap out as a materialized buffer,
       * instead setting the length of the bitmap buffer to 0.
       */
      nullCount() {
        return this.bb.readInt64(this.bb_pos + 8);
      }
      static sizeOf() {
        return 16;
      }
      static createFieldNode(builder, length, null_count) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        return builder.offset();
      }
    };
    exports2.FieldNode = FieldNode;
  }
});

// node_modules/apache-arrow/fb/record-batch.js
var require_record_batch = __commonJS({
  "node_modules/apache-arrow/fb/record-batch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecordBatch = void 0;
    var flatbuffers = require_flatbuffers();
    var body_compression_js_1 = require_body_compression();
    var buffer_js_1 = require_buffer2();
    var field_node_js_1 = require_field_node();
    var RecordBatch = class _RecordBatch {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsRecordBatch(bb, obj) {
        return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsRecordBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * number of records / rows. The arrays in the batch should all have this
       * length
       */
      length() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
      }
      /**
       * Nodes correspond to the pre-ordered flattened logical schema
       */
      nodes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_node_js_1.FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
      }
      nodesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * Buffers correspond to the pre-ordered flattened buffer tree
       *
       * The number of buffers appended to this list depends on the schema. For
       * example, most primitive arrays will have 2 buffers, 1 for the validity
       * bitmap and 1 for the values. For struct arrays, there will only be a
       * single buffer for the validity (nulls) bitmap
       */
      buffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
      }
      buffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * Optional compression of the message body
       */
      compression(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new body_compression_js_1.BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      static startRecordBatch(builder) {
        builder.startObject(4);
      }
      static addLength(builder, length) {
        builder.addFieldInt64(0, length, BigInt("0"));
      }
      static addNodes(builder, nodesOffset) {
        builder.addFieldOffset(1, nodesOffset, 0);
      }
      static startNodesVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
      }
      static addBuffers(builder, buffersOffset) {
        builder.addFieldOffset(2, buffersOffset, 0);
      }
      static startBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
      }
      static addCompression(builder, compressionOffset) {
        builder.addFieldOffset(3, compressionOffset, 0);
      }
      static endRecordBatch(builder) {
        const offset = builder.endObject();
        return offset;
      }
    };
    exports2.RecordBatch = RecordBatch;
  }
});

// node_modules/apache-arrow/fb/dictionary-batch.js
var require_dictionary_batch = __commonJS({
  "node_modules/apache-arrow/fb/dictionary-batch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DictionaryBatch = void 0;
    var flatbuffers = require_flatbuffers();
    var record_batch_js_1 = require_record_batch();
    var DictionaryBatch = class _DictionaryBatch {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsDictionaryBatch(bb, obj) {
        return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
      }
      data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new record_batch_js_1.RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * If isDelta is true the values in the dictionary are to be appended to a
       * dictionary with the indicated id. If isDelta is false this dictionary
       * should replace the existing dictionary.
       */
      isDelta() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
      }
      static startDictionaryBatch(builder) {
        builder.startObject(3);
      }
      static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt("0"));
      }
      static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
      }
      static addIsDelta(builder, isDelta) {
        builder.addFieldInt8(2, +isDelta, 0);
      }
      static endDictionaryBatch(builder) {
        const offset = builder.endObject();
        return offset;
      }
    };
    exports2.DictionaryBatch = DictionaryBatch;
  }
});

// node_modules/apache-arrow/fb/endianness.js
var require_endianness = __commonJS({
  "node_modules/apache-arrow/fb/endianness.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Endianness = void 0;
    var Endianness;
    (function(Endianness2) {
      Endianness2[Endianness2["Little"] = 0] = "Little";
      Endianness2[Endianness2["Big"] = 1] = "Big";
    })(Endianness || (exports2.Endianness = Endianness = {}));
  }
});

// node_modules/apache-arrow/fb/dictionary-kind.js
var require_dictionary_kind = __commonJS({
  "node_modules/apache-arrow/fb/dictionary-kind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DictionaryKind = void 0;
    var DictionaryKind;
    (function(DictionaryKind2) {
      DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
    })(DictionaryKind || (exports2.DictionaryKind = DictionaryKind = {}));
  }
});

// node_modules/apache-arrow/fb/int.js
var require_int = __commonJS({
  "node_modules/apache-arrow/fb/int.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Int = void 0;
    var flatbuffers = require_flatbuffers();
    var Int = class _Int {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsInt(bb, obj) {
        return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsInt(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
      }
      isSigned() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
      }
      static startInt(builder) {
        builder.startObject(2);
      }
      static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(0, bitWidth, 0);
      }
      static addIsSigned(builder, isSigned) {
        builder.addFieldInt8(1, +isSigned, 0);
      }
      static endInt(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createInt(builder, bitWidth, isSigned) {
        _Int.startInt(builder);
        _Int.addBitWidth(builder, bitWidth);
        _Int.addIsSigned(builder, isSigned);
        return _Int.endInt(builder);
      }
    };
    exports2.Int = Int;
  }
});

// node_modules/apache-arrow/fb/dictionary-encoding.js
var require_dictionary_encoding = __commonJS({
  "node_modules/apache-arrow/fb/dictionary-encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DictionaryEncoding = void 0;
    var flatbuffers = require_flatbuffers();
    var dictionary_kind_js_1 = require_dictionary_kind();
    var int_js_1 = require_int();
    var DictionaryEncoding = class _DictionaryEncoding {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsDictionaryEncoding(bb, obj) {
        return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * The known dictionary id in the application where this data is used. In
       * the file or streaming formats, the dictionary ids are found in the
       * DictionaryBatch messages
       */
      id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
      }
      /**
       * The dictionary indices are constrained to be non-negative integers. If
       * this field is null, the indices must be signed int32. To maximize
       * cross-language compatibility and performance, implementations are
       * recommended to prefer signed integer types over unsigned integer types
       * and to avoid uint64 indices unless they are required by an application.
       */
      indexType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * By default, dictionaries are not ordered, or the order does not have
       * semantic meaning. In some statistical, applications, dictionary-encoding
       * is used to represent ordered categorical data, and we provide a way to
       * preserve that metadata here
       */
      isOrdered() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
      }
      dictionaryKind() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : dictionary_kind_js_1.DictionaryKind.DenseArray;
      }
      static startDictionaryEncoding(builder) {
        builder.startObject(4);
      }
      static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt("0"));
      }
      static addIndexType(builder, indexTypeOffset) {
        builder.addFieldOffset(1, indexTypeOffset, 0);
      }
      static addIsOrdered(builder, isOrdered) {
        builder.addFieldInt8(2, +isOrdered, 0);
      }
      static addDictionaryKind(builder, dictionaryKind) {
        builder.addFieldInt16(3, dictionaryKind, dictionary_kind_js_1.DictionaryKind.DenseArray);
      }
      static endDictionaryEncoding(builder) {
        const offset = builder.endObject();
        return offset;
      }
    };
    exports2.DictionaryEncoding = DictionaryEncoding;
  }
});

// node_modules/apache-arrow/fb/key-value.js
var require_key_value = __commonJS({
  "node_modules/apache-arrow/fb/key-value.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyValue = void 0;
    var flatbuffers = require_flatbuffers();
    var KeyValue = class _KeyValue {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsKeyValue(bb, obj) {
        return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsKeyValue(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      key(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
      }
      value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
      }
      static startKeyValue(builder) {
        builder.startObject(2);
      }
      static addKey(builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
      }
      static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
      }
      static endKeyValue(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createKeyValue(builder, keyOffset, valueOffset) {
        _KeyValue.startKeyValue(builder);
        _KeyValue.addKey(builder, keyOffset);
        _KeyValue.addValue(builder, valueOffset);
        return _KeyValue.endKeyValue(builder);
      }
    };
    exports2.KeyValue = KeyValue;
  }
});

// node_modules/apache-arrow/fb/binary.js
var require_binary = __commonJS({
  "node_modules/apache-arrow/fb/binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Binary = void 0;
    var flatbuffers = require_flatbuffers();
    var Binary = class _Binary {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsBinary(bb, obj) {
        return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startBinary(builder) {
        builder.startObject(0);
      }
      static endBinary(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createBinary(builder) {
        _Binary.startBinary(builder);
        return _Binary.endBinary(builder);
      }
    };
    exports2.Binary = Binary;
  }
});

// node_modules/apache-arrow/fb/bool.js
var require_bool = __commonJS({
  "node_modules/apache-arrow/fb/bool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Bool = void 0;
    var flatbuffers = require_flatbuffers();
    var Bool = class _Bool {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsBool(bb, obj) {
        return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsBool(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startBool(builder) {
        builder.startObject(0);
      }
      static endBool(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createBool(builder) {
        _Bool.startBool(builder);
        return _Bool.endBool(builder);
      }
    };
    exports2.Bool = Bool;
  }
});

// node_modules/apache-arrow/fb/date.js
var require_date2 = __commonJS({
  "node_modules/apache-arrow/fb/date.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Date = void 0;
    var flatbuffers = require_flatbuffers();
    var date_unit_js_1 = require_date_unit();
    var Date2 = class _Date {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsDate(bb, obj) {
        return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsDate(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : date_unit_js_1.DateUnit.MILLISECOND;
      }
      static startDate(builder) {
        builder.startObject(1);
      }
      static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, date_unit_js_1.DateUnit.MILLISECOND);
      }
      static endDate(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createDate(builder, unit) {
        _Date.startDate(builder);
        _Date.addUnit(builder, unit);
        return _Date.endDate(builder);
      }
    };
    exports2.Date = Date2;
  }
});

// node_modules/apache-arrow/fb/decimal.js
var require_decimal = __commonJS({
  "node_modules/apache-arrow/fb/decimal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Decimal = void 0;
    var flatbuffers = require_flatbuffers();
    var Decimal = class _Decimal {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsDecimal(bb, obj) {
        return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsDecimal(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * Total number of decimal digits
       */
      precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
      }
      /**
       * Number of digits after the decimal point "."
       */
      scale() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
      }
      /**
       * Number of bits per value. The only accepted widths are 128 and 256.
       * We use bitWidth for consistency with Int::bitWidth.
       */
      bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
      }
      static startDecimal(builder) {
        builder.startObject(3);
      }
      static addPrecision(builder, precision) {
        builder.addFieldInt32(0, precision, 0);
      }
      static addScale(builder, scale) {
        builder.addFieldInt32(1, scale, 0);
      }
      static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(2, bitWidth, 128);
      }
      static endDecimal(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createDecimal(builder, precision, scale, bitWidth) {
        _Decimal.startDecimal(builder);
        _Decimal.addPrecision(builder, precision);
        _Decimal.addScale(builder, scale);
        _Decimal.addBitWidth(builder, bitWidth);
        return _Decimal.endDecimal(builder);
      }
    };
    exports2.Decimal = Decimal;
  }
});

// node_modules/apache-arrow/fb/duration.js
var require_duration = __commonJS({
  "node_modules/apache-arrow/fb/duration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Duration = void 0;
    var flatbuffers = require_flatbuffers();
    var time_unit_js_1 = require_time_unit();
    var Duration = class _Duration {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsDuration(bb, obj) {
        return (obj || new _Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsDuration(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
      }
      static startDuration(builder) {
        builder.startObject(1);
      }
      static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
      }
      static endDuration(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createDuration(builder, unit) {
        _Duration.startDuration(builder);
        _Duration.addUnit(builder, unit);
        return _Duration.endDuration(builder);
      }
    };
    exports2.Duration = Duration;
  }
});

// node_modules/apache-arrow/fb/fixed-size-binary.js
var require_fixed_size_binary = __commonJS({
  "node_modules/apache-arrow/fb/fixed-size-binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FixedSizeBinary = void 0;
    var flatbuffers = require_flatbuffers();
    var FixedSizeBinary = class _FixedSizeBinary {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsFixedSizeBinary(bb, obj) {
        return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * Number of bytes per value
       */
      byteWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
      }
      static startFixedSizeBinary(builder) {
        builder.startObject(1);
      }
      static addByteWidth(builder, byteWidth) {
        builder.addFieldInt32(0, byteWidth, 0);
      }
      static endFixedSizeBinary(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createFixedSizeBinary(builder, byteWidth) {
        _FixedSizeBinary.startFixedSizeBinary(builder);
        _FixedSizeBinary.addByteWidth(builder, byteWidth);
        return _FixedSizeBinary.endFixedSizeBinary(builder);
      }
    };
    exports2.FixedSizeBinary = FixedSizeBinary;
  }
});

// node_modules/apache-arrow/fb/fixed-size-list.js
var require_fixed_size_list = __commonJS({
  "node_modules/apache-arrow/fb/fixed-size-list.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FixedSizeList = void 0;
    var flatbuffers = require_flatbuffers();
    var FixedSizeList = class _FixedSizeList {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsFixedSizeList(bb, obj) {
        return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsFixedSizeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * Number of list items per value
       */
      listSize() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
      }
      static startFixedSizeList(builder) {
        builder.startObject(1);
      }
      static addListSize(builder, listSize) {
        builder.addFieldInt32(0, listSize, 0);
      }
      static endFixedSizeList(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createFixedSizeList(builder, listSize) {
        _FixedSizeList.startFixedSizeList(builder);
        _FixedSizeList.addListSize(builder, listSize);
        return _FixedSizeList.endFixedSizeList(builder);
      }
    };
    exports2.FixedSizeList = FixedSizeList;
  }
});

// node_modules/apache-arrow/fb/floating-point.js
var require_floating_point = __commonJS({
  "node_modules/apache-arrow/fb/floating-point.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FloatingPoint = void 0;
    var flatbuffers = require_flatbuffers();
    var precision_js_1 = require_precision();
    var FloatingPoint = class _FloatingPoint {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsFloatingPoint(bb, obj) {
        return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsFloatingPoint(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : precision_js_1.Precision.HALF;
      }
      static startFloatingPoint(builder) {
        builder.startObject(1);
      }
      static addPrecision(builder, precision) {
        builder.addFieldInt16(0, precision, precision_js_1.Precision.HALF);
      }
      static endFloatingPoint(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createFloatingPoint(builder, precision) {
        _FloatingPoint.startFloatingPoint(builder);
        _FloatingPoint.addPrecision(builder, precision);
        return _FloatingPoint.endFloatingPoint(builder);
      }
    };
    exports2.FloatingPoint = FloatingPoint;
  }
});

// node_modules/apache-arrow/fb/interval.js
var require_interval = __commonJS({
  "node_modules/apache-arrow/fb/interval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Interval = void 0;
    var flatbuffers = require_flatbuffers();
    var interval_unit_js_1 = require_interval_unit();
    var Interval = class _Interval {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsInterval(bb, obj) {
        return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsInterval(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : interval_unit_js_1.IntervalUnit.YEAR_MONTH;
      }
      static startInterval(builder) {
        builder.startObject(1);
      }
      static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, interval_unit_js_1.IntervalUnit.YEAR_MONTH);
      }
      static endInterval(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createInterval(builder, unit) {
        _Interval.startInterval(builder);
        _Interval.addUnit(builder, unit);
        return _Interval.endInterval(builder);
      }
    };
    exports2.Interval = Interval;
  }
});

// node_modules/apache-arrow/fb/large-binary.js
var require_large_binary = __commonJS({
  "node_modules/apache-arrow/fb/large-binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LargeBinary = void 0;
    var flatbuffers = require_flatbuffers();
    var LargeBinary = class _LargeBinary {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsLargeBinary(bb, obj) {
        return (obj || new _LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsLargeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startLargeBinary(builder) {
        builder.startObject(0);
      }
      static endLargeBinary(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createLargeBinary(builder) {
        _LargeBinary.startLargeBinary(builder);
        return _LargeBinary.endLargeBinary(builder);
      }
    };
    exports2.LargeBinary = LargeBinary;
  }
});

// node_modules/apache-arrow/fb/large-list.js
var require_large_list = __commonJS({
  "node_modules/apache-arrow/fb/large-list.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LargeList = void 0;
    var flatbuffers = require_flatbuffers();
    var LargeList = class _LargeList {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsLargeList(bb, obj) {
        return (obj || new _LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsLargeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startLargeList(builder) {
        builder.startObject(0);
      }
      static endLargeList(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createLargeList(builder) {
        _LargeList.startLargeList(builder);
        return _LargeList.endLargeList(builder);
      }
    };
    exports2.LargeList = LargeList;
  }
});

// node_modules/apache-arrow/fb/large-utf8.js
var require_large_utf8 = __commonJS({
  "node_modules/apache-arrow/fb/large-utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LargeUtf8 = void 0;
    var flatbuffers = require_flatbuffers();
    var LargeUtf8 = class _LargeUtf8 {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsLargeUtf8(bb, obj) {
        return (obj || new _LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsLargeUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startLargeUtf8(builder) {
        builder.startObject(0);
      }
      static endLargeUtf8(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createLargeUtf8(builder) {
        _LargeUtf8.startLargeUtf8(builder);
        return _LargeUtf8.endLargeUtf8(builder);
      }
    };
    exports2.LargeUtf8 = LargeUtf8;
  }
});

// node_modules/apache-arrow/fb/list.js
var require_list = __commonJS({
  "node_modules/apache-arrow/fb/list.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.List = void 0;
    var flatbuffers = require_flatbuffers();
    var List = class _List {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsList(bb, obj) {
        return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startList(builder) {
        builder.startObject(0);
      }
      static endList(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createList(builder) {
        _List.startList(builder);
        return _List.endList(builder);
      }
    };
    exports2.List = List;
  }
});

// node_modules/apache-arrow/fb/map.js
var require_map = __commonJS({
  "node_modules/apache-arrow/fb/map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Map = void 0;
    var flatbuffers = require_flatbuffers();
    var Map2 = class _Map {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsMap(bb, obj) {
        return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsMap(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * Set to true if the keys within each value are sorted
       */
      keysSorted() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
      }
      static startMap(builder) {
        builder.startObject(1);
      }
      static addKeysSorted(builder, keysSorted) {
        builder.addFieldInt8(0, +keysSorted, 0);
      }
      static endMap(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createMap(builder, keysSorted) {
        _Map.startMap(builder);
        _Map.addKeysSorted(builder, keysSorted);
        return _Map.endMap(builder);
      }
    };
    exports2.Map = Map2;
  }
});

// node_modules/apache-arrow/fb/null.js
var require_null = __commonJS({
  "node_modules/apache-arrow/fb/null.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Null = void 0;
    var flatbuffers = require_flatbuffers();
    var Null = class _Null {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsNull(bb, obj) {
        return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsNull(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startNull(builder) {
        builder.startObject(0);
      }
      static endNull(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createNull(builder) {
        _Null.startNull(builder);
        return _Null.endNull(builder);
      }
    };
    exports2.Null = Null;
  }
});

// node_modules/apache-arrow/fb/run-end-encoded.js
var require_run_end_encoded = __commonJS({
  "node_modules/apache-arrow/fb/run-end-encoded.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RunEndEncoded = void 0;
    var flatbuffers = require_flatbuffers();
    var RunEndEncoded = class _RunEndEncoded {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsRunEndEncoded(bb, obj) {
        return (obj || new _RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsRunEndEncoded(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startRunEndEncoded(builder) {
        builder.startObject(0);
      }
      static endRunEndEncoded(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createRunEndEncoded(builder) {
        _RunEndEncoded.startRunEndEncoded(builder);
        return _RunEndEncoded.endRunEndEncoded(builder);
      }
    };
    exports2.RunEndEncoded = RunEndEncoded;
  }
});

// node_modules/apache-arrow/fb/struct-.js
var require_struct = __commonJS({
  "node_modules/apache-arrow/fb/struct-.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Struct_ = void 0;
    var flatbuffers = require_flatbuffers();
    var Struct_ = class _Struct_ {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsStruct_(bb, obj) {
        return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsStruct_(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startStruct_(builder) {
        builder.startObject(0);
      }
      static endStruct_(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createStruct_(builder) {
        _Struct_.startStruct_(builder);
        return _Struct_.endStruct_(builder);
      }
    };
    exports2.Struct_ = Struct_;
  }
});

// node_modules/apache-arrow/fb/time.js
var require_time = __commonJS({
  "node_modules/apache-arrow/fb/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var flatbuffers = require_flatbuffers();
    var time_unit_js_1 = require_time_unit();
    var Time = class _Time {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsTime(bb, obj) {
        return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsTime(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
      }
      bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
      }
      static startTime(builder) {
        builder.startObject(2);
      }
      static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
      }
      static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(1, bitWidth, 32);
      }
      static endTime(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createTime(builder, unit, bitWidth) {
        _Time.startTime(builder);
        _Time.addUnit(builder, unit);
        _Time.addBitWidth(builder, bitWidth);
        return _Time.endTime(builder);
      }
    };
    exports2.Time = Time;
  }
});

// node_modules/apache-arrow/fb/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/apache-arrow/fb/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Timestamp = void 0;
    var flatbuffers = require_flatbuffers();
    var time_unit_js_1 = require_time_unit();
    var Timestamp = class _Timestamp {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsTimestamp(bb, obj) {
        return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsTimestamp(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.SECOND;
      }
      timezone(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
      }
      static startTimestamp(builder) {
        builder.startObject(2);
      }
      static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.SECOND);
      }
      static addTimezone(builder, timezoneOffset) {
        builder.addFieldOffset(1, timezoneOffset, 0);
      }
      static endTimestamp(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createTimestamp(builder, unit, timezoneOffset) {
        _Timestamp.startTimestamp(builder);
        _Timestamp.addUnit(builder, unit);
        _Timestamp.addTimezone(builder, timezoneOffset);
        return _Timestamp.endTimestamp(builder);
      }
    };
    exports2.Timestamp = Timestamp;
  }
});

// node_modules/apache-arrow/fb/union.js
var require_union = __commonJS({
  "node_modules/apache-arrow/fb/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Union = void 0;
    var flatbuffers = require_flatbuffers();
    var union_mode_js_1 = require_union_mode();
    var Union = class _Union {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsUnion(bb, obj) {
        return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsUnion(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      mode() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : union_mode_js_1.UnionMode.Sparse;
      }
      typeIds(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
      }
      typeIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      typeIdsArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
      }
      static startUnion(builder) {
        builder.startObject(2);
      }
      static addMode(builder, mode) {
        builder.addFieldInt16(0, mode, union_mode_js_1.UnionMode.Sparse);
      }
      static addTypeIds(builder, typeIdsOffset) {
        builder.addFieldOffset(1, typeIdsOffset, 0);
      }
      static createTypeIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addInt32(data[i]);
        }
        return builder.endVector();
      }
      static startTypeIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static endUnion(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createUnion(builder, mode, typeIdsOffset) {
        _Union.startUnion(builder);
        _Union.addMode(builder, mode);
        _Union.addTypeIds(builder, typeIdsOffset);
        return _Union.endUnion(builder);
      }
    };
    exports2.Union = Union;
  }
});

// node_modules/apache-arrow/fb/utf8.js
var require_utf82 = __commonJS({
  "node_modules/apache-arrow/fb/utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utf8 = void 0;
    var flatbuffers = require_flatbuffers();
    var Utf8 = class _Utf8 {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsUtf8(bb, obj) {
        return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static startUtf8(builder) {
        builder.startObject(0);
      }
      static endUtf8(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createUtf8(builder) {
        _Utf8.startUtf8(builder);
        return _Utf8.endUtf8(builder);
      }
    };
    exports2.Utf8 = Utf8;
  }
});

// node_modules/apache-arrow/fb/type.js
var require_type = __commonJS({
  "node_modules/apache-arrow/fb/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unionListToType = exports2.unionToType = exports2.Type = void 0;
    var binary_js_1 = require_binary();
    var bool_js_1 = require_bool();
    var date_js_1 = require_date2();
    var decimal_js_1 = require_decimal();
    var duration_js_1 = require_duration();
    var fixed_size_binary_js_1 = require_fixed_size_binary();
    var fixed_size_list_js_1 = require_fixed_size_list();
    var floating_point_js_1 = require_floating_point();
    var int_js_1 = require_int();
    var interval_js_1 = require_interval();
    var large_binary_js_1 = require_large_binary();
    var large_list_js_1 = require_large_list();
    var large_utf8_js_1 = require_large_utf8();
    var list_js_1 = require_list();
    var map_js_1 = require_map();
    var null_js_1 = require_null();
    var run_end_encoded_js_1 = require_run_end_encoded();
    var struct__js_1 = require_struct();
    var time_js_1 = require_time();
    var timestamp_js_1 = require_timestamp();
    var union_js_1 = require_union();
    var utf8_js_1 = require_utf82();
    var Type;
    (function(Type2) {
      Type2[Type2["NONE"] = 0] = "NONE";
      Type2[Type2["Null"] = 1] = "Null";
      Type2[Type2["Int"] = 2] = "Int";
      Type2[Type2["FloatingPoint"] = 3] = "FloatingPoint";
      Type2[Type2["Binary"] = 4] = "Binary";
      Type2[Type2["Utf8"] = 5] = "Utf8";
      Type2[Type2["Bool"] = 6] = "Bool";
      Type2[Type2["Decimal"] = 7] = "Decimal";
      Type2[Type2["Date"] = 8] = "Date";
      Type2[Type2["Time"] = 9] = "Time";
      Type2[Type2["Timestamp"] = 10] = "Timestamp";
      Type2[Type2["Interval"] = 11] = "Interval";
      Type2[Type2["List"] = 12] = "List";
      Type2[Type2["Struct_"] = 13] = "Struct_";
      Type2[Type2["Union"] = 14] = "Union";
      Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
      Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
      Type2[Type2["Map"] = 17] = "Map";
      Type2[Type2["Duration"] = 18] = "Duration";
      Type2[Type2["LargeBinary"] = 19] = "LargeBinary";
      Type2[Type2["LargeUtf8"] = 20] = "LargeUtf8";
      Type2[Type2["LargeList"] = 21] = "LargeList";
      Type2[Type2["RunEndEncoded"] = 22] = "RunEndEncoded";
    })(Type || (exports2.Type = Type = {}));
    function unionToType(type, accessor) {
      switch (Type[type]) {
        case "NONE":
          return null;
        case "Null":
          return accessor(new null_js_1.Null());
        case "Int":
          return accessor(new int_js_1.Int());
        case "FloatingPoint":
          return accessor(new floating_point_js_1.FloatingPoint());
        case "Binary":
          return accessor(new binary_js_1.Binary());
        case "Utf8":
          return accessor(new utf8_js_1.Utf8());
        case "Bool":
          return accessor(new bool_js_1.Bool());
        case "Decimal":
          return accessor(new decimal_js_1.Decimal());
        case "Date":
          return accessor(new date_js_1.Date());
        case "Time":
          return accessor(new time_js_1.Time());
        case "Timestamp":
          return accessor(new timestamp_js_1.Timestamp());
        case "Interval":
          return accessor(new interval_js_1.Interval());
        case "List":
          return accessor(new list_js_1.List());
        case "Struct_":
          return accessor(new struct__js_1.Struct_());
        case "Union":
          return accessor(new union_js_1.Union());
        case "FixedSizeBinary":
          return accessor(new fixed_size_binary_js_1.FixedSizeBinary());
        case "FixedSizeList":
          return accessor(new fixed_size_list_js_1.FixedSizeList());
        case "Map":
          return accessor(new map_js_1.Map());
        case "Duration":
          return accessor(new duration_js_1.Duration());
        case "LargeBinary":
          return accessor(new large_binary_js_1.LargeBinary());
        case "LargeUtf8":
          return accessor(new large_utf8_js_1.LargeUtf8());
        case "LargeList":
          return accessor(new large_list_js_1.LargeList());
        case "RunEndEncoded":
          return accessor(new run_end_encoded_js_1.RunEndEncoded());
        default:
          return null;
      }
    }
    exports2.unionToType = unionToType;
    function unionListToType(type, accessor, index) {
      switch (Type[type]) {
        case "NONE":
          return null;
        case "Null":
          return accessor(index, new null_js_1.Null());
        case "Int":
          return accessor(index, new int_js_1.Int());
        case "FloatingPoint":
          return accessor(index, new floating_point_js_1.FloatingPoint());
        case "Binary":
          return accessor(index, new binary_js_1.Binary());
        case "Utf8":
          return accessor(index, new utf8_js_1.Utf8());
        case "Bool":
          return accessor(index, new bool_js_1.Bool());
        case "Decimal":
          return accessor(index, new decimal_js_1.Decimal());
        case "Date":
          return accessor(index, new date_js_1.Date());
        case "Time":
          return accessor(index, new time_js_1.Time());
        case "Timestamp":
          return accessor(index, new timestamp_js_1.Timestamp());
        case "Interval":
          return accessor(index, new interval_js_1.Interval());
        case "List":
          return accessor(index, new list_js_1.List());
        case "Struct_":
          return accessor(index, new struct__js_1.Struct_());
        case "Union":
          return accessor(index, new union_js_1.Union());
        case "FixedSizeBinary":
          return accessor(index, new fixed_size_binary_js_1.FixedSizeBinary());
        case "FixedSizeList":
          return accessor(index, new fixed_size_list_js_1.FixedSizeList());
        case "Map":
          return accessor(index, new map_js_1.Map());
        case "Duration":
          return accessor(index, new duration_js_1.Duration());
        case "LargeBinary":
          return accessor(index, new large_binary_js_1.LargeBinary());
        case "LargeUtf8":
          return accessor(index, new large_utf8_js_1.LargeUtf8());
        case "LargeList":
          return accessor(index, new large_list_js_1.LargeList());
        case "RunEndEncoded":
          return accessor(index, new run_end_encoded_js_1.RunEndEncoded());
        default:
          return null;
      }
    }
    exports2.unionListToType = unionListToType;
  }
});

// node_modules/apache-arrow/fb/field.js
var require_field = __commonJS({
  "node_modules/apache-arrow/fb/field.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Field = void 0;
    var flatbuffers = require_flatbuffers();
    var dictionary_encoding_js_1 = require_dictionary_encoding();
    var key_value_js_1 = require_key_value();
    var type_js_1 = require_type();
    var Field = class _Field {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsField(bb, obj) {
        return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsField(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
      }
      /**
       * Whether or not this field can contain nulls. Should be true in general.
       */
      nullable() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
      }
      typeType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
      }
      /**
       * This is the type of the decoded value if the field is dictionary encoded.
       */
      type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
      }
      /**
       * Present only if the field is dictionary encoded.
       */
      dictionary(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new dictionary_encoding_js_1.DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * children apply only to nested data types like Struct, List and Union. For
       * primitive types children will have length 0.
       */
      children(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new _Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      childrenLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * User-defined metadata
       */
      customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      static startField(builder) {
        builder.startObject(7);
      }
      static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
      }
      static addNullable(builder, nullable) {
        builder.addFieldInt8(1, +nullable, 0);
      }
      static addTypeType(builder, typeType) {
        builder.addFieldInt8(2, typeType, type_js_1.Type.NONE);
      }
      static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
      }
      static addDictionary(builder, dictionaryOffset) {
        builder.addFieldOffset(4, dictionaryOffset, 0);
      }
      static addChildren(builder, childrenOffset) {
        builder.addFieldOffset(5, childrenOffset, 0);
      }
      static createChildrenVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startChildrenVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(6, customMetadataOffset, 0);
      }
      static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static endField(builder) {
        const offset = builder.endObject();
        return offset;
      }
    };
    exports2.Field = Field;
  }
});

// node_modules/apache-arrow/fb/schema.js
var require_schema = __commonJS({
  "node_modules/apache-arrow/fb/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Schema = void 0;
    var flatbuffers = require_flatbuffers();
    var endianness_js_1 = require_endianness();
    var field_js_1 = require_field();
    var key_value_js_1 = require_key_value();
    var Schema = class _Schema {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsSchema(bb, obj) {
        return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsSchema(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * endianness of the buffer
       * it is Little Endian by default
       * if endianness doesn't match the underlying system then the vectors need to be converted
       */
      endianness() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : endianness_js_1.Endianness.Little;
      }
      fields(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_js_1.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      fieldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * Features used in the stream/file.
       */
      features(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
      }
      featuresLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      static startSchema(builder) {
        builder.startObject(4);
      }
      static addEndianness(builder, endianness) {
        builder.addFieldInt16(0, endianness, endianness_js_1.Endianness.Little);
      }
      static addFields(builder, fieldsOffset) {
        builder.addFieldOffset(1, fieldsOffset, 0);
      }
      static createFieldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startFieldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(2, customMetadataOffset, 0);
      }
      static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static addFeatures(builder, featuresOffset) {
        builder.addFieldOffset(3, featuresOffset, 0);
      }
      static createFeaturesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addInt64(data[i]);
        }
        return builder.endVector();
      }
      static startFeaturesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
      }
      static endSchema(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static finishSchemaBuffer(builder, offset) {
        builder.finish(offset);
      }
      static finishSizePrefixedSchemaBuffer(builder, offset) {
        builder.finish(offset, void 0, true);
      }
      static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
        _Schema.startSchema(builder);
        _Schema.addEndianness(builder, endianness);
        _Schema.addFields(builder, fieldsOffset);
        _Schema.addCustomMetadata(builder, customMetadataOffset);
        _Schema.addFeatures(builder, featuresOffset);
        return _Schema.endSchema(builder);
      }
    };
    exports2.Schema = Schema;
  }
});

// node_modules/apache-arrow/fb/sparse-matrix-compressed-axis.js
var require_sparse_matrix_compressed_axis = __commonJS({
  "node_modules/apache-arrow/fb/sparse-matrix-compressed-axis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SparseMatrixCompressedAxis = void 0;
    var SparseMatrixCompressedAxis;
    (function(SparseMatrixCompressedAxis2) {
      SparseMatrixCompressedAxis2[SparseMatrixCompressedAxis2["Row"] = 0] = "Row";
      SparseMatrixCompressedAxis2[SparseMatrixCompressedAxis2["Column"] = 1] = "Column";
    })(SparseMatrixCompressedAxis || (exports2.SparseMatrixCompressedAxis = SparseMatrixCompressedAxis = {}));
  }
});

// node_modules/apache-arrow/fb/sparse-matrix-index-csx.js
var require_sparse_matrix_index_csx = __commonJS({
  "node_modules/apache-arrow/fb/sparse-matrix-index-csx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SparseMatrixIndexCSX = void 0;
    var flatbuffers = require_flatbuffers();
    var buffer_js_1 = require_buffer2();
    var int_js_1 = require_int();
    var sparse_matrix_compressed_axis_js_1 = require_sparse_matrix_compressed_axis();
    var SparseMatrixIndexCSX = class _SparseMatrixIndexCSX {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsSparseMatrixIndexCSX(bb, obj) {
        return (obj || new _SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsSparseMatrixIndexCSX(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * Which axis, row or column, is compressed
       */
      compressedAxis() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row;
      }
      /**
       * The type of values in indptrBuffer
       */
      indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * indptrBuffer stores the location and size of indptr array that
       * represents the range of the rows.
       * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.
       * The length of this array is 1 + (the number of rows), and the type
       * of index value is long.
       *
       * For example, let X be the following 6x4 matrix:
       * ```text
       *   X := [[0, 1, 2, 0],
       *         [0, 0, 3, 0],
       *         [0, 4, 0, 5],
       *         [0, 0, 0, 0],
       *         [6, 0, 7, 8],
       *         [0, 9, 0, 0]].
       * ```
       * The array of non-zero values in X is:
       * ```text
       *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
       * ```
       * And the indptr of X is:
       * ```text
       *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].
       * ```
       */
      indptrBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
      }
      /**
       * The type of values in indicesBuffer
       */
      indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * indicesBuffer stores the location and size of the array that
       * contains the column indices of the corresponding non-zero values.
       * The type of index value is long.
       *
       * For example, the indices of the above X is:
       * ```text
       *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
       * ```
       * Note that the indices are sorted in lexicographical order for each row.
       */
      indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
      }
      static startSparseMatrixIndexCSX(builder) {
        builder.startObject(5);
      }
      static addCompressedAxis(builder, compressedAxis) {
        builder.addFieldInt16(0, compressedAxis, sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row);
      }
      static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(1, indptrTypeOffset, 0);
      }
      static addIndptrBuffer(builder, indptrBufferOffset) {
        builder.addFieldStruct(2, indptrBufferOffset, 0);
      }
      static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(3, indicesTypeOffset, 0);
      }
      static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(4, indicesBufferOffset, 0);
      }
      static endSparseMatrixIndexCSX(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6);
        builder.requiredField(offset, 8);
        builder.requiredField(offset, 10);
        builder.requiredField(offset, 12);
        return offset;
      }
    };
    exports2.SparseMatrixIndexCSX = SparseMatrixIndexCSX;
  }
});

// node_modules/apache-arrow/fb/sparse-tensor-index-coo.js
var require_sparse_tensor_index_coo = __commonJS({
  "node_modules/apache-arrow/fb/sparse-tensor-index-coo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SparseTensorIndexCOO = void 0;
    var flatbuffers = require_flatbuffers();
    var buffer_js_1 = require_buffer2();
    var int_js_1 = require_int();
    var SparseTensorIndexCOO = class _SparseTensorIndexCOO {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsSparseTensorIndexCOO(bb, obj) {
        return (obj || new _SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsSparseTensorIndexCOO(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * The type of values in indicesBuffer
       */
      indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * Non-negative byte offsets to advance one value cell along each dimension
       * If omitted, default to row-major order (C-like).
       */
      indicesStrides(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
      }
      indicesStridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * The location and size of the indices matrix's data
       */
      indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
      }
      /**
       * This flag is true if and only if the indices matrix is sorted in
       * row-major order, and does not have duplicated entries.
       * This sort order is the same as of Tensorflow's SparseTensor,
       * but it is inverse order of SciPy's canonical coo_matrix
       * (SciPy employs column-major order for its coo_matrix).
       */
      isCanonical() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
      }
      static startSparseTensorIndexCOO(builder) {
        builder.startObject(4);
      }
      static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(0, indicesTypeOffset, 0);
      }
      static addIndicesStrides(builder, indicesStridesOffset) {
        builder.addFieldOffset(1, indicesStridesOffset, 0);
      }
      static createIndicesStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addInt64(data[i]);
        }
        return builder.endVector();
      }
      static startIndicesStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
      }
      static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(2, indicesBufferOffset, 0);
      }
      static addIsCanonical(builder, isCanonical) {
        builder.addFieldInt8(3, +isCanonical, 0);
      }
      static endSparseTensorIndexCOO(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4);
        builder.requiredField(offset, 8);
        return offset;
      }
    };
    exports2.SparseTensorIndexCOO = SparseTensorIndexCOO;
  }
});

// node_modules/apache-arrow/fb/sparse-tensor-index-csf.js
var require_sparse_tensor_index_csf = __commonJS({
  "node_modules/apache-arrow/fb/sparse-tensor-index-csf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SparseTensorIndexCSF = void 0;
    var flatbuffers = require_flatbuffers();
    var buffer_js_1 = require_buffer2();
    var int_js_1 = require_int();
    var SparseTensorIndexCSF = class _SparseTensorIndexCSF {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsSparseTensorIndexCSF(bb, obj) {
        return (obj || new _SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsSparseTensorIndexCSF(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * CSF is a generalization of compressed sparse row (CSR) index.
       * See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
       *
       * CSF index recursively compresses each dimension of a tensor into a set
       * of prefix trees. Each path from a root to leaf forms one tensor
       * non-zero index. CSF is implemented with two arrays of buffers and one
       * arrays of integers.
       *
       * For example, let X be a 2x3x4x5 tensor and let it have the following
       * 8 non-zero values:
       * ```text
       *   X[0, 0, 0, 1] := 1
       *   X[0, 0, 0, 2] := 2
       *   X[0, 1, 0, 0] := 3
       *   X[0, 1, 0, 2] := 4
       *   X[0, 1, 1, 0] := 5
       *   X[1, 1, 1, 0] := 6
       *   X[1, 1, 1, 1] := 7
       *   X[1, 1, 1, 2] := 8
       * ```
       * As a prefix tree this would be represented as:
       * ```text
       *         0          1
       *        / \         |
       *       0   1        1
       *      /   / \       |
       *     0   0   1      1
       *    /|  /|   |    /| |
       *   1 2 0 2   0   0 1 2
       * ```
       * The type of values in indptrBuffers
       */
      indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * indptrBuffers stores the sparsity structure.
       * Each two consecutive dimensions in a tensor correspond to a buffer in
       * indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
       * and `indptrBuffers[dim][i + 1]` signify a range of nodes in
       * `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
       *
       * For example, the indptrBuffers for the above X is:
       * ```text
       *   indptrBuffer(X) = [
       *                       [0, 2, 3],
       *                       [0, 1, 3, 4],
       *                       [0, 2, 4, 5, 8]
       *                     ].
       * ```
       */
      indptrBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
      }
      indptrBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * The type of values in indicesBuffers
       */
      indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      /**
       * indicesBuffers stores values of nodes.
       * Each tensor dimension corresponds to a buffer in indicesBuffers.
       * For example, the indicesBuffers for the above X is:
       * ```text
       *   indicesBuffer(X) = [
       *                        [0, 1],
       *                        [0, 1, 1],
       *                        [0, 0, 1, 1],
       *                        [1, 2, 0, 2, 0, 0, 1, 2]
       *                      ].
       * ```
       */
      indicesBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
      }
      indicesBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * axisOrder stores the sequence in which dimensions were traversed to
       * produce the prefix tree.
       * For example, the axisOrder for the above X is:
       * ```text
       *   axisOrder(X) = [0, 1, 2, 3].
       * ```
       */
      axisOrder(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
      }
      axisOrderLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      axisOrderArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
      }
      static startSparseTensorIndexCSF(builder) {
        builder.startObject(5);
      }
      static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(0, indptrTypeOffset, 0);
      }
      static addIndptrBuffers(builder, indptrBuffersOffset) {
        builder.addFieldOffset(1, indptrBuffersOffset, 0);
      }
      static startIndptrBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
      }
      static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(2, indicesTypeOffset, 0);
      }
      static addIndicesBuffers(builder, indicesBuffersOffset) {
        builder.addFieldOffset(3, indicesBuffersOffset, 0);
      }
      static startIndicesBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
      }
      static addAxisOrder(builder, axisOrderOffset) {
        builder.addFieldOffset(4, axisOrderOffset, 0);
      }
      static createAxisOrderVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addInt32(data[i]);
        }
        return builder.endVector();
      }
      static startAxisOrderVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static endSparseTensorIndexCSF(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4);
        builder.requiredField(offset, 6);
        builder.requiredField(offset, 8);
        builder.requiredField(offset, 10);
        builder.requiredField(offset, 12);
        return offset;
      }
    };
    exports2.SparseTensorIndexCSF = SparseTensorIndexCSF;
  }
});

// node_modules/apache-arrow/fb/sparse-tensor-index.js
var require_sparse_tensor_index = __commonJS({
  "node_modules/apache-arrow/fb/sparse-tensor-index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unionListToSparseTensorIndex = exports2.unionToSparseTensorIndex = exports2.SparseTensorIndex = void 0;
    var sparse_matrix_index_csx_js_1 = require_sparse_matrix_index_csx();
    var sparse_tensor_index_coo_js_1 = require_sparse_tensor_index_coo();
    var sparse_tensor_index_csf_js_1 = require_sparse_tensor_index_csf();
    var SparseTensorIndex;
    (function(SparseTensorIndex2) {
      SparseTensorIndex2[SparseTensorIndex2["NONE"] = 0] = "NONE";
      SparseTensorIndex2[SparseTensorIndex2["SparseTensorIndexCOO"] = 1] = "SparseTensorIndexCOO";
      SparseTensorIndex2[SparseTensorIndex2["SparseMatrixIndexCSX"] = 2] = "SparseMatrixIndexCSX";
      SparseTensorIndex2[SparseTensorIndex2["SparseTensorIndexCSF"] = 3] = "SparseTensorIndexCSF";
    })(SparseTensorIndex || (exports2.SparseTensorIndex = SparseTensorIndex = {}));
    function unionToSparseTensorIndex(type, accessor) {
      switch (SparseTensorIndex[type]) {
        case "NONE":
          return null;
        case "SparseTensorIndexCOO":
          return accessor(new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case "SparseMatrixIndexCSX":
          return accessor(new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case "SparseTensorIndexCSF":
          return accessor(new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default:
          return null;
      }
    }
    exports2.unionToSparseTensorIndex = unionToSparseTensorIndex;
    function unionListToSparseTensorIndex(type, accessor, index) {
      switch (SparseTensorIndex[type]) {
        case "NONE":
          return null;
        case "SparseTensorIndexCOO":
          return accessor(index, new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case "SparseMatrixIndexCSX":
          return accessor(index, new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case "SparseTensorIndexCSF":
          return accessor(index, new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default:
          return null;
      }
    }
    exports2.unionListToSparseTensorIndex = unionListToSparseTensorIndex;
  }
});

// node_modules/apache-arrow/fb/tensor-dim.js
var require_tensor_dim = __commonJS({
  "node_modules/apache-arrow/fb/tensor-dim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TensorDim = void 0;
    var flatbuffers = require_flatbuffers();
    var TensorDim = class _TensorDim {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsTensorDim(bb, obj) {
        return (obj || new _TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsTensorDim(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      /**
       * Length of dimension
       */
      size() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
      }
      name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
      }
      static startTensorDim(builder) {
        builder.startObject(2);
      }
      static addSize(builder, size) {
        builder.addFieldInt64(0, size, BigInt("0"));
      }
      static addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
      }
      static endTensorDim(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static createTensorDim(builder, size, nameOffset) {
        _TensorDim.startTensorDim(builder);
        _TensorDim.addSize(builder, size);
        _TensorDim.addName(builder, nameOffset);
        return _TensorDim.endTensorDim(builder);
      }
    };
    exports2.TensorDim = TensorDim;
  }
});

// node_modules/apache-arrow/fb/sparse-tensor.js
var require_sparse_tensor = __commonJS({
  "node_modules/apache-arrow/fb/sparse-tensor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SparseTensor = void 0;
    var flatbuffers = require_flatbuffers();
    var buffer_js_1 = require_buffer2();
    var sparse_tensor_index_js_1 = require_sparse_tensor_index();
    var tensor_dim_js_1 = require_tensor_dim();
    var type_js_1 = require_type();
    var SparseTensor = class _SparseTensor {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsSparseTensor(bb, obj) {
        return (obj || new _SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsSparseTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
      }
      /**
       * The type of data contained in a value cell.
       * Currently only fixed-width value types are supported,
       * no strings or nested types.
       */
      type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
      }
      /**
       * The dimensions of the tensor, optionally named.
       */
      shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * The number of non-zero values in a sparse tensor.
       */
      nonZeroLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
      }
      sparseIndexType() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : sparse_tensor_index_js_1.SparseTensorIndex.NONE;
      }
      /**
       * Sparse tensor index
       */
      sparseIndex(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
      }
      /**
       * The location and size of the tensor's data
       */
      data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
      }
      static startSparseTensor(builder) {
        builder.startObject(7);
      }
      static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
      }
      static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
      }
      static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
      }
      static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static addNonZeroLength(builder, nonZeroLength) {
        builder.addFieldInt64(3, nonZeroLength, BigInt("0"));
      }
      static addSparseIndexType(builder, sparseIndexType) {
        builder.addFieldInt8(4, sparseIndexType, sparse_tensor_index_js_1.SparseTensorIndex.NONE);
      }
      static addSparseIndex(builder, sparseIndexOffset) {
        builder.addFieldOffset(5, sparseIndexOffset, 0);
      }
      static addData(builder, dataOffset) {
        builder.addFieldStruct(6, dataOffset, 0);
      }
      static endSparseTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6);
        builder.requiredField(offset, 8);
        builder.requiredField(offset, 14);
        builder.requiredField(offset, 16);
        return offset;
      }
      static finishSparseTensorBuffer(builder, offset) {
        builder.finish(offset);
      }
      static finishSizePrefixedSparseTensorBuffer(builder, offset) {
        builder.finish(offset, void 0, true);
      }
    };
    exports2.SparseTensor = SparseTensor;
  }
});

// node_modules/apache-arrow/fb/tensor.js
var require_tensor = __commonJS({
  "node_modules/apache-arrow/fb/tensor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tensor = void 0;
    var flatbuffers = require_flatbuffers();
    var buffer_js_1 = require_buffer2();
    var tensor_dim_js_1 = require_tensor_dim();
    var type_js_1 = require_type();
    var Tensor = class _Tensor {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsTensor(bb, obj) {
        return (obj || new _Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
      }
      /**
       * The type of data contained in a value cell. Currently only fixed-width
       * value types are supported, no strings or nested types
       */
      type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
      }
      /**
       * The dimensions of the tensor, optionally named
       */
      shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * Non-negative byte offsets to advance one value cell along each dimension
       * If omitted, default to row-major order (C-like).
       */
      strides(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
      }
      stridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * The location and size of the tensor's data
       */
      data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
      }
      static startTensor(builder) {
        builder.startObject(5);
      }
      static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
      }
      static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
      }
      static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
      }
      static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static addStrides(builder, stridesOffset) {
        builder.addFieldOffset(3, stridesOffset, 0);
      }
      static createStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addInt64(data[i]);
        }
        return builder.endVector();
      }
      static startStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
      }
      static addData(builder, dataOffset) {
        builder.addFieldStruct(4, dataOffset, 0);
      }
      static endTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6);
        builder.requiredField(offset, 8);
        builder.requiredField(offset, 12);
        return offset;
      }
      static finishTensorBuffer(builder, offset) {
        builder.finish(offset);
      }
      static finishSizePrefixedTensorBuffer(builder, offset) {
        builder.finish(offset, void 0, true);
      }
    };
    exports2.Tensor = Tensor;
  }
});

// node_modules/apache-arrow/fb/message-header.js
var require_message_header = __commonJS({
  "node_modules/apache-arrow/fb/message-header.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unionListToMessageHeader = exports2.unionToMessageHeader = exports2.MessageHeader = void 0;
    var dictionary_batch_js_1 = require_dictionary_batch();
    var record_batch_js_1 = require_record_batch();
    var schema_js_1 = require_schema();
    var sparse_tensor_js_1 = require_sparse_tensor();
    var tensor_js_1 = require_tensor();
    var MessageHeader;
    (function(MessageHeader2) {
      MessageHeader2[MessageHeader2["NONE"] = 0] = "NONE";
      MessageHeader2[MessageHeader2["Schema"] = 1] = "Schema";
      MessageHeader2[MessageHeader2["DictionaryBatch"] = 2] = "DictionaryBatch";
      MessageHeader2[MessageHeader2["RecordBatch"] = 3] = "RecordBatch";
      MessageHeader2[MessageHeader2["Tensor"] = 4] = "Tensor";
      MessageHeader2[MessageHeader2["SparseTensor"] = 5] = "SparseTensor";
    })(MessageHeader || (exports2.MessageHeader = MessageHeader = {}));
    function unionToMessageHeader(type, accessor) {
      switch (MessageHeader[type]) {
        case "NONE":
          return null;
        case "Schema":
          return accessor(new schema_js_1.Schema());
        case "DictionaryBatch":
          return accessor(new dictionary_batch_js_1.DictionaryBatch());
        case "RecordBatch":
          return accessor(new record_batch_js_1.RecordBatch());
        case "Tensor":
          return accessor(new tensor_js_1.Tensor());
        case "SparseTensor":
          return accessor(new sparse_tensor_js_1.SparseTensor());
        default:
          return null;
      }
    }
    exports2.unionToMessageHeader = unionToMessageHeader;
    function unionListToMessageHeader(type, accessor, index) {
      switch (MessageHeader[type]) {
        case "NONE":
          return null;
        case "Schema":
          return accessor(index, new schema_js_1.Schema());
        case "DictionaryBatch":
          return accessor(index, new dictionary_batch_js_1.DictionaryBatch());
        case "RecordBatch":
          return accessor(index, new record_batch_js_1.RecordBatch());
        case "Tensor":
          return accessor(index, new tensor_js_1.Tensor());
        case "SparseTensor":
          return accessor(index, new sparse_tensor_js_1.SparseTensor());
        default:
          return null;
      }
    }
    exports2.unionListToMessageHeader = unionListToMessageHeader;
  }
});

// node_modules/apache-arrow/enum.js
var require_enum = __commonJS({
  "node_modules/apache-arrow/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferType = exports2.Type = exports2.MessageHeader = exports2.IntervalUnit = exports2.TimeUnit = exports2.DateUnit = exports2.Precision = exports2.UnionMode = exports2.MetadataVersion = void 0;
    var metadata_version_js_1 = require_metadata_version();
    Object.defineProperty(exports2, "MetadataVersion", { enumerable: true, get: function() {
      return metadata_version_js_1.MetadataVersion;
    } });
    var union_mode_js_1 = require_union_mode();
    Object.defineProperty(exports2, "UnionMode", { enumerable: true, get: function() {
      return union_mode_js_1.UnionMode;
    } });
    var precision_js_1 = require_precision();
    Object.defineProperty(exports2, "Precision", { enumerable: true, get: function() {
      return precision_js_1.Precision;
    } });
    var date_unit_js_1 = require_date_unit();
    Object.defineProperty(exports2, "DateUnit", { enumerable: true, get: function() {
      return date_unit_js_1.DateUnit;
    } });
    var time_unit_js_1 = require_time_unit();
    Object.defineProperty(exports2, "TimeUnit", { enumerable: true, get: function() {
      return time_unit_js_1.TimeUnit;
    } });
    var interval_unit_js_1 = require_interval_unit();
    Object.defineProperty(exports2, "IntervalUnit", { enumerable: true, get: function() {
      return interval_unit_js_1.IntervalUnit;
    } });
    var message_header_js_1 = require_message_header();
    Object.defineProperty(exports2, "MessageHeader", { enumerable: true, get: function() {
      return message_header_js_1.MessageHeader;
    } });
    var Type;
    (function(Type2) {
      Type2[Type2["NONE"] = 0] = "NONE";
      Type2[Type2["Null"] = 1] = "Null";
      Type2[Type2["Int"] = 2] = "Int";
      Type2[Type2["Float"] = 3] = "Float";
      Type2[Type2["Binary"] = 4] = "Binary";
      Type2[Type2["Utf8"] = 5] = "Utf8";
      Type2[Type2["Bool"] = 6] = "Bool";
      Type2[Type2["Decimal"] = 7] = "Decimal";
      Type2[Type2["Date"] = 8] = "Date";
      Type2[Type2["Time"] = 9] = "Time";
      Type2[Type2["Timestamp"] = 10] = "Timestamp";
      Type2[Type2["Interval"] = 11] = "Interval";
      Type2[Type2["List"] = 12] = "List";
      Type2[Type2["Struct"] = 13] = "Struct";
      Type2[Type2["Union"] = 14] = "Union";
      Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
      Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
      Type2[Type2["Map"] = 17] = "Map";
      Type2[Type2["Duration"] = 18] = "Duration";
      Type2[Type2["LargeBinary"] = 19] = "LargeBinary";
      Type2[Type2["LargeUtf8"] = 20] = "LargeUtf8";
      Type2[Type2["Dictionary"] = -1] = "Dictionary";
      Type2[Type2["Int8"] = -2] = "Int8";
      Type2[Type2["Int16"] = -3] = "Int16";
      Type2[Type2["Int32"] = -4] = "Int32";
      Type2[Type2["Int64"] = -5] = "Int64";
      Type2[Type2["Uint8"] = -6] = "Uint8";
      Type2[Type2["Uint16"] = -7] = "Uint16";
      Type2[Type2["Uint32"] = -8] = "Uint32";
      Type2[Type2["Uint64"] = -9] = "Uint64";
      Type2[Type2["Float16"] = -10] = "Float16";
      Type2[Type2["Float32"] = -11] = "Float32";
      Type2[Type2["Float64"] = -12] = "Float64";
      Type2[Type2["DateDay"] = -13] = "DateDay";
      Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
      Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
      Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
      Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
      Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
      Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
      Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
      Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
      Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
      Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
      Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
      Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
      Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
      Type2[Type2["DurationSecond"] = -27] = "DurationSecond";
      Type2[Type2["DurationMillisecond"] = -28] = "DurationMillisecond";
      Type2[Type2["DurationMicrosecond"] = -29] = "DurationMicrosecond";
      Type2[Type2["DurationNanosecond"] = -30] = "DurationNanosecond";
    })(Type || (exports2.Type = Type = {}));
    var BufferType;
    (function(BufferType2) {
      BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
      BufferType2[BufferType2["DATA"] = 1] = "DATA";
      BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
      BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
    })(BufferType || (exports2.BufferType = BufferType = {}));
  }
});

// node_modules/apache-arrow/util/pretty.js
var require_pretty = __commonJS({
  "node_modules/apache-arrow/util/pretty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.valueToString = void 0;
    var undf = void 0;
    function valueToString(x) {
      if (x === null) {
        return "null";
      }
      if (x === undf) {
        return "undefined";
      }
      switch (typeof x) {
        case "number":
          return `${x}`;
        case "bigint":
          return `${x}`;
        case "string":
          return `"${x}"`;
      }
      if (typeof x[Symbol.toPrimitive] === "function") {
        return x[Symbol.toPrimitive]("string");
      }
      if (ArrayBuffer.isView(x)) {
        if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
          return `[${[...x].map((x2) => valueToString(x2))}]`;
        }
        return `[${x}]`;
      }
      return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
    }
    exports2.valueToString = valueToString;
  }
});

// node_modules/apache-arrow/util/bigint.js
var require_bigint = __commonJS({
  "node_modules/apache-arrow/util/bigint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.divideBigInts = exports2.bigIntToNumber = void 0;
    function bigIntToNumber(number) {
      if (typeof number === "bigint" && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {
        throw new TypeError(`${number} is not safe to convert to a number.`);
      }
      return Number(number);
    }
    exports2.bigIntToNumber = bigIntToNumber;
    function divideBigInts(number, divisor) {
      return bigIntToNumber(number / divisor) + bigIntToNumber(number % divisor) / bigIntToNumber(divisor);
    }
    exports2.divideBigInts = divideBigInts;
  }
});

// node_modules/apache-arrow/util/bn.js
var require_bn = __commonJS({
  "node_modules/apache-arrow/util/bn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BN = exports2.bigNumToBigInt = exports2.bigNumToString = exports2.bigNumToNumber = exports2.isArrowBigNumSymbol = void 0;
    var buffer_js_1 = require_buffer();
    var bigint_js_1 = require_bigint();
    exports2.isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
    function BigNum(x, ...xs) {
      if (xs.length === 0) {
        return Object.setPrototypeOf((0, buffer_js_1.toArrayBufferView)(this["TypedArray"], x), this.constructor.prototype);
      }
      return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
    }
    BigNum.prototype[exports2.isArrowBigNumSymbol] = true;
    BigNum.prototype.toJSON = function() {
      return `"${bigNumToString(this)}"`;
    };
    BigNum.prototype.valueOf = function(scale) {
      return bigNumToNumber(this, scale);
    };
    BigNum.prototype.toString = function() {
      return bigNumToString(this);
    };
    BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
      switch (hint) {
        case "number":
          return bigNumToNumber(this);
        case "string":
          return bigNumToString(this);
        case "default":
          return bigNumToBigInt(this);
      }
      return bigNumToString(this);
    };
    function SignedBigNum(...args) {
      return BigNum.apply(this, args);
    }
    function UnsignedBigNum(...args) {
      return BigNum.apply(this, args);
    }
    function DecimalBigNum(...args) {
      return BigNum.apply(this, args);
    }
    Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
    Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
    Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
    Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64Array });
    Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
    Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
    var TWO_TO_THE_64 = BigInt(4294967296) * BigInt(4294967296);
    var TWO_TO_THE_64_MINUS_1 = TWO_TO_THE_64 - BigInt(1);
    function bigNumToNumber(bn, scale) {
      const { buffer, byteOffset, byteLength, "signed": signed } = bn;
      const words = new BigUint64Array(buffer, byteOffset, byteLength / 8);
      const negative = signed && words.at(-1) & BigInt(1) << BigInt(63);
      let number = BigInt(0);
      let i = 0;
      if (negative) {
        for (const word of words) {
          number |= (word ^ TWO_TO_THE_64_MINUS_1) * (BigInt(1) << BigInt(64 * i++));
        }
        number *= BigInt(-1);
        number -= BigInt(1);
      } else {
        for (const word of words) {
          number |= word * (BigInt(1) << BigInt(64 * i++));
        }
      }
      if (typeof scale === "number") {
        const denominator = BigInt(Math.pow(10, scale));
        const quotient = number / denominator;
        const remainder = number % denominator;
        return (0, bigint_js_1.bigIntToNumber)(quotient) + (0, bigint_js_1.bigIntToNumber)(remainder) / (0, bigint_js_1.bigIntToNumber)(denominator);
      }
      return (0, bigint_js_1.bigIntToNumber)(number);
    }
    exports2.bigNumToNumber = bigNumToNumber;
    function bigNumToString(a) {
      if (a.byteLength === 8) {
        const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
        return `${bigIntArray[0]}`;
      }
      if (!a["signed"]) {
        return unsignedBigNumToString(a);
      }
      let array = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
      const highOrderWord = new Int16Array([array.at(-1)])[0];
      if (highOrderWord >= 0) {
        return unsignedBigNumToString(a);
      }
      array = array.slice();
      let carry = 1;
      for (let i = 0; i < array.length; i++) {
        const elem = array[i];
        const updated = ~elem + carry;
        array[i] = updated;
        carry &= elem === 0 ? 1 : 0;
      }
      const negated = unsignedBigNumToString(array);
      return `-${negated}`;
    }
    exports2.bigNumToString = bigNumToString;
    function bigNumToBigInt(a) {
      if (a.byteLength === 8) {
        const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
        return bigIntArray[0];
      } else {
        return bigNumToString(a);
      }
    }
    exports2.bigNumToBigInt = bigNumToBigInt;
    function unsignedBigNumToString(a) {
      let digits = "";
      const base64 = new Uint32Array(2);
      let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
      const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
      let i = -1;
      const n = base32.length - 1;
      do {
        for (base64[0] = base32[i = 0]; i < n; ) {
          base32[i++] = base64[1] = base64[0] / 10;
          base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
        }
        base32[i] = base64[1] = base64[0] / 10;
        base64[0] = base64[0] - base64[1] * 10;
        digits = `${base64[0]}${digits}`;
      } while (checks[0] || checks[1] || checks[2] || checks[3]);
      return digits !== null && digits !== void 0 ? digits : `0`;
    }
    var BN = class _BN {
      /** @nocollapse */
      static new(num, isSigned) {
        switch (isSigned) {
          case true:
            return new SignedBigNum(num);
          case false:
            return new UnsignedBigNum(num);
        }
        switch (num.constructor) {
          case Int8Array:
          case Int16Array:
          case Int32Array:
          case BigInt64Array:
            return new SignedBigNum(num);
        }
        if (num.byteLength === 16) {
          return new DecimalBigNum(num);
        }
        return new UnsignedBigNum(num);
      }
      /** @nocollapse */
      static signed(num) {
        return new SignedBigNum(num);
      }
      /** @nocollapse */
      static unsigned(num) {
        return new UnsignedBigNum(num);
      }
      /** @nocollapse */
      static decimal(num) {
        return new DecimalBigNum(num);
      }
      constructor(num, isSigned) {
        return _BN.new(num, isSigned);
      }
    };
    exports2.BN = BN;
  }
});

// node_modules/apache-arrow/type.js
var require_type2 = __commonJS({
  "node_modules/apache-arrow/type.js"(exports2) {
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    var _e;
    var _f;
    var _g;
    var _h;
    var _j;
    var _k;
    var _l;
    var _m;
    var _o;
    var _p;
    var _q;
    var _r;
    var _s;
    var _t;
    var _u;
    var _v;
    var _w;
    var _x;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Map_ = exports2.FixedSizeList = exports2.FixedSizeBinary = exports2.SparseUnion = exports2.DenseUnion = exports2.Union = exports2.Struct = exports2.List = exports2.DurationNanosecond = exports2.DurationMicrosecond = exports2.DurationMillisecond = exports2.DurationSecond = exports2.Duration = exports2.IntervalYearMonth = exports2.IntervalDayTime = exports2.Interval = exports2.TimestampNanosecond = exports2.TimestampMicrosecond = exports2.TimestampMillisecond = exports2.TimestampSecond = exports2.Timestamp = exports2.TimeNanosecond = exports2.TimeMicrosecond = exports2.TimeMillisecond = exports2.TimeSecond = exports2.Time = exports2.DateMillisecond = exports2.DateDay = exports2.Date_ = exports2.Decimal = exports2.Bool = exports2.LargeUtf8 = exports2.Utf8 = exports2.LargeBinary = exports2.Binary = exports2.Float64 = exports2.Float32 = exports2.Float16 = exports2.Float = exports2.Uint64 = exports2.Uint32 = exports2.Uint16 = exports2.Uint8 = exports2.Int64 = exports2.Int32 = exports2.Int16 = exports2.Int8 = exports2.Int = exports2.Null = exports2.DataType = void 0;
    exports2.strideForType = exports2.Dictionary = void 0;
    var bigint_js_1 = require_bigint();
    var enum_js_1 = require_enum();
    var DataType = class _DataType {
      /** @nocollapse */
      static isNull(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Null;
      }
      /** @nocollapse */
      static isInt(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Int;
      }
      /** @nocollapse */
      static isFloat(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Float;
      }
      /** @nocollapse */
      static isBinary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Binary;
      }
      /** @nocollapse */
      static isLargeBinary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.LargeBinary;
      }
      /** @nocollapse */
      static isUtf8(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Utf8;
      }
      /** @nocollapse */
      static isLargeUtf8(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.LargeUtf8;
      }
      /** @nocollapse */
      static isBool(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Bool;
      }
      /** @nocollapse */
      static isDecimal(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Decimal;
      }
      /** @nocollapse */
      static isDate(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Date;
      }
      /** @nocollapse */
      static isTime(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Time;
      }
      /** @nocollapse */
      static isTimestamp(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Timestamp;
      }
      /** @nocollapse */
      static isInterval(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Interval;
      }
      /** @nocollapse */
      static isDuration(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Duration;
      }
      /** @nocollapse */
      static isList(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.List;
      }
      /** @nocollapse */
      static isStruct(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Struct;
      }
      /** @nocollapse */
      static isUnion(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Union;
      }
      /** @nocollapse */
      static isFixedSizeBinary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeBinary;
      }
      /** @nocollapse */
      static isFixedSizeList(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeList;
      }
      /** @nocollapse */
      static isMap(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Map;
      }
      /** @nocollapse */
      static isDictionary(x) {
        return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Dictionary;
      }
      /** @nocollapse */
      static isDenseUnion(x) {
        return _DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Dense;
      }
      /** @nocollapse */
      static isSparseUnion(x) {
        return _DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Sparse;
      }
      constructor(typeId) {
        this.typeId = typeId;
      }
    };
    exports2.DataType = DataType;
    _a = Symbol.toStringTag;
    DataType[_a] = ((proto) => {
      proto.children = null;
      proto.ArrayType = Array;
      proto.OffsetArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "DataType";
    })(DataType.prototype);
    var Null = class extends DataType {
      constructor() {
        super(enum_js_1.Type.Null);
      }
      toString() {
        return `Null`;
      }
    };
    exports2.Null = Null;
    _b = Symbol.toStringTag;
    Null[_b] = ((proto) => proto[Symbol.toStringTag] = "Null")(Null.prototype);
    var Int_ = class extends DataType {
      constructor(isSigned, bitWidth) {
        super(enum_js_1.Type.Int);
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
      }
      get ArrayType() {
        switch (this.bitWidth) {
          case 8:
            return this.isSigned ? Int8Array : Uint8Array;
          case 16:
            return this.isSigned ? Int16Array : Uint16Array;
          case 32:
            return this.isSigned ? Int32Array : Uint32Array;
          case 64:
            return this.isSigned ? BigInt64Array : BigUint64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
      }
      toString() {
        return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
      }
    };
    exports2.Int = Int_;
    _c = Symbol.toStringTag;
    Int_[_c] = ((proto) => {
      proto.isSigned = null;
      proto.bitWidth = null;
      return proto[Symbol.toStringTag] = "Int";
    })(Int_.prototype);
    var Int8 = class extends Int_ {
      constructor() {
        super(true, 8);
      }
      get ArrayType() {
        return Int8Array;
      }
    };
    exports2.Int8 = Int8;
    var Int16 = class extends Int_ {
      constructor() {
        super(true, 16);
      }
      get ArrayType() {
        return Int16Array;
      }
    };
    exports2.Int16 = Int16;
    var Int32 = class extends Int_ {
      constructor() {
        super(true, 32);
      }
      get ArrayType() {
        return Int32Array;
      }
    };
    exports2.Int32 = Int32;
    var Int64 = class extends Int_ {
      constructor() {
        super(true, 64);
      }
      get ArrayType() {
        return BigInt64Array;
      }
    };
    exports2.Int64 = Int64;
    var Uint8 = class extends Int_ {
      constructor() {
        super(false, 8);
      }
      get ArrayType() {
        return Uint8Array;
      }
    };
    exports2.Uint8 = Uint8;
    var Uint16 = class extends Int_ {
      constructor() {
        super(false, 16);
      }
      get ArrayType() {
        return Uint16Array;
      }
    };
    exports2.Uint16 = Uint16;
    var Uint32 = class extends Int_ {
      constructor() {
        super(false, 32);
      }
      get ArrayType() {
        return Uint32Array;
      }
    };
    exports2.Uint32 = Uint32;
    var Uint64 = class extends Int_ {
      constructor() {
        super(false, 64);
      }
      get ArrayType() {
        return BigUint64Array;
      }
    };
    exports2.Uint64 = Uint64;
    Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
    Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
    Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
    Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64Array });
    Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
    Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
    Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
    Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64Array });
    var Float = class extends DataType {
      constructor(precision) {
        super(enum_js_1.Type.Float);
        this.precision = precision;
      }
      get ArrayType() {
        switch (this.precision) {
          case enum_js_1.Precision.HALF:
            return Uint16Array;
          case enum_js_1.Precision.SINGLE:
            return Float32Array;
          case enum_js_1.Precision.DOUBLE:
            return Float64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
      }
      toString() {
        return `Float${this.precision << 5 || 16}`;
      }
    };
    exports2.Float = Float;
    _d = Symbol.toStringTag;
    Float[_d] = ((proto) => {
      proto.precision = null;
      return proto[Symbol.toStringTag] = "Float";
    })(Float.prototype);
    var Float16 = class extends Float {
      constructor() {
        super(enum_js_1.Precision.HALF);
      }
    };
    exports2.Float16 = Float16;
    var Float32 = class extends Float {
      constructor() {
        super(enum_js_1.Precision.SINGLE);
      }
    };
    exports2.Float32 = Float32;
    var Float64 = class extends Float {
      constructor() {
        super(enum_js_1.Precision.DOUBLE);
      }
    };
    exports2.Float64 = Float64;
    Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
    Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
    Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });
    var Binary = class extends DataType {
      constructor() {
        super(enum_js_1.Type.Binary);
      }
      toString() {
        return `Binary`;
      }
    };
    exports2.Binary = Binary;
    _e = Symbol.toStringTag;
    Binary[_e] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Binary";
    })(Binary.prototype);
    var LargeBinary = class extends DataType {
      constructor() {
        super(enum_js_1.Type.LargeBinary);
      }
      toString() {
        return `LargeBinary`;
      }
    };
    exports2.LargeBinary = LargeBinary;
    _f = Symbol.toStringTag;
    LargeBinary[_f] = ((proto) => {
      proto.ArrayType = Uint8Array;
      proto.OffsetArrayType = BigInt64Array;
      return proto[Symbol.toStringTag] = "LargeBinary";
    })(LargeBinary.prototype);
    var Utf8 = class extends DataType {
      constructor() {
        super(enum_js_1.Type.Utf8);
      }
      toString() {
        return `Utf8`;
      }
    };
    exports2.Utf8 = Utf8;
    _g = Symbol.toStringTag;
    Utf8[_g] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Utf8";
    })(Utf8.prototype);
    var LargeUtf8 = class extends DataType {
      constructor() {
        super(enum_js_1.Type.LargeUtf8);
      }
      toString() {
        return `LargeUtf8`;
      }
    };
    exports2.LargeUtf8 = LargeUtf8;
    _h = Symbol.toStringTag;
    LargeUtf8[_h] = ((proto) => {
      proto.ArrayType = Uint8Array;
      proto.OffsetArrayType = BigInt64Array;
      return proto[Symbol.toStringTag] = "LargeUtf8";
    })(LargeUtf8.prototype);
    var Bool = class extends DataType {
      constructor() {
        super(enum_js_1.Type.Bool);
      }
      toString() {
        return `Bool`;
      }
    };
    exports2.Bool = Bool;
    _j = Symbol.toStringTag;
    Bool[_j] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Bool";
    })(Bool.prototype);
    var Decimal = class extends DataType {
      constructor(scale, precision, bitWidth = 128) {
        super(enum_js_1.Type.Decimal);
        this.scale = scale;
        this.precision = precision;
        this.bitWidth = bitWidth;
      }
      toString() {
        return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
      }
    };
    exports2.Decimal = Decimal;
    _k = Symbol.toStringTag;
    Decimal[_k] = ((proto) => {
      proto.scale = null;
      proto.precision = null;
      proto.ArrayType = Uint32Array;
      return proto[Symbol.toStringTag] = "Decimal";
    })(Decimal.prototype);
    var Date_ = class extends DataType {
      constructor(unit) {
        super(enum_js_1.Type.Date);
        this.unit = unit;
      }
      toString() {
        return `Date${(this.unit + 1) * 32}<${enum_js_1.DateUnit[this.unit]}>`;
      }
      get ArrayType() {
        return this.unit === enum_js_1.DateUnit.DAY ? Int32Array : BigInt64Array;
      }
    };
    exports2.Date_ = Date_;
    _l = Symbol.toStringTag;
    Date_[_l] = ((proto) => {
      proto.unit = null;
      return proto[Symbol.toStringTag] = "Date";
    })(Date_.prototype);
    var DateDay = class extends Date_ {
      constructor() {
        super(enum_js_1.DateUnit.DAY);
      }
    };
    exports2.DateDay = DateDay;
    var DateMillisecond = class extends Date_ {
      constructor() {
        super(enum_js_1.DateUnit.MILLISECOND);
      }
    };
    exports2.DateMillisecond = DateMillisecond;
    var Time_ = class extends DataType {
      constructor(unit, bitWidth) {
        super(enum_js_1.Type.Time);
        this.unit = unit;
        this.bitWidth = bitWidth;
      }
      toString() {
        return `Time${this.bitWidth}<${enum_js_1.TimeUnit[this.unit]}>`;
      }
      get ArrayType() {
        switch (this.bitWidth) {
          case 32:
            return Int32Array;
          case 64:
            return BigInt64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
      }
    };
    exports2.Time = Time_;
    _m = Symbol.toStringTag;
    Time_[_m] = ((proto) => {
      proto.unit = null;
      proto.bitWidth = null;
      return proto[Symbol.toStringTag] = "Time";
    })(Time_.prototype);
    var TimeSecond = class extends Time_ {
      constructor() {
        super(enum_js_1.TimeUnit.SECOND, 32);
      }
    };
    exports2.TimeSecond = TimeSecond;
    var TimeMillisecond = class extends Time_ {
      constructor() {
        super(enum_js_1.TimeUnit.MILLISECOND, 32);
      }
    };
    exports2.TimeMillisecond = TimeMillisecond;
    var TimeMicrosecond = class extends Time_ {
      constructor() {
        super(enum_js_1.TimeUnit.MICROSECOND, 64);
      }
    };
    exports2.TimeMicrosecond = TimeMicrosecond;
    var TimeNanosecond = class extends Time_ {
      constructor() {
        super(enum_js_1.TimeUnit.NANOSECOND, 64);
      }
    };
    exports2.TimeNanosecond = TimeNanosecond;
    var Timestamp_ = class extends DataType {
      constructor(unit, timezone) {
        super(enum_js_1.Type.Timestamp);
        this.unit = unit;
        this.timezone = timezone;
      }
      toString() {
        return `Timestamp<${enum_js_1.TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
      }
    };
    exports2.Timestamp = Timestamp_;
    _o = Symbol.toStringTag;
    Timestamp_[_o] = ((proto) => {
      proto.unit = null;
      proto.timezone = null;
      proto.ArrayType = BigInt64Array;
      return proto[Symbol.toStringTag] = "Timestamp";
    })(Timestamp_.prototype);
    var TimestampSecond = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_js_1.TimeUnit.SECOND, timezone);
      }
    };
    exports2.TimestampSecond = TimestampSecond;
    var TimestampMillisecond = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_js_1.TimeUnit.MILLISECOND, timezone);
      }
    };
    exports2.TimestampMillisecond = TimestampMillisecond;
    var TimestampMicrosecond = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_js_1.TimeUnit.MICROSECOND, timezone);
      }
    };
    exports2.TimestampMicrosecond = TimestampMicrosecond;
    var TimestampNanosecond = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_js_1.TimeUnit.NANOSECOND, timezone);
      }
    };
    exports2.TimestampNanosecond = TimestampNanosecond;
    var Interval_ = class extends DataType {
      constructor(unit) {
        super(enum_js_1.Type.Interval);
        this.unit = unit;
      }
      toString() {
        return `Interval<${enum_js_1.IntervalUnit[this.unit]}>`;
      }
    };
    exports2.Interval = Interval_;
    _p = Symbol.toStringTag;
    Interval_[_p] = ((proto) => {
      proto.unit = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Interval";
    })(Interval_.prototype);
    var IntervalDayTime = class extends Interval_ {
      constructor() {
        super(enum_js_1.IntervalUnit.DAY_TIME);
      }
    };
    exports2.IntervalDayTime = IntervalDayTime;
    var IntervalYearMonth = class extends Interval_ {
      constructor() {
        super(enum_js_1.IntervalUnit.YEAR_MONTH);
      }
    };
    exports2.IntervalYearMonth = IntervalYearMonth;
    var Duration = class extends DataType {
      constructor(unit) {
        super(enum_js_1.Type.Duration);
        this.unit = unit;
      }
      toString() {
        return `Duration<${enum_js_1.TimeUnit[this.unit]}>`;
      }
    };
    exports2.Duration = Duration;
    _q = Symbol.toStringTag;
    Duration[_q] = ((proto) => {
      proto.unit = null;
      proto.ArrayType = BigInt64Array;
      return proto[Symbol.toStringTag] = "Duration";
    })(Duration.prototype);
    var DurationSecond = class extends Duration {
      constructor() {
        super(enum_js_1.TimeUnit.SECOND);
      }
    };
    exports2.DurationSecond = DurationSecond;
    var DurationMillisecond = class extends Duration {
      constructor() {
        super(enum_js_1.TimeUnit.MILLISECOND);
      }
    };
    exports2.DurationMillisecond = DurationMillisecond;
    var DurationMicrosecond = class extends Duration {
      constructor() {
        super(enum_js_1.TimeUnit.MICROSECOND);
      }
    };
    exports2.DurationMicrosecond = DurationMicrosecond;
    var DurationNanosecond = class extends Duration {
      constructor() {
        super(enum_js_1.TimeUnit.NANOSECOND);
      }
    };
    exports2.DurationNanosecond = DurationNanosecond;
    var List = class extends DataType {
      constructor(child) {
        super(enum_js_1.Type.List);
        this.children = [child];
      }
      toString() {
        return `List<${this.valueType}>`;
      }
      get valueType() {
        return this.children[0].type;
      }
      get valueField() {
        return this.children[0];
      }
      get ArrayType() {
        return this.valueType.ArrayType;
      }
    };
    exports2.List = List;
    _r = Symbol.toStringTag;
    List[_r] = ((proto) => {
      proto.children = null;
      return proto[Symbol.toStringTag] = "List";
    })(List.prototype);
    var Struct = class extends DataType {
      constructor(children) {
        super(enum_js_1.Type.Struct);
        this.children = children;
      }
      toString() {
        return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
      }
    };
    exports2.Struct = Struct;
    _s = Symbol.toStringTag;
    Struct[_s] = ((proto) => {
      proto.children = null;
      return proto[Symbol.toStringTag] = "Struct";
    })(Struct.prototype);
    var Union_ = class extends DataType {
      constructor(mode, typeIds, children) {
        super(enum_js_1.Type.Union);
        this.mode = mode;
        this.children = children;
        this.typeIds = typeIds = Int32Array.from(typeIds);
        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
      }
      toString() {
        return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
      }
    };
    exports2.Union = Union_;
    _t = Symbol.toStringTag;
    Union_[_t] = ((proto) => {
      proto.mode = null;
      proto.typeIds = null;
      proto.children = null;
      proto.typeIdToChildIndex = null;
      proto.ArrayType = Int8Array;
      return proto[Symbol.toStringTag] = "Union";
    })(Union_.prototype);
    var DenseUnion = class extends Union_ {
      constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Dense, typeIds, children);
      }
    };
    exports2.DenseUnion = DenseUnion;
    var SparseUnion = class extends Union_ {
      constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Sparse, typeIds, children);
      }
    };
    exports2.SparseUnion = SparseUnion;
    var FixedSizeBinary = class extends DataType {
      constructor(byteWidth) {
        super(enum_js_1.Type.FixedSizeBinary);
        this.byteWidth = byteWidth;
      }
      toString() {
        return `FixedSizeBinary[${this.byteWidth}]`;
      }
    };
    exports2.FixedSizeBinary = FixedSizeBinary;
    _u = Symbol.toStringTag;
    FixedSizeBinary[_u] = ((proto) => {
      proto.byteWidth = null;
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "FixedSizeBinary";
    })(FixedSizeBinary.prototype);
    var FixedSizeList = class extends DataType {
      constructor(listSize, child) {
        super(enum_js_1.Type.FixedSizeList);
        this.listSize = listSize;
        this.children = [child];
      }
      get valueType() {
        return this.children[0].type;
      }
      get valueField() {
        return this.children[0];
      }
      get ArrayType() {
        return this.valueType.ArrayType;
      }
      toString() {
        return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
      }
    };
    exports2.FixedSizeList = FixedSizeList;
    _v = Symbol.toStringTag;
    FixedSizeList[_v] = ((proto) => {
      proto.children = null;
      proto.listSize = null;
      return proto[Symbol.toStringTag] = "FixedSizeList";
    })(FixedSizeList.prototype);
    var Map_ = class extends DataType {
      constructor(entries, keysSorted = false) {
        var _y, _z, _0;
        super(enum_js_1.Type.Map);
        this.children = [entries];
        this.keysSorted = keysSorted;
        if (entries) {
          entries["name"] = "entries";
          if ((_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children) {
            const key = (_z = entries === null || entries === void 0 ? void 0 : entries.type) === null || _z === void 0 ? void 0 : _z.children[0];
            if (key) {
              key["name"] = "key";
            }
            const val = (_0 = entries === null || entries === void 0 ? void 0 : entries.type) === null || _0 === void 0 ? void 0 : _0.children[1];
            if (val) {
              val["name"] = "value";
            }
          }
        }
      }
      get keyType() {
        return this.children[0].type.children[0].type;
      }
      get valueType() {
        return this.children[0].type.children[1].type;
      }
      get childType() {
        return this.children[0].type;
      }
      toString() {
        return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
      }
    };
    exports2.Map_ = Map_;
    _w = Symbol.toStringTag;
    Map_[_w] = ((proto) => {
      proto.children = null;
      proto.keysSorted = null;
      return proto[Symbol.toStringTag] = "Map_";
    })(Map_.prototype);
    var getId = /* @__PURE__ */ ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
    var Dictionary = class extends DataType {
      constructor(dictionary, indices, id, isOrdered) {
        super(enum_js_1.Type.Dictionary);
        this.indices = indices;
        this.dictionary = dictionary;
        this.isOrdered = isOrdered || false;
        this.id = id == null ? getId() : (0, bigint_js_1.bigIntToNumber)(id);
      }
      get children() {
        return this.dictionary.children;
      }
      get valueType() {
        return this.dictionary;
      }
      get ArrayType() {
        return this.dictionary.ArrayType;
      }
      toString() {
        return `Dictionary<${this.indices}, ${this.dictionary}>`;
      }
    };
    exports2.Dictionary = Dictionary;
    _x = Symbol.toStringTag;
    Dictionary[_x] = ((proto) => {
      proto.id = null;
      proto.indices = null;
      proto.isOrdered = null;
      proto.dictionary = null;
      return proto[Symbol.toStringTag] = "Dictionary";
    })(Dictionary.prototype);
    function strideForType(type) {
      const t = type;
      switch (type.typeId) {
        case enum_js_1.Type.Decimal:
          return type.bitWidth / 32;
        case enum_js_1.Type.Interval:
          return 1 + t.unit;
        // case Type.Int: return 1 + +((t as Int_).bitWidth > 32);
        // case Type.Time: return 1 + +((t as Time_).bitWidth > 32);
        case enum_js_1.Type.FixedSizeList:
          return t.listSize;
        case enum_js_1.Type.FixedSizeBinary:
          return t.byteWidth;
        default:
          return 1;
      }
    }
    exports2.strideForType = strideForType;
  }
});

// node_modules/apache-arrow/visitor.js
var require_visitor = __commonJS({
  "node_modules/apache-arrow/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Visitor = void 0;
    var enum_js_1 = require_enum();
    var type_js_1 = require_type2();
    var Visitor = class {
      visitMany(nodes, ...args) {
        return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
      }
      visit(...args) {
        return this.getVisitFn(args[0], false).apply(this, args);
      }
      getVisitFn(node, throwIfNotFound = true) {
        return getVisitFn(this, node, throwIfNotFound);
      }
      getVisitFnByTypeId(typeId, throwIfNotFound = true) {
        return getVisitFnByTypeId(this, typeId, throwIfNotFound);
      }
      visitNull(_node, ..._args) {
        return null;
      }
      visitBool(_node, ..._args) {
        return null;
      }
      visitInt(_node, ..._args) {
        return null;
      }
      visitFloat(_node, ..._args) {
        return null;
      }
      visitUtf8(_node, ..._args) {
        return null;
      }
      visitLargeUtf8(_node, ..._args) {
        return null;
      }
      visitBinary(_node, ..._args) {
        return null;
      }
      visitLargeBinary(_node, ..._args) {
        return null;
      }
      visitFixedSizeBinary(_node, ..._args) {
        return null;
      }
      visitDate(_node, ..._args) {
        return null;
      }
      visitTimestamp(_node, ..._args) {
        return null;
      }
      visitTime(_node, ..._args) {
        return null;
      }
      visitDecimal(_node, ..._args) {
        return null;
      }
      visitList(_node, ..._args) {
        return null;
      }
      visitStruct(_node, ..._args) {
        return null;
      }
      visitUnion(_node, ..._args) {
        return null;
      }
      visitDictionary(_node, ..._args) {
        return null;
      }
      visitInterval(_node, ..._args) {
        return null;
      }
      visitDuration(_node, ..._args) {
        return null;
      }
      visitFixedSizeList(_node, ..._args) {
        return null;
      }
      visitMap(_node, ..._args) {
        return null;
      }
    };
    exports2.Visitor = Visitor;
    function getVisitFn(visitor, node, throwIfNotFound = true) {
      if (typeof node === "number") {
        return getVisitFnByTypeId(visitor, node, throwIfNotFound);
      }
      if (typeof node === "string" && node in enum_js_1.Type) {
        return getVisitFnByTypeId(visitor, enum_js_1.Type[node], throwIfNotFound);
      }
      if (node && node instanceof type_js_1.DataType) {
        return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
      }
      if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof type_js_1.DataType) {
        return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
      }
      return getVisitFnByTypeId(visitor, enum_js_1.Type.NONE, throwIfNotFound);
    }
    function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
      let fn = null;
      switch (dtype) {
        case enum_js_1.Type.Null:
          fn = visitor.visitNull;
          break;
        case enum_js_1.Type.Bool:
          fn = visitor.visitBool;
          break;
        case enum_js_1.Type.Int:
          fn = visitor.visitInt;
          break;
        case enum_js_1.Type.Int8:
          fn = visitor.visitInt8 || visitor.visitInt;
          break;
        case enum_js_1.Type.Int16:
          fn = visitor.visitInt16 || visitor.visitInt;
          break;
        case enum_js_1.Type.Int32:
          fn = visitor.visitInt32 || visitor.visitInt;
          break;
        case enum_js_1.Type.Int64:
          fn = visitor.visitInt64 || visitor.visitInt;
          break;
        case enum_js_1.Type.Uint8:
          fn = visitor.visitUint8 || visitor.visitInt;
          break;
        case enum_js_1.Type.Uint16:
          fn = visitor.visitUint16 || visitor.visitInt;
          break;
        case enum_js_1.Type.Uint32:
          fn = visitor.visitUint32 || visitor.visitInt;
          break;
        case enum_js_1.Type.Uint64:
          fn = visitor.visitUint64 || visitor.visitInt;
          break;
        case enum_js_1.Type.Float:
          fn = visitor.visitFloat;
          break;
        case enum_js_1.Type.Float16:
          fn = visitor.visitFloat16 || visitor.visitFloat;
          break;
        case enum_js_1.Type.Float32:
          fn = visitor.visitFloat32 || visitor.visitFloat;
          break;
        case enum_js_1.Type.Float64:
          fn = visitor.visitFloat64 || visitor.visitFloat;
          break;
        case enum_js_1.Type.Utf8:
          fn = visitor.visitUtf8;
          break;
        case enum_js_1.Type.LargeUtf8:
          fn = visitor.visitLargeUtf8;
          break;
        case enum_js_1.Type.Binary:
          fn = visitor.visitBinary;
          break;
        case enum_js_1.Type.LargeBinary:
          fn = visitor.visitLargeBinary;
          break;
        case enum_js_1.Type.FixedSizeBinary:
          fn = visitor.visitFixedSizeBinary;
          break;
        case enum_js_1.Type.Date:
          fn = visitor.visitDate;
          break;
        case enum_js_1.Type.DateDay:
          fn = visitor.visitDateDay || visitor.visitDate;
          break;
        case enum_js_1.Type.DateMillisecond:
          fn = visitor.visitDateMillisecond || visitor.visitDate;
          break;
        case enum_js_1.Type.Timestamp:
          fn = visitor.visitTimestamp;
          break;
        case enum_js_1.Type.TimestampSecond:
          fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
          break;
        case enum_js_1.Type.TimestampMillisecond:
          fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
          break;
        case enum_js_1.Type.TimestampMicrosecond:
          fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
          break;
        case enum_js_1.Type.TimestampNanosecond:
          fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
          break;
        case enum_js_1.Type.Time:
          fn = visitor.visitTime;
          break;
        case enum_js_1.Type.TimeSecond:
          fn = visitor.visitTimeSecond || visitor.visitTime;
          break;
        case enum_js_1.Type.TimeMillisecond:
          fn = visitor.visitTimeMillisecond || visitor.visitTime;
          break;
        case enum_js_1.Type.TimeMicrosecond:
          fn = visitor.visitTimeMicrosecond || visitor.visitTime;
          break;
        case enum_js_1.Type.TimeNanosecond:
          fn = visitor.visitTimeNanosecond || visitor.visitTime;
          break;
        case enum_js_1.Type.Decimal:
          fn = visitor.visitDecimal;
          break;
        case enum_js_1.Type.List:
          fn = visitor.visitList;
          break;
        case enum_js_1.Type.Struct:
          fn = visitor.visitStruct;
          break;
        case enum_js_1.Type.Union:
          fn = visitor.visitUnion;
          break;
        case enum_js_1.Type.DenseUnion:
          fn = visitor.visitDenseUnion || visitor.visitUnion;
          break;
        case enum_js_1.Type.SparseUnion:
          fn = visitor.visitSparseUnion || visitor.visitUnion;
          break;
        case enum_js_1.Type.Dictionary:
          fn = visitor.visitDictionary;
          break;
        case enum_js_1.Type.Interval:
          fn = visitor.visitInterval;
          break;
        case enum_js_1.Type.IntervalDayTime:
          fn = visitor.visitIntervalDayTime || visitor.visitInterval;
          break;
        case enum_js_1.Type.IntervalYearMonth:
          fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
          break;
        case enum_js_1.Type.Duration:
          fn = visitor.visitDuration;
          break;
        case enum_js_1.Type.DurationSecond:
          fn = visitor.visitDurationSecond || visitor.visitDuration;
          break;
        case enum_js_1.Type.DurationMillisecond:
          fn = visitor.visitDurationMillisecond || visitor.visitDuration;
          break;
        case enum_js_1.Type.DurationMicrosecond:
          fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
          break;
        case enum_js_1.Type.DurationNanosecond:
          fn = visitor.visitDurationNanosecond || visitor.visitDuration;
          break;
        case enum_js_1.Type.FixedSizeList:
          fn = visitor.visitFixedSizeList;
          break;
        case enum_js_1.Type.Map:
          fn = visitor.visitMap;
          break;
      }
      if (typeof fn === "function")
        return fn;
      if (!throwIfNotFound)
        return () => null;
      throw new Error(`Unrecognized type '${enum_js_1.Type[dtype]}'`);
    }
    function inferDType(type) {
      switch (type.typeId) {
        case enum_js_1.Type.Null:
          return enum_js_1.Type.Null;
        case enum_js_1.Type.Int: {
          const { bitWidth, isSigned } = type;
          switch (bitWidth) {
            case 8:
              return isSigned ? enum_js_1.Type.Int8 : enum_js_1.Type.Uint8;
            case 16:
              return isSigned ? enum_js_1.Type.Int16 : enum_js_1.Type.Uint16;
            case 32:
              return isSigned ? enum_js_1.Type.Int32 : enum_js_1.Type.Uint32;
            case 64:
              return isSigned ? enum_js_1.Type.Int64 : enum_js_1.Type.Uint64;
          }
          return enum_js_1.Type.Int;
        }
        case enum_js_1.Type.Float:
          switch (type.precision) {
            case enum_js_1.Precision.HALF:
              return enum_js_1.Type.Float16;
            case enum_js_1.Precision.SINGLE:
              return enum_js_1.Type.Float32;
            case enum_js_1.Precision.DOUBLE:
              return enum_js_1.Type.Float64;
          }
          return enum_js_1.Type.Float;
        case enum_js_1.Type.Binary:
          return enum_js_1.Type.Binary;
        case enum_js_1.Type.LargeBinary:
          return enum_js_1.Type.LargeBinary;
        case enum_js_1.Type.Utf8:
          return enum_js_1.Type.Utf8;
        case enum_js_1.Type.LargeUtf8:
          return enum_js_1.Type.LargeUtf8;
        case enum_js_1.Type.Bool:
          return enum_js_1.Type.Bool;
        case enum_js_1.Type.Decimal:
          return enum_js_1.Type.Decimal;
        case enum_js_1.Type.Time:
          switch (type.unit) {
            case enum_js_1.TimeUnit.SECOND:
              return enum_js_1.Type.TimeSecond;
            case enum_js_1.TimeUnit.MILLISECOND:
              return enum_js_1.Type.TimeMillisecond;
            case enum_js_1.TimeUnit.MICROSECOND:
              return enum_js_1.Type.TimeMicrosecond;
            case enum_js_1.TimeUnit.NANOSECOND:
              return enum_js_1.Type.TimeNanosecond;
          }
          return enum_js_1.Type.Time;
        case enum_js_1.Type.Timestamp:
          switch (type.unit) {
            case enum_js_1.TimeUnit.SECOND:
              return enum_js_1.Type.TimestampSecond;
            case enum_js_1.TimeUnit.MILLISECOND:
              return enum_js_1.Type.TimestampMillisecond;
            case enum_js_1.TimeUnit.MICROSECOND:
              return enum_js_1.Type.TimestampMicrosecond;
            case enum_js_1.TimeUnit.NANOSECOND:
              return enum_js_1.Type.TimestampNanosecond;
          }
          return enum_js_1.Type.Timestamp;
        case enum_js_1.Type.Date:
          switch (type.unit) {
            case enum_js_1.DateUnit.DAY:
              return enum_js_1.Type.DateDay;
            case enum_js_1.DateUnit.MILLISECOND:
              return enum_js_1.Type.DateMillisecond;
          }
          return enum_js_1.Type.Date;
        case enum_js_1.Type.Interval:
          switch (type.unit) {
            case enum_js_1.IntervalUnit.DAY_TIME:
              return enum_js_1.Type.IntervalDayTime;
            case enum_js_1.IntervalUnit.YEAR_MONTH:
              return enum_js_1.Type.IntervalYearMonth;
          }
          return enum_js_1.Type.Interval;
        case enum_js_1.Type.Duration:
          switch (type.unit) {
            case enum_js_1.TimeUnit.SECOND:
              return enum_js_1.Type.DurationSecond;
            case enum_js_1.TimeUnit.MILLISECOND:
              return enum_js_1.Type.DurationMillisecond;
            case enum_js_1.TimeUnit.MICROSECOND:
              return enum_js_1.Type.DurationMicrosecond;
            case enum_js_1.TimeUnit.NANOSECOND:
              return enum_js_1.Type.DurationNanosecond;
          }
          return enum_js_1.Type.Duration;
        case enum_js_1.Type.Map:
          return enum_js_1.Type.Map;
        case enum_js_1.Type.List:
          return enum_js_1.Type.List;
        case enum_js_1.Type.Struct:
          return enum_js_1.Type.Struct;
        case enum_js_1.Type.Union:
          switch (type.mode) {
            case enum_js_1.UnionMode.Dense:
              return enum_js_1.Type.DenseUnion;
            case enum_js_1.UnionMode.Sparse:
              return enum_js_1.Type.SparseUnion;
          }
          return enum_js_1.Type.Union;
        case enum_js_1.Type.FixedSizeBinary:
          return enum_js_1.Type.FixedSizeBinary;
        case enum_js_1.Type.FixedSizeList:
          return enum_js_1.Type.FixedSizeList;
        case enum_js_1.Type.Dictionary:
          return enum_js_1.Type.Dictionary;
      }
      throw new Error(`Unrecognized type '${enum_js_1.Type[type.typeId]}'`);
    }
    Visitor.prototype.visitInt8 = null;
    Visitor.prototype.visitInt16 = null;
    Visitor.prototype.visitInt32 = null;
    Visitor.prototype.visitInt64 = null;
    Visitor.prototype.visitUint8 = null;
    Visitor.prototype.visitUint16 = null;
    Visitor.prototype.visitUint32 = null;
    Visitor.prototype.visitUint64 = null;
    Visitor.prototype.visitFloat16 = null;
    Visitor.prototype.visitFloat32 = null;
    Visitor.prototype.visitFloat64 = null;
    Visitor.prototype.visitDateDay = null;
    Visitor.prototype.visitDateMillisecond = null;
    Visitor.prototype.visitTimestampSecond = null;
    Visitor.prototype.visitTimestampMillisecond = null;
    Visitor.prototype.visitTimestampMicrosecond = null;
    Visitor.prototype.visitTimestampNanosecond = null;
    Visitor.prototype.visitTimeSecond = null;
    Visitor.prototype.visitTimeMillisecond = null;
    Visitor.prototype.visitTimeMicrosecond = null;
    Visitor.prototype.visitTimeNanosecond = null;
    Visitor.prototype.visitDenseUnion = null;
    Visitor.prototype.visitSparseUnion = null;
    Visitor.prototype.visitIntervalDayTime = null;
    Visitor.prototype.visitIntervalYearMonth = null;
    Visitor.prototype.visitDuration = null;
    Visitor.prototype.visitDurationSecond = null;
    Visitor.prototype.visitDurationMillisecond = null;
    Visitor.prototype.visitDurationMicrosecond = null;
    Visitor.prototype.visitDurationNanosecond = null;
  }
});

// node_modules/apache-arrow/util/math.js
var require_math = __commonJS({
  "node_modules/apache-arrow/util/math.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.float64ToUint16 = exports2.uint16ToFloat64 = void 0;
    var f64 = new Float64Array(1);
    var u32 = new Uint32Array(f64.buffer);
    function uint16ToFloat64(h) {
      const expo = (h & 31744) >> 10;
      const sigf = (h & 1023) / 1024;
      const sign = Math.pow(-1, (h & 32768) >> 15);
      switch (expo) {
        case 31:
          return sign * (sigf ? Number.NaN : 1 / 0);
        case 0:
          return sign * (sigf ? 6103515625e-14 * sigf : 0);
      }
      return sign * Math.pow(2, expo - 15) * (1 + sigf);
    }
    exports2.uint16ToFloat64 = uint16ToFloat64;
    function float64ToUint16(d) {
      if (d !== d) {
        return 32256;
      }
      f64[0] = d;
      const sign = (u32[1] & 2147483648) >> 16 & 65535;
      let expo = u32[1] & 2146435072, sigf = 0;
      if (expo >= 1089470464) {
        if (u32[0] > 0) {
          expo = 31744;
        } else {
          expo = (expo & 2080374784) >> 16;
          sigf = (u32[1] & 1048575) >> 10;
        }
      } else if (expo <= 1056964608) {
        sigf = 1048576 + (u32[1] & 1048575);
        sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
        expo = 0;
      } else {
        expo = expo - 1056964608 >> 10;
        sigf = (u32[1] & 1048575) + 512 >> 10;
      }
      return sign | expo | sigf & 65535;
    }
    exports2.float64ToUint16 = float64ToUint16;
  }
});

// node_modules/apache-arrow/visitor/set.js
var require_set = __commonJS({
  "node_modules/apache-arrow/visitor/set.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instance = exports2.setDuration = exports2.setDurationNanosecond = exports2.setDurationMicrosecond = exports2.setDurationMillisecond = exports2.setDurationSecond = exports2.setIntervalYearMonth = exports2.setIntervalDayTime = exports2.setIntervalValue = exports2.setDecimal = exports2.setTime = exports2.setTimeNanosecond = exports2.setTimeMicrosecond = exports2.setTimeMillisecond = exports2.setTimeSecond = exports2.setTimestamp = exports2.setTimestampNanosecond = exports2.setTimestampMicrosecond = exports2.setTimestampMillisecond = exports2.setTimestampSecond = exports2.setDate = exports2.setFixedSizeBinary = exports2.setDateMillisecond = exports2.setDateDay = exports2.setAnyFloat = exports2.setFloat16 = exports2.setFloat = exports2.setInt = exports2.setVariableWidthBytes = exports2.setEpochMsToDays = exports2.SetVisitor = void 0;
    var vector_js_1 = require_vector2();
    var visitor_js_1 = require_visitor();
    var bigint_js_1 = require_bigint();
    var utf8_js_1 = require_utf8();
    var math_js_1 = require_math();
    var enum_js_1 = require_enum();
    var SetVisitor = class extends visitor_js_1.Visitor {
    };
    exports2.SetVisitor = SetVisitor;
    function wrapSet(fn) {
      return (data, _1, _2) => {
        if (data.setValid(_1, _2 != null)) {
          return fn(data, _1, _2);
        }
      };
    }
    var setEpochMsToDays = (data, index, epochMs) => {
      data[index] = Math.floor(epochMs / 864e5);
    };
    exports2.setEpochMsToDays = setEpochMsToDays;
    var setVariableWidthBytes = (values, valueOffsets, index, value) => {
      if (index + 1 < valueOffsets.length) {
        const x = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index]);
        const y = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index + 1]);
        values.set(value.subarray(0, y - x), x);
      }
    };
    exports2.setVariableWidthBytes = setVariableWidthBytes;
    var setBool = ({ offset, values }, index, val) => {
      const idx = offset + index;
      val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8);
    };
    var setInt = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setInt = setInt;
    var setFloat = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setFloat = setFloat;
    var setFloat16 = ({ values }, index, value) => {
      values[index] = (0, math_js_1.float64ToUint16)(value);
    };
    exports2.setFloat16 = setFloat16;
    var setAnyFloat = (data, index, value) => {
      switch (data.type.precision) {
        case enum_js_1.Precision.HALF:
          return (0, exports2.setFloat16)(data, index, value);
        case enum_js_1.Precision.SINGLE:
        case enum_js_1.Precision.DOUBLE:
          return (0, exports2.setFloat)(data, index, value);
      }
    };
    exports2.setAnyFloat = setAnyFloat;
    var setDateDay = ({ values }, index, value) => {
      (0, exports2.setEpochMsToDays)(values, index, value.valueOf());
    };
    exports2.setDateDay = setDateDay;
    var setDateMillisecond = ({ values }, index, value) => {
      values[index] = BigInt(value);
    };
    exports2.setDateMillisecond = setDateMillisecond;
    var setFixedSizeBinary = ({ stride, values }, index, value) => {
      values.set(value.subarray(0, stride), stride * index);
    };
    exports2.setFixedSizeBinary = setFixedSizeBinary;
    var setBinary = ({ values, valueOffsets }, index, value) => (0, exports2.setVariableWidthBytes)(values, valueOffsets, index, value);
    var setUtf8 = ({ values, valueOffsets }, index, value) => (0, exports2.setVariableWidthBytes)(values, valueOffsets, index, (0, utf8_js_1.encodeUtf8)(value));
    var setDate = (data, index, value) => {
      data.type.unit === enum_js_1.DateUnit.DAY ? (0, exports2.setDateDay)(data, index, value) : (0, exports2.setDateMillisecond)(data, index, value);
    };
    exports2.setDate = setDate;
    var setTimestampSecond = ({ values }, index, value) => {
      values[index] = BigInt(value / 1e3);
    };
    exports2.setTimestampSecond = setTimestampSecond;
    var setTimestampMillisecond = ({ values }, index, value) => {
      values[index] = BigInt(value);
    };
    exports2.setTimestampMillisecond = setTimestampMillisecond;
    var setTimestampMicrosecond = ({ values }, index, value) => {
      values[index] = BigInt(value * 1e3);
    };
    exports2.setTimestampMicrosecond = setTimestampMicrosecond;
    var setTimestampNanosecond = ({ values }, index, value) => {
      values[index] = BigInt(value * 1e6);
    };
    exports2.setTimestampNanosecond = setTimestampNanosecond;
    var setTimestamp = (data, index, value) => {
      switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND:
          return (0, exports2.setTimestampSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND:
          return (0, exports2.setTimestampMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND:
          return (0, exports2.setTimestampMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND:
          return (0, exports2.setTimestampNanosecond)(data, index, value);
      }
    };
    exports2.setTimestamp = setTimestamp;
    var setTimeSecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setTimeSecond = setTimeSecond;
    var setTimeMillisecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setTimeMillisecond = setTimeMillisecond;
    var setTimeMicrosecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setTimeMicrosecond = setTimeMicrosecond;
    var setTimeNanosecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setTimeNanosecond = setTimeNanosecond;
    var setTime = (data, index, value) => {
      switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND:
          return (0, exports2.setTimeSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND:
          return (0, exports2.setTimeMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND:
          return (0, exports2.setTimeMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND:
          return (0, exports2.setTimeNanosecond)(data, index, value);
      }
    };
    exports2.setTime = setTime;
    var setDecimal = ({ values, stride }, index, value) => {
      values.set(value.subarray(0, stride), stride * index);
    };
    exports2.setDecimal = setDecimal;
    var setList = (data, index, value) => {
      const values = data.children[0];
      const valueOffsets = data.valueOffsets;
      const set = exports2.instance.getVisitFn(values);
      if (Array.isArray(value)) {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
          set(values, itr++, value[++idx]);
        }
      } else {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
          set(values, itr++, value.get(++idx));
        }
      }
    };
    var setMap = (data, index, value) => {
      const values = data.children[0];
      const { valueOffsets } = data;
      const set = exports2.instance.getVisitFn(values);
      let { [index]: idx, [index + 1]: end } = valueOffsets;
      const entries = value instanceof Map ? value.entries() : Object.entries(value);
      for (const val of entries) {
        set(values, idx, val);
        if (++idx >= end)
          break;
      }
    };
    var _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);
    var _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));
    var _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
    var _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
    var setStruct = (data, index, value) => {
      const childSetters = data.type.children.map((f) => exports2.instance.getVisitFn(f.type));
      const set = value instanceof Map ? _setStructMapValue(index, value) : value instanceof vector_js_1.Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
      data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));
    };
    var setUnion = (data, index, value) => {
      data.type.mode === enum_js_1.UnionMode.Dense ? setDenseUnion(data, index, value) : setSparseUnion(data, index, value);
    };
    var setDenseUnion = (data, index, value) => {
      const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
      const child = data.children[childIndex];
      exports2.instance.visit(child, data.valueOffsets[index], value);
    };
    var setSparseUnion = (data, index, value) => {
      const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
      const child = data.children[childIndex];
      exports2.instance.visit(child, index, value);
    };
    var setDictionary = (data, index, value) => {
      var _a;
      (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.set(data.values[index], value);
    };
    var setIntervalValue = (data, index, value) => {
      data.type.unit === enum_js_1.IntervalUnit.DAY_TIME ? (0, exports2.setIntervalDayTime)(data, index, value) : (0, exports2.setIntervalYearMonth)(data, index, value);
    };
    exports2.setIntervalValue = setIntervalValue;
    var setIntervalDayTime = ({ values }, index, value) => {
      values.set(value.subarray(0, 2), 2 * index);
    };
    exports2.setIntervalDayTime = setIntervalDayTime;
    var setIntervalYearMonth = ({ values }, index, value) => {
      values[index] = value[0] * 12 + value[1] % 12;
    };
    exports2.setIntervalYearMonth = setIntervalYearMonth;
    var setDurationSecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setDurationSecond = setDurationSecond;
    var setDurationMillisecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setDurationMillisecond = setDurationMillisecond;
    var setDurationMicrosecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setDurationMicrosecond = setDurationMicrosecond;
    var setDurationNanosecond = ({ values }, index, value) => {
      values[index] = value;
    };
    exports2.setDurationNanosecond = setDurationNanosecond;
    var setDuration = (data, index, value) => {
      switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND:
          return (0, exports2.setDurationSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND:
          return (0, exports2.setDurationMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND:
          return (0, exports2.setDurationMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND:
          return (0, exports2.setDurationNanosecond)(data, index, value);
      }
    };
    exports2.setDuration = setDuration;
    var setFixedSizeList = (data, index, value) => {
      const { stride } = data;
      const child = data.children[0];
      const set = exports2.instance.getVisitFn(child);
      if (Array.isArray(value)) {
        for (let idx = -1, offset = index * stride; ++idx < stride; ) {
          set(child, offset + idx, value[idx]);
        }
      } else {
        for (let idx = -1, offset = index * stride; ++idx < stride; ) {
          set(child, offset + idx, value.get(idx));
        }
      }
    };
    SetVisitor.prototype.visitBool = wrapSet(setBool);
    SetVisitor.prototype.visitInt = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitInt8 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitInt16 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitInt32 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitInt64 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitUint8 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitUint16 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitUint32 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitUint64 = wrapSet(exports2.setInt);
    SetVisitor.prototype.visitFloat = wrapSet(exports2.setAnyFloat);
    SetVisitor.prototype.visitFloat16 = wrapSet(exports2.setFloat16);
    SetVisitor.prototype.visitFloat32 = wrapSet(exports2.setFloat);
    SetVisitor.prototype.visitFloat64 = wrapSet(exports2.setFloat);
    SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
    SetVisitor.prototype.visitLargeUtf8 = wrapSet(setUtf8);
    SetVisitor.prototype.visitBinary = wrapSet(setBinary);
    SetVisitor.prototype.visitLargeBinary = wrapSet(setBinary);
    SetVisitor.prototype.visitFixedSizeBinary = wrapSet(exports2.setFixedSizeBinary);
    SetVisitor.prototype.visitDate = wrapSet(exports2.setDate);
    SetVisitor.prototype.visitDateDay = wrapSet(exports2.setDateDay);
    SetVisitor.prototype.visitDateMillisecond = wrapSet(exports2.setDateMillisecond);
    SetVisitor.prototype.visitTimestamp = wrapSet(exports2.setTimestamp);
    SetVisitor.prototype.visitTimestampSecond = wrapSet(exports2.setTimestampSecond);
    SetVisitor.prototype.visitTimestampMillisecond = wrapSet(exports2.setTimestampMillisecond);
    SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(exports2.setTimestampMicrosecond);
    SetVisitor.prototype.visitTimestampNanosecond = wrapSet(exports2.setTimestampNanosecond);
    SetVisitor.prototype.visitTime = wrapSet(exports2.setTime);
    SetVisitor.prototype.visitTimeSecond = wrapSet(exports2.setTimeSecond);
    SetVisitor.prototype.visitTimeMillisecond = wrapSet(exports2.setTimeMillisecond);
    SetVisitor.prototype.visitTimeMicrosecond = wrapSet(exports2.setTimeMicrosecond);
    SetVisitor.prototype.visitTimeNanosecond = wrapSet(exports2.setTimeNanosecond);
    SetVisitor.prototype.visitDecimal = wrapSet(exports2.setDecimal);
    SetVisitor.prototype.visitList = wrapSet(setList);
    SetVisitor.prototype.visitStruct = wrapSet(setStruct);
    SetVisitor.prototype.visitUnion = wrapSet(setUnion);
    SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
    SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
    SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
    SetVisitor.prototype.visitInterval = wrapSet(exports2.setIntervalValue);
    SetVisitor.prototype.visitIntervalDayTime = wrapSet(exports2.setIntervalDayTime);
    SetVisitor.prototype.visitIntervalYearMonth = wrapSet(exports2.setIntervalYearMonth);
    SetVisitor.prototype.visitDuration = wrapSet(exports2.setDuration);
    SetVisitor.prototype.visitDurationSecond = wrapSet(exports2.setDurationSecond);
    SetVisitor.prototype.visitDurationMillisecond = wrapSet(exports2.setDurationMillisecond);
    SetVisitor.prototype.visitDurationMicrosecond = wrapSet(exports2.setDurationMicrosecond);
    SetVisitor.prototype.visitDurationNanosecond = wrapSet(exports2.setDurationNanosecond);
    SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
    SetVisitor.prototype.visitMap = wrapSet(setMap);
    exports2.instance = new SetVisitor();
  }
});

// node_modules/apache-arrow/row/struct.js
var require_struct2 = __commonJS({
  "node_modules/apache-arrow/row/struct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StructRow = void 0;
    var pretty_js_1 = require_pretty();
    var get_js_1 = require_get();
    var set_js_1 = require_set();
    var kParent = Symbol.for("parent");
    var kRowIndex = Symbol.for("rowIndex");
    var StructRow = class {
      constructor(parent, rowIndex) {
        this[kParent] = parent;
        this[kRowIndex] = rowIndex;
        return new Proxy(this, structRowProxyHandler);
      }
      toArray() {
        return Object.values(this.toJSON());
      }
      toJSON() {
        const i = this[kRowIndex];
        const parent = this[kParent];
        const keys = parent.type.children;
        const json = {};
        for (let j = -1, n = keys.length; ++j < n; ) {
          json[keys[j].name] = get_js_1.instance.visit(parent.children[j], i);
        }
        return json;
      }
      toString() {
        return `{${[...this].map(([key, val]) => `${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(", ")}}`;
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.toString();
      }
      [Symbol.iterator]() {
        return new StructRowIterator(this[kParent], this[kRowIndex]);
      }
    };
    exports2.StructRow = StructRow;
    var StructRowIterator = class {
      constructor(data, rowIndex) {
        this.childIndex = 0;
        this.children = data.children;
        this.rowIndex = rowIndex;
        this.childFields = data.type.children;
        this.numChildren = this.childFields.length;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        const i = this.childIndex;
        if (i < this.numChildren) {
          this.childIndex = i + 1;
          return {
            done: false,
            value: [
              this.childFields[i].name,
              get_js_1.instance.visit(this.children[i], this.rowIndex)
            ]
          };
        }
        return { done: true, value: null };
      }
    };
    Object.defineProperties(StructRow.prototype, {
      [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
      [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
      [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
    });
    var StructRowProxyHandler = class {
      isExtensible() {
        return false;
      }
      deleteProperty() {
        return false;
      }
      preventExtensions() {
        return true;
      }
      ownKeys(row) {
        return row[kParent].type.children.map((f) => f.name);
      }
      has(row, key) {
        return row[kParent].type.children.some((f) => f.name === key);
      }
      getOwnPropertyDescriptor(row, key) {
        if (row[kParent].type.children.some((f) => f.name === key)) {
          return { writable: true, enumerable: true, configurable: true };
        }
        return;
      }
      get(row, key) {
        if (Reflect.has(row, key)) {
          return row[key];
        }
        const idx = row[kParent].type.children.findIndex((f) => f.name === key);
        if (idx !== -1) {
          const val = get_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex]);
          Reflect.set(row, key, val);
          return val;
        }
      }
      set(row, key, val) {
        const idx = row[kParent].type.children.findIndex((f) => f.name === key);
        if (idx !== -1) {
          set_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex], val);
          return Reflect.set(row, key, val);
        } else if (Reflect.has(row, key) || typeof key === "symbol") {
          return Reflect.set(row, key, val);
        }
        return false;
      }
    };
    var structRowProxyHandler = new StructRowProxyHandler();
  }
});

// node_modules/apache-arrow/visitor/get.js
var require_get = __commonJS({
  "node_modules/apache-arrow/visitor/get.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instance = exports2.GetVisitor = void 0;
    var bn_js_1 = require_bn();
    var vector_js_1 = require_vector2();
    var visitor_js_1 = require_visitor();
    var map_js_1 = require_map2();
    var struct_js_1 = require_struct2();
    var bigint_js_1 = require_bigint();
    var utf8_js_1 = require_utf8();
    var math_js_1 = require_math();
    var enum_js_1 = require_enum();
    var GetVisitor = class extends visitor_js_1.Visitor {
    };
    exports2.GetVisitor = GetVisitor;
    function wrapGet(fn) {
      return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
    }
    var epochDaysToMs = (data, index) => 864e5 * data[index];
    var getNull = (_data, _index) => null;
    var getVariableWidthBytes = (values, valueOffsets, index) => {
      if (index + 1 >= valueOffsets.length) {
        return null;
      }
      const x = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index]);
      const y = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index + 1]);
      return values.subarray(x, y);
    };
    var getBool = ({ offset, values }, index) => {
      const idx = offset + index;
      const byte = values[idx >> 3];
      return (byte & 1 << idx % 8) !== 0;
    };
    var getDateDay = ({ values }, index) => epochDaysToMs(values, index);
    var getDateMillisecond = ({ values }, index) => (0, bigint_js_1.bigIntToNumber)(values[index]);
    var getNumeric = ({ stride, values }, index) => values[stride * index];
    var getFloat16 = ({ stride, values }, index) => (0, math_js_1.uint16ToFloat64)(values[stride * index]);
    var getBigInts = ({ values }, index) => values[index];
    var getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
    var getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
    var getUtf8 = ({ values, valueOffsets }, index) => {
      const bytes = getVariableWidthBytes(values, valueOffsets, index);
      return bytes !== null ? (0, utf8_js_1.decodeUtf8)(bytes) : null;
    };
    var getInt = ({ values }, index) => values[index];
    var getFloat = ({ type, values }, index) => type.precision !== enum_js_1.Precision.HALF ? values[index] : (0, math_js_1.uint16ToFloat64)(values[index]);
    var getDate = (data, index) => data.type.unit === enum_js_1.DateUnit.DAY ? getDateDay(data, index) : getDateMillisecond(data, index);
    var getTimestampSecond = ({ values }, index) => 1e3 * (0, bigint_js_1.bigIntToNumber)(values[index]);
    var getTimestampMillisecond = ({ values }, index) => (0, bigint_js_1.bigIntToNumber)(values[index]);
    var getTimestampMicrosecond = ({ values }, index) => (0, bigint_js_1.divideBigInts)(values[index], BigInt(1e3));
    var getTimestampNanosecond = ({ values }, index) => (0, bigint_js_1.divideBigInts)(values[index], BigInt(1e6));
    var getTimestamp = (data, index) => {
      switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND:
          return getTimestampSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND:
          return getTimestampMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND:
          return getTimestampMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND:
          return getTimestampNanosecond(data, index);
      }
    };
    var getTimeSecond = ({ values }, index) => values[index];
    var getTimeMillisecond = ({ values }, index) => values[index];
    var getTimeMicrosecond = ({ values }, index) => values[index];
    var getTimeNanosecond = ({ values }, index) => values[index];
    var getTime = (data, index) => {
      switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND:
          return getTimeSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND:
          return getTimeMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND:
          return getTimeMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND:
          return getTimeNanosecond(data, index);
      }
    };
    var getDecimal = ({ values, stride }, index) => bn_js_1.BN.decimal(values.subarray(stride * index, stride * (index + 1)));
    var getList = (data, index) => {
      const { valueOffsets, stride, children } = data;
      const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
      const child = children[0];
      const slice = child.slice(begin, end - begin);
      return new vector_js_1.Vector([slice]);
    };
    var getMap = (data, index) => {
      const { valueOffsets, children } = data;
      const { [index]: begin, [index + 1]: end } = valueOffsets;
      const child = children[0];
      return new map_js_1.MapRow(child.slice(begin, end - begin));
    };
    var getStruct = (data, index) => {
      return new struct_js_1.StructRow(data, index);
    };
    var getUnion = (data, index) => {
      return data.type.mode === enum_js_1.UnionMode.Dense ? getDenseUnion(data, index) : getSparseUnion(data, index);
    };
    var getDenseUnion = (data, index) => {
      const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
      const child = data.children[childIndex];
      return exports2.instance.visit(child, data.valueOffsets[index]);
    };
    var getSparseUnion = (data, index) => {
      const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
      const child = data.children[childIndex];
      return exports2.instance.visit(child, index);
    };
    var getDictionary = (data, index) => {
      var _a;
      return (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.get(data.values[index]);
    };
    var getInterval = (data, index) => data.type.unit === enum_js_1.IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index) : getIntervalYearMonth(data, index);
    var getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
    var getIntervalYearMonth = ({ values }, index) => {
      const interval = values[index];
      const int32s = new Int32Array(2);
      int32s[0] = Math.trunc(interval / 12);
      int32s[1] = Math.trunc(interval % 12);
      return int32s;
    };
    var getDurationSecond = ({ values }, index) => values[index];
    var getDurationMillisecond = ({ values }, index) => values[index];
    var getDurationMicrosecond = ({ values }, index) => values[index];
    var getDurationNanosecond = ({ values }, index) => values[index];
    var getDuration = (data, index) => {
      switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND:
          return getDurationSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND:
          return getDurationMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND:
          return getDurationMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND:
          return getDurationNanosecond(data, index);
      }
    };
    var getFixedSizeList = (data, index) => {
      const { stride, children } = data;
      const child = children[0];
      const slice = child.slice(index * stride, stride);
      return new vector_js_1.Vector([slice]);
    };
    GetVisitor.prototype.visitNull = wrapGet(getNull);
    GetVisitor.prototype.visitBool = wrapGet(getBool);
    GetVisitor.prototype.visitInt = wrapGet(getInt);
    GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
    GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
    GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
    GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
    GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
    GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
    GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
    GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
    GetVisitor.prototype.visitFloat = wrapGet(getFloat);
    GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
    GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
    GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
    GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
    GetVisitor.prototype.visitLargeUtf8 = wrapGet(getUtf8);
    GetVisitor.prototype.visitBinary = wrapGet(getBinary);
    GetVisitor.prototype.visitLargeBinary = wrapGet(getBinary);
    GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
    GetVisitor.prototype.visitDate = wrapGet(getDate);
    GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
    GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
    GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
    GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
    GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
    GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
    GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
    GetVisitor.prototype.visitTime = wrapGet(getTime);
    GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
    GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
    GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
    GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
    GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
    GetVisitor.prototype.visitList = wrapGet(getList);
    GetVisitor.prototype.visitStruct = wrapGet(getStruct);
    GetVisitor.prototype.visitUnion = wrapGet(getUnion);
    GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
    GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
    GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
    GetVisitor.prototype.visitInterval = wrapGet(getInterval);
    GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
    GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
    GetVisitor.prototype.visitDuration = wrapGet(getDuration);
    GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
    GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
    GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
    GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
    GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
    GetVisitor.prototype.visitMap = wrapGet(getMap);
    exports2.instance = new GetVisitor();
  }
});

// node_modules/apache-arrow/row/map.js
var require_map2 = __commonJS({
  "node_modules/apache-arrow/row/map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapRow = exports2._kKeysAsStrings = exports2.kKeysAsStrings = exports2.kVals = exports2.kKeys = void 0;
    var vector_js_1 = require_vector2();
    var pretty_js_1 = require_pretty();
    var get_js_1 = require_get();
    var set_js_1 = require_set();
    exports2.kKeys = Symbol.for("keys");
    exports2.kVals = Symbol.for("vals");
    exports2.kKeysAsStrings = Symbol.for("kKeysAsStrings");
    exports2._kKeysAsStrings = Symbol.for("_kKeysAsStrings");
    var MapRow = class {
      constructor(slice) {
        this[exports2.kKeys] = new vector_js_1.Vector([slice.children[0]]).memoize();
        this[exports2.kVals] = slice.children[1];
        return new Proxy(this, new MapRowProxyHandler());
      }
      /** @ignore */
      get [exports2.kKeysAsStrings]() {
        return this[exports2._kKeysAsStrings] || (this[exports2._kKeysAsStrings] = Array.from(this[exports2.kKeys].toArray(), String));
      }
      [Symbol.iterator]() {
        return new MapRowIterator(this[exports2.kKeys], this[exports2.kVals]);
      }
      get size() {
        return this[exports2.kKeys].length;
      }
      toArray() {
        return Object.values(this.toJSON());
      }
      toJSON() {
        const keys = this[exports2.kKeys];
        const vals = this[exports2.kVals];
        const json = {};
        for (let i = -1, n = keys.length; ++i < n; ) {
          json[keys.get(i)] = get_js_1.instance.visit(vals, i);
        }
        return json;
      }
      toString() {
        return `{${[...this].map(([key, val]) => `${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(", ")}}`;
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.toString();
      }
    };
    exports2.MapRow = MapRow;
    var MapRowIterator = class {
      constructor(keys, vals) {
        this.keys = keys;
        this.vals = vals;
        this.keyIndex = 0;
        this.numKeys = keys.length;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        const i = this.keyIndex;
        if (i === this.numKeys) {
          return { done: true, value: null };
        }
        this.keyIndex++;
        return {
          done: false,
          value: [
            this.keys.get(i),
            get_js_1.instance.visit(this.vals, i)
          ]
        };
      }
    };
    var MapRowProxyHandler = class {
      isExtensible() {
        return false;
      }
      deleteProperty() {
        return false;
      }
      preventExtensions() {
        return true;
      }
      ownKeys(row) {
        return row[exports2.kKeysAsStrings];
      }
      has(row, key) {
        return row[exports2.kKeysAsStrings].includes(key);
      }
      getOwnPropertyDescriptor(row, key) {
        const idx = row[exports2.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
          return { writable: true, enumerable: true, configurable: true };
        }
        return;
      }
      get(row, key) {
        if (Reflect.has(row, key)) {
          return row[key];
        }
        const idx = row[exports2.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
          const val = get_js_1.instance.visit(Reflect.get(row, exports2.kVals), idx);
          Reflect.set(row, key, val);
          return val;
        }
      }
      set(row, key, val) {
        const idx = row[exports2.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
          set_js_1.instance.visit(Reflect.get(row, exports2.kVals), idx, val);
          return Reflect.set(row, key, val);
        } else if (Reflect.has(row, key)) {
          return Reflect.set(row, key, val);
        }
        return false;
      }
    };
    Object.defineProperties(MapRow.prototype, {
      [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
      [exports2.kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
      [exports2.kVals]: { writable: true, enumerable: false, configurable: false, value: null },
      [exports2._kKeysAsStrings]: { writable: true, enumerable: false, configurable: false, value: null }
    });
  }
});

// node_modules/apache-arrow/util/vector.js
var require_vector = __commonJS({
  "node_modules/apache-arrow/util/vector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createElementComparator = exports2.wrapIndex = exports2.clampRange = void 0;
    var vector_js_1 = require_vector2();
    var map_js_1 = require_map2();
    var struct_js_1 = require_struct2();
    var buffer_js_1 = require_buffer();
    var tmp;
    function clampRange(source, begin, end, then) {
      const { length: len = 0 } = source;
      let lhs = typeof begin !== "number" ? 0 : begin;
      let rhs = typeof end !== "number" ? len : end;
      lhs < 0 && (lhs = (lhs % len + len) % len);
      rhs < 0 && (rhs = (rhs % len + len) % len);
      rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
      rhs > len && (rhs = len);
      return then ? then(source, lhs, rhs) : [lhs, rhs];
    }
    exports2.clampRange = clampRange;
    var wrapIndex = (index, len) => index < 0 ? len + index : index;
    exports2.wrapIndex = wrapIndex;
    var isNaNFast = (value) => value !== value;
    function createElementComparator(search) {
      const typeofSearch = typeof search;
      if (typeofSearch !== "object" || search === null) {
        if (isNaNFast(search)) {
          return isNaNFast;
        }
        return (value) => value === search;
      }
      if (search instanceof Date) {
        const valueOfSearch = search.valueOf();
        return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
      }
      if (ArrayBuffer.isView(search)) {
        return (value) => value ? (0, buffer_js_1.compareArrayLike)(search, value) : false;
      }
      if (search instanceof Map) {
        return createMapComparator(search);
      }
      if (Array.isArray(search)) {
        return createArrayLikeComparator(search);
      }
      if (search instanceof vector_js_1.Vector) {
        return createVectorComparator(search);
      }
      return createObjectComparator(search, true);
    }
    exports2.createElementComparator = createElementComparator;
    function createArrayLikeComparator(lhs) {
      const comparators = [];
      for (let i = -1, n = lhs.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs[i]);
      }
      return createSubElementsComparator(comparators);
    }
    function createMapComparator(lhs) {
      let i = -1;
      const comparators = [];
      for (const v of lhs.values())
        comparators[++i] = createElementComparator(v);
      return createSubElementsComparator(comparators);
    }
    function createVectorComparator(lhs) {
      const comparators = [];
      for (let i = -1, n = lhs.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs.get(i));
      }
      return createSubElementsComparator(comparators);
    }
    function createObjectComparator(lhs, allowEmpty = false) {
      const keys = Object.keys(lhs);
      if (!allowEmpty && keys.length === 0) {
        return () => false;
      }
      const comparators = [];
      for (let i = -1, n = keys.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs[keys[i]]);
      }
      return createSubElementsComparator(comparators, keys);
    }
    function createSubElementsComparator(comparators, keys) {
      return (rhs) => {
        if (!rhs || typeof rhs !== "object") {
          return false;
        }
        switch (rhs.constructor) {
          case Array:
            return compareArray(comparators, rhs);
          case Map:
            return compareObject(comparators, rhs, rhs.keys());
          case map_js_1.MapRow:
          case struct_js_1.StructRow:
          case Object:
          case void 0:
            return compareObject(comparators, rhs, keys || Object.keys(rhs));
        }
        return rhs instanceof vector_js_1.Vector ? compareVector(comparators, rhs) : false;
      };
    }
    function compareArray(comparators, arr) {
      const n = comparators.length;
      if (arr.length !== n) {
        return false;
      }
      for (let i = -1; ++i < n; ) {
        if (!comparators[i](arr[i])) {
          return false;
        }
      }
      return true;
    }
    function compareVector(comparators, vec) {
      const n = comparators.length;
      if (vec.length !== n) {
        return false;
      }
      for (let i = -1; ++i < n; ) {
        if (!comparators[i](vec.get(i))) {
          return false;
        }
      }
      return true;
    }
    function compareObject(comparators, obj, keys) {
      const lKeyItr = keys[Symbol.iterator]();
      const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
      const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
      let i = 0;
      const n = comparators.length;
      let rVal = rValItr.next();
      let lKey = lKeyItr.next();
      let rKey = rKeyItr.next();
      for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
          break;
        }
      }
      if (i === n && lKey.done && rKey.done && rVal.done) {
        return true;
      }
      lKeyItr.return && lKeyItr.return();
      rKeyItr.return && rKeyItr.return();
      rValItr.return && rValItr.return();
      return false;
    }
  }
});

// node_modules/apache-arrow/util/bit.js
var require_bit = __commonJS({
  "node_modules/apache-arrow/util/bit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.popcnt_uint32 = exports2.popcnt_array = exports2.popcnt_bit_range = exports2.BitIterator = exports2.packBools = exports2.truncateBitmap = exports2.setBool = exports2.getBit = exports2.getBool = void 0;
    function getBool(_data, _index, byte, bit) {
      return (byte & 1 << bit) !== 0;
    }
    exports2.getBool = getBool;
    function getBit(_data, _index, byte, bit) {
      return (byte & 1 << bit) >> bit;
    }
    exports2.getBit = getBit;
    function setBool(bytes, index, value) {
      return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
    }
    exports2.setBool = setBool;
    function truncateBitmap(offset, length, bitmap) {
      const alignedSize = bitmap.byteLength + 7 & ~7;
      if (offset > 0 || bitmap.byteLength < alignedSize) {
        const bytes = new Uint8Array(alignedSize);
        bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : (
          // Otherwise iterate each bit from the offset and return a new one
          packBools(new BitIterator(bitmap, offset, length, null, getBool)).subarray(0, alignedSize)
        ));
        return bytes;
      }
      return bitmap;
    }
    exports2.truncateBitmap = truncateBitmap;
    function packBools(values) {
      const xs = [];
      let i = 0, bit = 0, byte = 0;
      for (const value of values) {
        value && (byte |= 1 << bit);
        if (++bit === 8) {
          xs[i++] = byte;
          byte = bit = 0;
        }
      }
      if (i === 0 || bit > 0) {
        xs[i++] = byte;
      }
      const b = new Uint8Array(xs.length + 7 & ~7);
      b.set(xs);
      return b;
    }
    exports2.packBools = packBools;
    var BitIterator = class {
      constructor(bytes, begin, length, context2, get) {
        this.bytes = bytes;
        this.length = length;
        this.context = context2;
        this.get = get;
        this.bit = begin % 8;
        this.byteIndex = begin >> 3;
        this.byte = bytes[this.byteIndex++];
        this.index = 0;
      }
      next() {
        if (this.index < this.length) {
          if (this.bit === 8) {
            this.bit = 0;
            this.byte = this.bytes[this.byteIndex++];
          }
          return {
            value: this.get(this.context, this.index++, this.byte, this.bit++)
          };
        }
        return { done: true, value: null };
      }
      [Symbol.iterator]() {
        return this;
      }
    };
    exports2.BitIterator = BitIterator;
    function popcnt_bit_range(data, lhs, rhs) {
      if (rhs - lhs <= 0) {
        return 0;
      }
      if (rhs - lhs < 8) {
        let sum = 0;
        for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
          sum += bit;
        }
        return sum;
      }
      const rhsInside = rhs >> 3 << 3;
      const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
      return (
        // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
        popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
        popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
        popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3)
      );
    }
    exports2.popcnt_bit_range = popcnt_bit_range;
    function popcnt_array(arr, byteOffset, byteLength) {
      let cnt = 0, pos = Math.trunc(byteOffset);
      const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
      while (len - pos >= 4) {
        cnt += popcnt_uint32(view.getUint32(pos));
        pos += 4;
      }
      while (len - pos >= 2) {
        cnt += popcnt_uint32(view.getUint16(pos));
        pos += 2;
      }
      while (len - pos >= 1) {
        cnt += popcnt_uint32(view.getUint8(pos));
        pos += 1;
      }
      return cnt;
    }
    exports2.popcnt_array = popcnt_array;
    function popcnt_uint32(uint32) {
      let i = Math.trunc(uint32);
      i = i - (i >>> 1 & 1431655765);
      i = (i & 858993459) + (i >>> 2 & 858993459);
      return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
    }
    exports2.popcnt_uint32 = popcnt_uint32;
  }
});

// node_modules/apache-arrow/data.js
var require_data = __commonJS({
  "node_modules/apache-arrow/data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeData = exports2.Data = exports2.kUnknownNullCount = void 0;
    var vector_js_1 = require_vector2();
    var enum_js_1 = require_enum();
    var type_js_1 = require_type2();
    var bit_js_1 = require_bit();
    exports2.kUnknownNullCount = -1;
    var Data = class _Data {
      get typeId() {
        return this.type.typeId;
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get buffers() {
        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
      }
      get nullable() {
        if (this._nullCount !== 0) {
          const { type } = this;
          if (type_js_1.DataType.isSparseUnion(type)) {
            return this.children.some((child) => child.nullable);
          } else if (type_js_1.DataType.isDenseUnion(type)) {
            return this.children.some((child) => child.nullable);
          }
          return this.nullBitmap && this.nullBitmap.byteLength > 0;
        }
        return true;
      }
      get byteLength() {
        let byteLength = 0;
        const { valueOffsets, values, nullBitmap, typeIds } = this;
        valueOffsets && (byteLength += valueOffsets.byteLength);
        values && (byteLength += values.byteLength);
        nullBitmap && (byteLength += nullBitmap.byteLength);
        typeIds && (byteLength += typeIds.byteLength);
        return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
      }
      get nullCount() {
        if (type_js_1.DataType.isUnion(this.type)) {
          return this.children.reduce((nullCount2, child) => nullCount2 + child.nullCount, 0);
        }
        let nullCount = this._nullCount;
        let nullBitmap;
        if (nullCount <= exports2.kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
          this._nullCount = nullCount = nullBitmap.length === 0 ? (
            // no null bitmap, so all values are valid
            0
          ) : this.length - (0, bit_js_1.popcnt_bit_range)(nullBitmap, this.offset, this.offset + this.length);
        }
        return nullCount;
      }
      constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
        this.type = type;
        this.children = children;
        this.dictionary = dictionary;
        this.offset = Math.floor(Math.max(offset || 0, 0));
        this.length = Math.floor(Math.max(length || 0, 0));
        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
        let buffer;
        if (buffers instanceof _Data) {
          this.stride = buffers.stride;
          this.values = buffers.values;
          this.typeIds = buffers.typeIds;
          this.nullBitmap = buffers.nullBitmap;
          this.valueOffsets = buffers.valueOffsets;
        } else {
          this.stride = (0, type_js_1.strideForType)(type);
          if (buffers) {
            (buffer = buffers[0]) && (this.valueOffsets = buffer);
            (buffer = buffers[1]) && (this.values = buffer);
            (buffer = buffers[2]) && (this.nullBitmap = buffer);
            (buffer = buffers[3]) && (this.typeIds = buffer);
          }
        }
      }
      getValid(index) {
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
          const union = type;
          const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
          const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
          return child.getValid(indexInChild);
        }
        if (this.nullable && this.nullCount > 0) {
          const pos = this.offset + index;
          const val = this.nullBitmap[pos >> 3];
          return (val & 1 << pos % 8) !== 0;
        }
        return true;
      }
      setValid(index, value) {
        let prev;
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
          const union = type;
          const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
          const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
          prev = child.getValid(indexInChild);
          child.setValid(indexInChild, value);
        } else {
          let { nullBitmap } = this;
          const { offset, length } = this;
          const idx = offset + index;
          const mask = 1 << idx % 8;
          const byteOffset = idx >> 3;
          if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
            nullBitmap = new Uint8Array((offset + length + 63 & ~63) >> 3).fill(255);
            if (this.nullCount > 0) {
              nullBitmap.set((0, bit_js_1.truncateBitmap)(offset, length, this.nullBitmap), 0);
              Object.assign(this, { nullBitmap });
            } else {
              Object.assign(this, { nullBitmap, _nullCount: 0 });
            }
          }
          const byte = nullBitmap[byteOffset];
          prev = (byte & mask) !== 0;
          nullBitmap[byteOffset] = value ? byte | mask : byte & ~mask;
        }
        if (prev !== !!value) {
          this._nullCount = this.nullCount + (value ? -1 : 1);
        }
        return value;
      }
      clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
        return new _Data(type, offset, length, nullCount, buffers, children, this.dictionary);
      }
      slice(offset, length) {
        const { stride, typeId, children } = this;
        const nullCount = +(this._nullCount === 0) - 1;
        const childStride = typeId === 16 ? stride : 1;
        const buffers = this._sliceBuffers(offset, length, stride, typeId);
        return this.clone(
          this.type,
          this.offset + offset,
          length,
          nullCount,
          buffers,
          // Don't slice children if we have value offsets (the variable-width types)
          children.length === 0 || this.valueOffsets ? children : this._sliceChildren(children, childStride * offset, childStride * length)
        );
      }
      _changeLengthAndBackfillNullBitmap(newLength) {
        if (this.typeId === enum_js_1.Type.Null) {
          return this.clone(this.type, 0, newLength, 0);
        }
        const { length, nullCount } = this;
        const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
        bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
        if (nullCount > 0) {
          bitmap.set((0, bit_js_1.truncateBitmap)(this.offset, length, this.nullBitmap), 0);
        }
        const buffers = this.buffers;
        buffers[enum_js_1.BufferType.VALIDITY] = bitmap;
        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
      }
      _sliceBuffers(offset, length, stride, typeId) {
        let arr;
        const { buffers } = this;
        (arr = buffers[enum_js_1.BufferType.TYPE]) && (buffers[enum_js_1.BufferType.TYPE] = arr.subarray(offset, offset + length));
        (arr = buffers[enum_js_1.BufferType.OFFSET]) && (buffers[enum_js_1.BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
        (arr = buffers[enum_js_1.BufferType.DATA]) && (buffers[enum_js_1.BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
        return buffers;
      }
      _sliceChildren(children, offset, length) {
        return children.map((child) => child.slice(offset, length));
      }
    };
    exports2.Data = Data;
    Data.prototype.children = Object.freeze([]);
    var visitor_js_1 = require_visitor();
    var buffer_js_1 = require_buffer();
    var MakeDataVisitor = class _MakeDataVisitor extends visitor_js_1.Visitor {
      visit(props) {
        return this.getVisitFn(props["type"]).call(this, props);
      }
      visitNull(props) {
        const { ["type"]: type, ["offset"]: offset = 0, ["length"]: length = 0 } = props;
        return new Data(type, offset, length, length);
      }
      visitBool(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitInt(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitFloat(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitUtf8(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props["data"]);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props["valueOffsets"]);
        const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
      }
      visitLargeUtf8(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props["data"]);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const valueOffsets = (0, buffer_js_1.toBigInt64Array)(props["valueOffsets"]);
        const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
      }
      visitBinary(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props["data"]);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props["valueOffsets"]);
        const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
      }
      visitLargeBinary(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props["data"]);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const valueOffsets = (0, buffer_js_1.toBigInt64Array)(props["valueOffsets"]);
        const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
      }
      visitFixedSizeBinary(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length / (0, type_js_1.strideForType)(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitDate(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length / (0, type_js_1.strideForType)(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitTimestamp(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length / (0, type_js_1.strideForType)(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitTime(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length / (0, type_js_1.strideForType)(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitDecimal(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length / (0, type_js_1.strideForType)(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitList(props) {
        const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props["valueOffsets"]);
        const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
      }
      visitStruct(props) {
        const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const { length = children.reduce((len, { length: length2 }) => Math.max(len, length2), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], children);
      }
      visitUnion(props) {
        const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
        const typeIds = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["typeIds"]);
        const { ["length"]: length = typeIds.length, ["nullCount"]: nullCount = -1 } = props;
        if (type_js_1.DataType.isSparseUnion(type)) {
          return new Data(type, offset, length, nullCount, [void 0, void 0, void 0, typeIds], children);
        }
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props["valueOffsets"]);
        return new Data(type, offset, length, nullCount, [valueOffsets, void 0, void 0, typeIds], children);
      }
      visitDictionary(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.indices.ArrayType, props["data"]);
        const { ["dictionary"]: dictionary = new vector_js_1.Vector([new _MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
        const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap], [], dictionary);
      }
      visitInterval(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length / (0, type_js_1.strideForType)(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitDuration(props) {
        const { ["type"]: type, ["offset"]: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props["data"]);
        const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
      }
      visitFixedSizeList(props) {
        const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.valueType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const { ["length"]: length = child.length / (0, type_js_1.strideForType)(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], [child]);
      }
      visitMap(props) {
        const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.childType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props["nullBitmap"]);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props["valueOffsets"]);
        const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
      }
    };
    var makeDataVisitor = new MakeDataVisitor();
    function makeData(props) {
      return makeDataVisitor.visit(props);
    }
    exports2.makeData = makeData;
  }
});

// node_modules/apache-arrow/util/chunk.js
var require_chunk = __commonJS({
  "node_modules/apache-arrow/util/chunk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapChunkedIndexOf = exports2.wrapChunkedCall2 = exports2.wrapChunkedCall1 = exports2.isChunkedValid = exports2.binarySearch = exports2.sliceChunks = exports2.computeChunkOffsets = exports2.computeChunkNullCounts = exports2.computeChunkNullable = exports2.ChunkedIterator = void 0;
    var ChunkedIterator = class {
      constructor(numChunks = 0, getChunkIterator) {
        this.numChunks = numChunks;
        this.getChunkIterator = getChunkIterator;
        this.chunkIndex = 0;
        this.chunkIterator = this.getChunkIterator(0);
      }
      next() {
        while (this.chunkIndex < this.numChunks) {
          const next = this.chunkIterator.next();
          if (!next.done) {
            return next;
          }
          if (++this.chunkIndex < this.numChunks) {
            this.chunkIterator = this.getChunkIterator(this.chunkIndex);
          }
        }
        return { done: true, value: null };
      }
      [Symbol.iterator]() {
        return this;
      }
    };
    exports2.ChunkedIterator = ChunkedIterator;
    function computeChunkNullable(chunks) {
      return chunks.some((chunk) => chunk.nullable);
    }
    exports2.computeChunkNullable = computeChunkNullable;
    function computeChunkNullCounts(chunks) {
      return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
    }
    exports2.computeChunkNullCounts = computeChunkNullCounts;
    function computeChunkOffsets(chunks) {
      return chunks.reduce((offsets, chunk, index) => {
        offsets[index + 1] = offsets[index] + chunk.length;
        return offsets;
      }, new Uint32Array(chunks.length + 1));
    }
    exports2.computeChunkOffsets = computeChunkOffsets;
    function sliceChunks(chunks, offsets, begin, end) {
      const slices = [];
      for (let i = -1, n = chunks.length; ++i < n; ) {
        const chunk = chunks[i];
        const offset = offsets[i];
        const { length } = chunk;
        if (offset >= end) {
          break;
        }
        if (begin >= offset + length) {
          continue;
        }
        if (offset >= begin && offset + length <= end) {
          slices.push(chunk);
          continue;
        }
        const from = Math.max(0, begin - offset);
        const to = Math.min(end - offset, length);
        slices.push(chunk.slice(from, to - from));
      }
      if (slices.length === 0) {
        slices.push(chunks[0].slice(0, 0));
      }
      return slices;
    }
    exports2.sliceChunks = sliceChunks;
    function binarySearch(chunks, offsets, idx, fn) {
      let lhs = 0, mid = 0, rhs = offsets.length - 1;
      do {
        if (lhs >= rhs - 1) {
          return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
        }
        mid = lhs + Math.trunc((rhs - lhs) * 0.5);
        idx < offsets[mid] ? rhs = mid : lhs = mid;
      } while (lhs < rhs);
    }
    exports2.binarySearch = binarySearch;
    function isChunkedValid(data, index) {
      return data.getValid(index);
    }
    exports2.isChunkedValid = isChunkedValid;
    function wrapChunkedCall1(fn) {
      function chunkedFn(chunks, i, j) {
        return fn(chunks[i], j);
      }
      return function(index) {
        const data = this.data;
        return binarySearch(data, this._offsets, index, chunkedFn);
      };
    }
    exports2.wrapChunkedCall1 = wrapChunkedCall1;
    function wrapChunkedCall2(fn) {
      let _2;
      function chunkedFn(chunks, i, j) {
        return fn(chunks[i], j, _2);
      }
      return function(index, value) {
        const data = this.data;
        _2 = value;
        const result = binarySearch(data, this._offsets, index, chunkedFn);
        _2 = void 0;
        return result;
      };
    }
    exports2.wrapChunkedCall2 = wrapChunkedCall2;
    function wrapChunkedIndexOf(indexOf) {
      let _1;
      function chunkedIndexOf(data, chunkIndex, fromIndex) {
        let begin = fromIndex, index = 0, total = 0;
        for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {
          const chunk = data[i];
          if (~(index = indexOf(chunk, _1, begin))) {
            return total + index;
          }
          begin = 0;
          total += chunk.length;
        }
        return -1;
      }
      return function(element, offset) {
        _1 = element;
        const data = this.data;
        const result = typeof offset !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);
        _1 = void 0;
        return result;
      };
    }
    exports2.wrapChunkedIndexOf = wrapChunkedIndexOf;
  }
});

// node_modules/apache-arrow/visitor/indexof.js
var require_indexof = __commonJS({
  "node_modules/apache-arrow/visitor/indexof.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instance = exports2.IndexOfVisitor = void 0;
    var enum_js_1 = require_enum();
    var visitor_js_1 = require_visitor();
    var get_js_1 = require_get();
    var bit_js_1 = require_bit();
    var vector_js_1 = require_vector();
    var IndexOfVisitor = class extends visitor_js_1.Visitor {
    };
    exports2.IndexOfVisitor = IndexOfVisitor;
    function nullIndexOf(data, searchElement) {
      return searchElement === null && data.length > 0 ? 0 : -1;
    }
    function indexOfNull(data, fromIndex) {
      const { nullBitmap } = data;
      if (!nullBitmap || data.nullCount <= 0) {
        return -1;
      }
      let i = 0;
      for (const isValid of new bit_js_1.BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, bit_js_1.getBool)) {
        if (!isValid) {
          return i;
        }
        ++i;
      }
      return -1;
    }
    function indexOfValue(data, searchElement, fromIndex) {
      if (searchElement === void 0) {
        return -1;
      }
      if (searchElement === null) {
        switch (data.typeId) {
          // Unions don't have a nullBitmap of its own, so compare the `searchElement` to `get()`.
          case enum_js_1.Type.Union:
            break;
          // Dictionaries do have a nullBitmap, but their dictionary could also have null elements.
          case enum_js_1.Type.Dictionary:
            break;
          // All other types can iterate the null bitmap
          default:
            return indexOfNull(data, fromIndex);
        }
      }
      const get = get_js_1.instance.getVisitFn(data);
      const compare = (0, vector_js_1.createElementComparator)(searchElement);
      for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
        if (compare(get(data, i))) {
          return i;
        }
      }
      return -1;
    }
    function indexOfUnion(data, searchElement, fromIndex) {
      const get = get_js_1.instance.getVisitFn(data);
      const compare = (0, vector_js_1.createElementComparator)(searchElement);
      for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
        if (compare(get(data, i))) {
          return i;
        }
      }
      return -1;
    }
    IndexOfVisitor.prototype.visitNull = nullIndexOf;
    IndexOfVisitor.prototype.visitBool = indexOfValue;
    IndexOfVisitor.prototype.visitInt = indexOfValue;
    IndexOfVisitor.prototype.visitInt8 = indexOfValue;
    IndexOfVisitor.prototype.visitInt16 = indexOfValue;
    IndexOfVisitor.prototype.visitInt32 = indexOfValue;
    IndexOfVisitor.prototype.visitInt64 = indexOfValue;
    IndexOfVisitor.prototype.visitUint8 = indexOfValue;
    IndexOfVisitor.prototype.visitUint16 = indexOfValue;
    IndexOfVisitor.prototype.visitUint32 = indexOfValue;
    IndexOfVisitor.prototype.visitUint64 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat = indexOfValue;
    IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
    IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
    IndexOfVisitor.prototype.visitLargeUtf8 = indexOfValue;
    IndexOfVisitor.prototype.visitBinary = indexOfValue;
    IndexOfVisitor.prototype.visitLargeBinary = indexOfValue;
    IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
    IndexOfVisitor.prototype.visitDate = indexOfValue;
    IndexOfVisitor.prototype.visitDateDay = indexOfValue;
    IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTime = indexOfValue;
    IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
    IndexOfVisitor.prototype.visitDecimal = indexOfValue;
    IndexOfVisitor.prototype.visitList = indexOfValue;
    IndexOfVisitor.prototype.visitStruct = indexOfValue;
    IndexOfVisitor.prototype.visitUnion = indexOfValue;
    IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
    IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
    IndexOfVisitor.prototype.visitDictionary = indexOfValue;
    IndexOfVisitor.prototype.visitInterval = indexOfValue;
    IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
    IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
    IndexOfVisitor.prototype.visitDuration = indexOfValue;
    IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
    IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
    IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
    IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
    IndexOfVisitor.prototype.visitMap = indexOfValue;
    exports2.instance = new IndexOfVisitor();
  }
});

// node_modules/apache-arrow/visitor/iterator.js
var require_iterator = __commonJS({
  "node_modules/apache-arrow/visitor/iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instance = exports2.IteratorVisitor = void 0;
    var visitor_js_1 = require_visitor();
    var enum_js_1 = require_enum();
    var type_js_1 = require_type2();
    var chunk_js_1 = require_chunk();
    var IteratorVisitor = class extends visitor_js_1.Visitor {
    };
    exports2.IteratorVisitor = IteratorVisitor;
    function vectorIterator(vector) {
      const { type } = vector;
      if (vector.nullCount === 0 && vector.stride === 1 && // Don't defer to native iterator for timestamps since Numbers are expected
      // (DataType.isTimestamp(type)) && type.unit === TimeUnit.MILLISECOND ||
      (type_js_1.DataType.isInt(type) && type.bitWidth !== 64 || type_js_1.DataType.isTime(type) && type.bitWidth !== 64 || type_js_1.DataType.isFloat(type) && type.precision !== enum_js_1.Precision.HALF)) {
        return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
          const data = vector.data[chunkIndex];
          return data.values.subarray(0, data.length)[Symbol.iterator]();
        });
      }
      let offset = 0;
      return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        const length = data.length;
        const inner = vector.slice(offset, offset + length);
        offset += length;
        return new VectorIterator(inner);
      });
    }
    var VectorIterator = class {
      constructor(vector) {
        this.vector = vector;
        this.index = 0;
      }
      next() {
        if (this.index < this.vector.length) {
          return {
            value: this.vector.get(this.index++)
          };
        }
        return { done: true, value: null };
      }
      [Symbol.iterator]() {
        return this;
      }
    };
    IteratorVisitor.prototype.visitNull = vectorIterator;
    IteratorVisitor.prototype.visitBool = vectorIterator;
    IteratorVisitor.prototype.visitInt = vectorIterator;
    IteratorVisitor.prototype.visitInt8 = vectorIterator;
    IteratorVisitor.prototype.visitInt16 = vectorIterator;
    IteratorVisitor.prototype.visitInt32 = vectorIterator;
    IteratorVisitor.prototype.visitInt64 = vectorIterator;
    IteratorVisitor.prototype.visitUint8 = vectorIterator;
    IteratorVisitor.prototype.visitUint16 = vectorIterator;
    IteratorVisitor.prototype.visitUint32 = vectorIterator;
    IteratorVisitor.prototype.visitUint64 = vectorIterator;
    IteratorVisitor.prototype.visitFloat = vectorIterator;
    IteratorVisitor.prototype.visitFloat16 = vectorIterator;
    IteratorVisitor.prototype.visitFloat32 = vectorIterator;
    IteratorVisitor.prototype.visitFloat64 = vectorIterator;
    IteratorVisitor.prototype.visitUtf8 = vectorIterator;
    IteratorVisitor.prototype.visitLargeUtf8 = vectorIterator;
    IteratorVisitor.prototype.visitBinary = vectorIterator;
    IteratorVisitor.prototype.visitLargeBinary = vectorIterator;
    IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
    IteratorVisitor.prototype.visitDate = vectorIterator;
    IteratorVisitor.prototype.visitDateDay = vectorIterator;
    IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestamp = vectorIterator;
    IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
    IteratorVisitor.prototype.visitTime = vectorIterator;
    IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
    IteratorVisitor.prototype.visitDecimal = vectorIterator;
    IteratorVisitor.prototype.visitList = vectorIterator;
    IteratorVisitor.prototype.visitStruct = vectorIterator;
    IteratorVisitor.prototype.visitUnion = vectorIterator;
    IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
    IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
    IteratorVisitor.prototype.visitDictionary = vectorIterator;
    IteratorVisitor.prototype.visitInterval = vectorIterator;
    IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
    IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
    IteratorVisitor.prototype.visitDuration = vectorIterator;
    IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
    IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
    IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
    IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
    IteratorVisitor.prototype.visitMap = vectorIterator;
    exports2.instance = new IteratorVisitor();
  }
});

// node_modules/apache-arrow/vector.js
var require_vector2 = __commonJS({
  "node_modules/apache-arrow/vector.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeVector = exports2.Vector = void 0;
    var enum_js_1 = require_enum();
    var vector_js_1 = require_vector();
    var type_js_1 = require_type2();
    var data_js_1 = require_data();
    var chunk_js_1 = require_chunk();
    var get_js_1 = require_get();
    var set_js_1 = require_set();
    var indexof_js_1 = require_indexof();
    var iterator_js_1 = require_iterator();
    var visitorsByTypeId = {};
    var vectorPrototypesByTypeId = {};
    var Vector = class _Vector {
      constructor(input) {
        var _b, _c, _d;
        const data = input[0] instanceof _Vector ? input.flatMap((x) => x.data) : input;
        if (data.length === 0 || data.some((x) => !(x instanceof data_js_1.Data))) {
          throw new TypeError("Vector constructor expects an Array of Data instances.");
        }
        const type = (_b = data[0]) === null || _b === void 0 ? void 0 : _b.type;
        switch (data.length) {
          case 0:
            this._offsets = [0];
            break;
          case 1: {
            const { get, set, indexOf } = visitorsByTypeId[type.typeId];
            const unchunkedData = data[0];
            this.isValid = (index) => (0, chunk_js_1.isChunkedValid)(unchunkedData, index);
            this.get = (index) => get(unchunkedData, index);
            this.set = (index, value) => set(unchunkedData, index, value);
            this.indexOf = (index) => indexOf(unchunkedData, index);
            this._offsets = [0, unchunkedData.length];
            break;
          }
          default:
            Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
            this._offsets = (0, chunk_js_1.computeChunkOffsets)(data);
            break;
        }
        this.data = data;
        this.type = type;
        this.stride = (0, type_js_1.strideForType)(type);
        this.numChildren = (_d = (_c = type.children) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        this.length = this._offsets.at(-1);
      }
      /**
       * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
       */
      get byteLength() {
        return this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
      }
      /**
       * Whether this Vector's elements can contain null values.
       */
      get nullable() {
        return (0, chunk_js_1.computeChunkNullable)(this.data);
      }
      /**
       * The number of null elements in this Vector.
       */
      get nullCount() {
        return (0, chunk_js_1.computeChunkNullCounts)(this.data);
      }
      /**
       * The Array or TypedArray constructor used for the JS representation
       *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
       */
      get ArrayType() {
        return this.type.ArrayType;
      }
      /**
       * The name that should be printed when the Vector is logged in a message.
       */
      get [Symbol.toStringTag]() {
        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
      }
      /**
       * The name of this Vector.
       */
      get VectorName() {
        return `${enum_js_1.Type[this.type.typeId]}Vector`;
      }
      /**
       * Check whether an element is null.
       * @param index The index at which to read the validity bitmap.
       */
      // @ts-ignore
      isValid(index) {
        return false;
      }
      /**
       * Get an element value by position.
       * @param index The index of the element to read.
       */
      // @ts-ignore
      get(index) {
        return null;
      }
      /**
       * Get an element value by position.
       * @param index The index of the element to read. A negative index will count back from the last element.
       */
      at(index) {
        return this.get((0, vector_js_1.wrapIndex)(index, this.length));
      }
      /**
       * Set an element value by position.
       * @param index The index of the element to write.
       * @param value The value to set.
       */
      // @ts-ignore
      set(index, value) {
        return;
      }
      /**
       * Retrieve the index of the first occurrence of a value in an Vector.
       * @param element The value to locate in the Vector.
       * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
       */
      // @ts-ignore
      indexOf(element, offset) {
        return -1;
      }
      includes(element, offset) {
        return this.indexOf(element, offset) > -1;
      }
      /**
       * Iterator for the Vector's elements.
       */
      [Symbol.iterator]() {
        return iterator_js_1.instance.visit(this);
      }
      /**
       * Combines two or more Vectors of the same type.
       * @param others Additional Vectors to add to the end of this Vector.
       */
      concat(...others) {
        return new _Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
      }
      /**
       * Return a zero-copy sub-section of this Vector.
       * @param start The beginning of the specified portion of the Vector.
       * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
       */
      slice(begin, end) {
        return new _Vector((0, vector_js_1.clampRange)(this, begin, end, ({ data, _offsets }, begin2, end2) => (0, chunk_js_1.sliceChunks)(data, _offsets, begin2, end2)));
      }
      toJSON() {
        return [...this];
      }
      /**
       * Return a JavaScript Array or TypedArray of the Vector's elements.
       *
       * @note If this Vector contains a single Data chunk and the Vector's type is a
       *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
       *  method returns a zero-copy slice of the underlying TypedArray values. If there's
       *  more than one chunk, the resulting TypedArray will be a copy of the data from each
       *  chunk's underlying TypedArray values.
       *
       * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
       */
      toArray() {
        const { type, data, length, stride, ArrayType } = this;
        switch (type.typeId) {
          case enum_js_1.Type.Int:
          case enum_js_1.Type.Float:
          case enum_js_1.Type.Decimal:
          case enum_js_1.Type.Time:
          case enum_js_1.Type.Timestamp:
            switch (data.length) {
              case 0:
                return new ArrayType();
              case 1:
                return data[0].values.subarray(0, length * stride);
              default:
                return data.reduce((memo, { values, length: chunk_length }) => {
                  memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                  memo.offset += chunk_length * stride;
                  return memo;
                }, { array: new ArrayType(length * stride), offset: 0 }).array;
            }
        }
        return [...this];
      }
      /**
       * Returns a string representation of the Vector.
       *
       * @returns A string representation of the Vector.
       */
      toString() {
        return `[${[...this].join(",")}]`;
      }
      /**
       * Returns a child Vector by name, or null if this Vector has no child with the given name.
       * @param name The name of the child to retrieve.
       */
      getChild(name) {
        var _b;
        return this.getChildAt((_b = this.type.children) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
      }
      /**
       * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
       * @param index The index of the child to retrieve.
       */
      getChildAt(index) {
        if (index > -1 && index < this.numChildren) {
          return new _Vector(this.data.map(({ children }) => children[index]));
        }
        return null;
      }
      get isMemoized() {
        if (type_js_1.DataType.isDictionary(this.type)) {
          return this.data[0].dictionary.isMemoized;
        }
        return false;
      }
      /**
       * Adds memoization to the Vector's {@link get} method. For dictionary
       * vectors, this method return a vector that memoizes only the dictionary
       * values.
       *
       * Memoization is very useful when decoding a value is expensive such as
       * Utf8. The memoization creates a cache of the size of the Vector and
       * therefore increases memory usage.
       *
       * @returns A new vector that memoizes calls to {@link get}.
       */
      memoize() {
        if (type_js_1.DataType.isDictionary(this.type)) {
          const dictionary = new MemoizedVector(this.data[0].dictionary);
          const newData = this.data.map((data) => {
            const cloned = data.clone();
            cloned.dictionary = dictionary;
            return cloned;
          });
          return new _Vector(newData);
        }
        return new MemoizedVector(this);
      }
      /**
       * Returns a vector without memoization of the {@link get} method. If this
       * vector is not memoized, this method returns this vector.
       *
       * @returns A new vector without memoization.
       */
      unmemoize() {
        if (type_js_1.DataType.isDictionary(this.type) && this.isMemoized) {
          const dictionary = this.data[0].dictionary.unmemoize();
          const newData = this.data.map((data) => {
            const newData2 = data.clone();
            newData2.dictionary = dictionary;
            return newData2;
          });
          return new _Vector(newData);
        }
        return this;
      }
    };
    exports2.Vector = Vector;
    _a = Symbol.toStringTag;
    Vector[_a] = ((proto) => {
      proto.type = type_js_1.DataType.prototype;
      proto.data = [];
      proto.length = 0;
      proto.stride = 1;
      proto.numChildren = 0;
      proto._offsets = new Uint32Array([0]);
      proto[Symbol.isConcatSpreadable] = true;
      const typeIds = Object.keys(enum_js_1.Type).map((T) => enum_js_1.Type[T]).filter((T) => typeof T === "number" && T !== enum_js_1.Type.NONE);
      for (const typeId of typeIds) {
        const get = get_js_1.instance.getVisitFnByTypeId(typeId);
        const set = set_js_1.instance.getVisitFnByTypeId(typeId);
        const indexOf = indexof_js_1.instance.getVisitFnByTypeId(typeId);
        visitorsByTypeId[typeId] = { get, set, indexOf };
        vectorPrototypesByTypeId[typeId] = Object.create(proto, {
          ["isValid"]: { value: (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid) },
          ["get"]: { value: (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFnByTypeId(typeId)) },
          ["set"]: { value: (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFnByTypeId(typeId)) },
          ["indexOf"]: { value: (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFnByTypeId(typeId)) }
        });
      }
      return "Vector";
    })(Vector.prototype);
    var MemoizedVector = class _MemoizedVector extends Vector {
      constructor(vector) {
        super(vector.data);
        const get = this.get;
        const set = this.set;
        const slice = this.slice;
        const cache = new Array(this.length);
        Object.defineProperty(this, "get", {
          value(index) {
            const cachedValue = cache[index];
            if (cachedValue !== void 0) {
              return cachedValue;
            }
            const value = get.call(this, index);
            cache[index] = value;
            return value;
          }
        });
        Object.defineProperty(this, "set", {
          value(index, value) {
            set.call(this, index, value);
            cache[index] = value;
          }
        });
        Object.defineProperty(this, "slice", {
          value: (begin, end) => new _MemoizedVector(slice.call(this, begin, end))
        });
        Object.defineProperty(this, "isMemoized", { value: true });
        Object.defineProperty(this, "unmemoize", {
          value: () => new Vector(this.data)
        });
        Object.defineProperty(this, "memoize", {
          value: () => this
        });
      }
    };
    var dtypes = require_type2();
    function makeVector(init) {
      if (init) {
        if (init instanceof data_js_1.Data) {
          return new Vector([init]);
        }
        if (init instanceof Vector) {
          return new Vector(init.data);
        }
        if (init.type instanceof type_js_1.DataType) {
          return new Vector([(0, data_js_1.makeData)(init)]);
        }
        if (Array.isArray(init)) {
          return new Vector(init.flatMap((v) => unwrapInputs(v)));
        }
        if (ArrayBuffer.isView(init)) {
          if (init instanceof DataView) {
            init = new Uint8Array(init.buffer);
          }
          const props = { offset: 0, length: init.length, nullCount: -1, data: init };
          if (init instanceof Int8Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int8() }))]);
          }
          if (init instanceof Int16Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int16() }))]);
          }
          if (init instanceof Int32Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int32() }))]);
          }
          if (init instanceof BigInt64Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int64() }))]);
          }
          if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint8() }))]);
          }
          if (init instanceof Uint16Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint16() }))]);
          }
          if (init instanceof Uint32Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint32() }))]);
          }
          if (init instanceof BigUint64Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint64() }))]);
          }
          if (init instanceof Float32Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float32() }))]);
          }
          if (init instanceof Float64Array) {
            return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float64() }))]);
          }
          throw new Error("Unrecognized input");
        }
      }
      throw new Error("Unrecognized input");
    }
    exports2.makeVector = makeVector;
    function unwrapInputs(x) {
      return x instanceof data_js_1.Data ? [x] : x instanceof Vector ? x.data : makeVector(x).data;
    }
  }
});

// node_modules/apache-arrow/builder/valid.js
var require_valid = __commonJS({
  "node_modules/apache-arrow/builder/valid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createIsValidFunction = void 0;
    var pretty_js_1 = require_pretty();
    function createIsValidFunction(nullValues) {
      if (!nullValues || nullValues.length <= 0) {
        return function isValid(value) {
          return true;
        };
      }
      let fnBody = "";
      const noNaNs = nullValues.filter((x) => x === x);
      if (noNaNs.length > 0) {
        fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
      }
      if (nullValues.length !== noNaNs.length) {
        fnBody = `if (x !== x) return false;
${fnBody}`;
      }
      return new Function(`x`, `${fnBody}
return true;`);
    }
    exports2.createIsValidFunction = createIsValidFunction;
    function valueToCase(x) {
      if (typeof x !== "bigint") {
        return (0, pretty_js_1.valueToString)(x);
      }
      return `${(0, pretty_js_1.valueToString)(x)}n`;
    }
  }
});

// node_modules/apache-arrow/builder/buffer.js
var require_buffer3 = __commonJS({
  "node_modules/apache-arrow/builder/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OffsetsBufferBuilder = exports2.BitmapBufferBuilder = exports2.DataBufferBuilder = exports2.BufferBuilder = void 0;
    var buffer_js_1 = require_buffer();
    function roundLengthUpToNearest64Bytes(len, BPE) {
      const bytesMinus1 = Math.ceil(len) * BPE - 1;
      return (bytesMinus1 - bytesMinus1 % 64 + 64 || 64) / BPE;
    }
    function resizeArray(arr, len = 0) {
      return arr.length >= len ? arr.subarray(0, len) : (0, buffer_js_1.memcpy)(new arr.constructor(len), arr, 0);
    }
    var BufferBuilder = class {
      constructor(bufferType, initialSize = 0, stride = 1) {
        this.length = Math.ceil(initialSize / stride);
        this.buffer = new bufferType(this.length);
        this.stride = stride;
        this.BYTES_PER_ELEMENT = bufferType.BYTES_PER_ELEMENT;
        this.ArrayType = bufferType;
      }
      get byteLength() {
        return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
      }
      get reservedLength() {
        return this.buffer.length / this.stride;
      }
      get reservedByteLength() {
        return this.buffer.byteLength;
      }
      // @ts-ignore
      set(index, value) {
        return this;
      }
      append(value) {
        return this.set(this.length, value);
      }
      reserve(extra) {
        if (extra > 0) {
          this.length += extra;
          const stride = this.stride;
          const length = this.length * stride;
          const reserved = this.buffer.length;
          if (length >= reserved) {
            this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
          }
        }
        return this;
      }
      flush(length = this.length) {
        length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
        const array = resizeArray(this.buffer, length);
        this.clear();
        return array;
      }
      clear() {
        this.length = 0;
        this.buffer = new this.ArrayType();
        return this;
      }
      _resize(newLength) {
        return this.buffer = resizeArray(this.buffer, newLength);
      }
    };
    exports2.BufferBuilder = BufferBuilder;
    var DataBufferBuilder = class extends BufferBuilder {
      last() {
        return this.get(this.length - 1);
      }
      get(index) {
        return this.buffer[index];
      }
      set(index, value) {
        this.reserve(index - this.length + 1);
        this.buffer[index * this.stride] = value;
        return this;
      }
    };
    exports2.DataBufferBuilder = DataBufferBuilder;
    var BitmapBufferBuilder = class extends DataBufferBuilder {
      constructor() {
        super(Uint8Array, 0, 1 / 8);
        this.numValid = 0;
      }
      get numInvalid() {
        return this.length - this.numValid;
      }
      get(idx) {
        return this.buffer[idx >> 3] >> idx % 8 & 1;
      }
      set(idx, val) {
        const { buffer } = this.reserve(idx - this.length + 1);
        const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
        val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
        return this;
      }
      clear() {
        this.numValid = 0;
        return super.clear();
      }
    };
    exports2.BitmapBufferBuilder = BitmapBufferBuilder;
    var OffsetsBufferBuilder = class extends DataBufferBuilder {
      constructor(type) {
        super(type.OffsetArrayType, 1, 1);
      }
      append(value) {
        return this.set(this.length - 1, value);
      }
      set(index, value) {
        const offset = this.length - 1;
        const buffer = this.reserve(index - offset + 1).buffer;
        if (offset < index++ && offset >= 0) {
          buffer.fill(buffer[offset], offset, index);
        }
        buffer[index] = buffer[index - 1] + value;
        return this;
      }
      flush(length = this.length - 1) {
        if (length > this.length) {
          this.set(length - 1, this.BYTES_PER_ELEMENT > 4 ? BigInt(0) : 0);
        }
        return super.flush(length + 1);
      }
    };
    exports2.OffsetsBufferBuilder = OffsetsBufferBuilder;
  }
});

// node_modules/apache-arrow/builder.js
var require_builder2 = __commonJS({
  "node_modules/apache-arrow/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VariableWidthBuilder = exports2.FixedWidthBuilder = exports2.Builder = void 0;
    var vector_js_1 = require_vector2();
    var data_js_1 = require_data();
    var map_js_1 = require_map2();
    var type_js_1 = require_type2();
    var valid_js_1 = require_valid();
    var buffer_js_1 = require_buffer3();
    var Builder = class {
      /** @nocollapse */
      // @ts-ignore
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      /** @nocollapse */
      // @ts-ignore
      static throughDOM(options) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      /**
       * Construct a builder with the given Arrow DataType with optional null values,
       * which will be interpreted as "null" when set or appended to the `Builder`.
       * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
       */
      constructor({ "type": type, "nullValues": nulls }) {
        this.length = 0;
        this.finished = false;
        this.type = type;
        this.children = [];
        this.nullValues = nulls;
        this.stride = (0, type_js_1.strideForType)(type);
        this._nulls = new buffer_js_1.BitmapBufferBuilder();
        if (nulls && nulls.length > 0) {
          this._isValid = (0, valid_js_1.createIsValidFunction)(nulls);
        }
      }
      /**
       * Flush the `Builder` and return a `Vector<T>`.
       * @returns {Vector<T>} A `Vector<T>` of the flushed values.
       */
      toVector() {
        return new vector_js_1.Vector([this.flush()]);
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get nullCount() {
        return this._nulls.numInvalid;
      }
      get numChildren() {
        return this.children.length;
      }
      /**
       * @returns The aggregate length (in bytes) of the values that have been written.
       */
      get byteLength() {
        let size = 0;
        const { _offsets, _values, _nulls, _typeIds, children } = this;
        _offsets && (size += _offsets.byteLength);
        _values && (size += _values.byteLength);
        _nulls && (size += _nulls.byteLength);
        _typeIds && (size += _typeIds.byteLength);
        return children.reduce((size2, child) => size2 + child.byteLength, size);
      }
      /**
       * @returns The aggregate number of rows that have been reserved to write new values.
       */
      get reservedLength() {
        return this._nulls.reservedLength;
      }
      /**
       * @returns The aggregate length (in bytes) that has been reserved to write new values.
       */
      get reservedByteLength() {
        let size = 0;
        this._offsets && (size += this._offsets.reservedByteLength);
        this._values && (size += this._values.reservedByteLength);
        this._nulls && (size += this._nulls.reservedByteLength);
        this._typeIds && (size += this._typeIds.reservedByteLength);
        return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
      }
      get valueOffsets() {
        return this._offsets ? this._offsets.buffer : null;
      }
      get values() {
        return this._values ? this._values.buffer : null;
      }
      get nullBitmap() {
        return this._nulls ? this._nulls.buffer : null;
      }
      get typeIds() {
        return this._typeIds ? this._typeIds.buffer : null;
      }
      /**
       * Appends a value (or null) to this `Builder`.
       * This is equivalent to `builder.set(builder.length, value)`.
       * @param {T['TValue'] | TNull } value The value to append.
       */
      append(value) {
        return this.set(this.length, value);
      }
      /**
       * Validates whether a value is valid (true), or null (false)
       * @param {T['TValue'] | TNull } value The value to compare against null the value representations
       */
      isValid(value) {
        return this._isValid(value);
      }
      /**
       * Write a value (or null-value sentinel) at the supplied index.
       * If the value matches one of the null-value representations, a 1-bit is
       * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
       * the null `BitmapBufferBuilder`, and the value is passed to
       * `Builder.prototype.setValue()`.
       * @param {number} index The index of the value to write.
       * @param {T['TValue'] | TNull } value The value to write at the supplied index.
       * @returns {this} The updated `Builder` instance.
       */
      set(index, value) {
        if (this.setValid(index, this.isValid(value))) {
          this.setValue(index, value);
        }
        return this;
      }
      /**
       * Write a value to the underlying buffers at the supplied index, bypassing
       * the null-value check. This is a low-level method that
       * @param {number} index
       * @param {T['TValue'] | TNull } value
       */
      setValue(index, value) {
        this._setValue(this, index, value);
      }
      setValid(index, valid) {
        this.length = this._nulls.set(index, +valid).length;
        return valid;
      }
      // @ts-ignore
      addChild(child, name = `${this.numChildren}`) {
        throw new Error(`Cannot append children to non-nested type "${this.type}"`);
      }
      /**
       * Retrieve the child `Builder` at the supplied `index`, or null if no child
       * exists at that index.
       * @param {number} index The index of the child `Builder` to retrieve.
       * @returns {Builder | null} The child Builder at the supplied index or null.
       */
      getChildAt(index) {
        return this.children[index] || null;
      }
      /**
       * Commit all the values that have been written to their underlying
       * ArrayBuffers, including any child Builders if applicable, and reset
       * the internal `Builder` state.
       * @returns A `Data<T>` of the buffers and children representing the values written.
       */
      flush() {
        let data;
        let typeIds;
        let nullBitmap;
        let valueOffsets;
        const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
        if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
          valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
        } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
          data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
        } else {
          data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
        }
        if (nullCount > 0) {
          nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
        }
        const children = this.children.map((child) => child.flush());
        this.clear();
        return (0, data_js_1.makeData)({
          type,
          length,
          nullCount,
          children,
          "child": children[0],
          data,
          typeIds,
          nullBitmap,
          valueOffsets
        });
      }
      /**
       * Finalize this `Builder`, and child builders if applicable.
       * @returns {this} The finalized `Builder` instance.
       */
      finish() {
        this.finished = true;
        for (const child of this.children)
          child.finish();
        return this;
      }
      /**
       * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
       * @returns {this} The cleared `Builder` instance.
       */
      clear() {
        var _a, _b, _c, _d;
        this.length = 0;
        (_a = this._nulls) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this._values) === null || _b === void 0 ? void 0 : _b.clear();
        (_c = this._offsets) === null || _c === void 0 ? void 0 : _c.clear();
        (_d = this._typeIds) === null || _d === void 0 ? void 0 : _d.clear();
        for (const child of this.children)
          child.clear();
        return this;
      }
    };
    exports2.Builder = Builder;
    Builder.prototype.length = 1;
    Builder.prototype.stride = 1;
    Builder.prototype.children = null;
    Builder.prototype.finished = false;
    Builder.prototype.nullValues = null;
    Builder.prototype._isValid = () => true;
    var FixedWidthBuilder = class extends Builder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.DataBufferBuilder(this.ArrayType, 0, this.stride);
      }
      setValue(index, value) {
        const values = this._values;
        values.reserve(index - values.length + 1);
        return super.setValue(index, value);
      }
    };
    exports2.FixedWidthBuilder = FixedWidthBuilder;
    var VariableWidthBuilder = class extends Builder {
      constructor(opts) {
        super(opts);
        this._pendingLength = 0;
        this._offsets = new buffer_js_1.OffsetsBufferBuilder(opts.type);
      }
      setValue(index, value) {
        const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.length);
        this._pendingLength += value instanceof map_js_1.MapRow ? value[map_js_1.kKeys].length : value.length;
        pending.set(index, value);
      }
      setValid(index, isValid) {
        if (!super.setValid(index, isValid)) {
          (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
          return false;
        }
        return true;
      }
      clear() {
        this._pendingLength = 0;
        this._pending = void 0;
        return super.clear();
      }
      flush() {
        this._flush();
        return super.flush();
      }
      finish() {
        this._flush();
        return super.finish();
      }
      _flush() {
        const pending = this._pending;
        const pendingLength = this._pendingLength;
        this._pendingLength = 0;
        this._pending = void 0;
        if (pending && pending.size > 0) {
          this._flushPending(pending, pendingLength);
        }
        return this;
      }
    };
    exports2.VariableWidthBuilder = VariableWidthBuilder;
  }
});

// node_modules/apache-arrow/fb/block.js
var require_block = __commonJS({
  "node_modules/apache-arrow/fb/block.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Block = void 0;
    var Block = class {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      /**
       * Index to the start of the RecordBlock (note this is past the Message header)
       */
      offset() {
        return this.bb.readInt64(this.bb_pos);
      }
      /**
       * Length of the metadata
       */
      metaDataLength() {
        return this.bb.readInt32(this.bb_pos + 8);
      }
      /**
       * Length of the data (this is aligned so there can be a gap between this and
       * the metadata).
       */
      bodyLength() {
        return this.bb.readInt64(this.bb_pos + 16);
      }
      static sizeOf() {
        return 24;
      }
      static createBlock(builder, offset, metaDataLength, bodyLength) {
        builder.prep(8, 24);
        builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
        builder.pad(4);
        builder.writeInt32(metaDataLength);
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
      }
    };
    exports2.Block = Block;
  }
});

// node_modules/apache-arrow/fb/footer.js
var require_footer = __commonJS({
  "node_modules/apache-arrow/fb/footer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Footer = void 0;
    var flatbuffers = require_flatbuffers();
    var block_js_1 = require_block();
    var key_value_js_1 = require_key_value();
    var metadata_version_js_1 = require_metadata_version();
    var schema_js_1 = require_schema();
    var Footer = class _Footer {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsFooter(bb, obj) {
        return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsFooter(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
      }
      schema(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new schema_js_1.Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
      }
      dictionaries(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
      }
      dictionariesLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      recordBatches(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
      }
      recordBatchesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      /**
       * User-defined metadata
       */
      customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      static startFooter(builder) {
        builder.startObject(5);
      }
      static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
      }
      static addSchema(builder, schemaOffset) {
        builder.addFieldOffset(1, schemaOffset, 0);
      }
      static addDictionaries(builder, dictionariesOffset) {
        builder.addFieldOffset(2, dictionariesOffset, 0);
      }
      static startDictionariesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
      }
      static addRecordBatches(builder, recordBatchesOffset) {
        builder.addFieldOffset(3, recordBatchesOffset, 0);
      }
      static startRecordBatchesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
      }
      static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
      }
      static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static endFooter(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static finishFooterBuffer(builder, offset) {
        builder.finish(offset);
      }
      static finishSizePrefixedFooterBuffer(builder, offset) {
        builder.finish(offset, void 0, true);
      }
    };
    exports2.Footer = Footer;
  }
});

// node_modules/apache-arrow/schema.js
var require_schema2 = __commonJS({
  "node_modules/apache-arrow/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Field = exports2.Schema = void 0;
    var enum_js_1 = require_enum();
    var type_js_1 = require_type2();
    var Schema = class _Schema {
      constructor(fields = [], metadata, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5) {
        this.fields = fields || [];
        this.metadata = metadata || /* @__PURE__ */ new Map();
        if (!dictionaries) {
          dictionaries = generateDictionaryMap(this.fields);
        }
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
      }
      get [Symbol.toStringTag]() {
        return "Schema";
      }
      get names() {
        return this.fields.map((f) => f.name);
      }
      toString() {
        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(", ")} }>`;
      }
      /**
       * Construct a new Schema containing only specified fields.
       *
       * @param fieldNames Names of fields to keep.
       * @returns A new Schema of fields matching the specified names.
       */
      select(fieldNames) {
        const names = new Set(fieldNames);
        const fields = this.fields.filter((f) => names.has(f.name));
        return new _Schema(fields, this.metadata);
      }
      /**
       * Construct a new Schema containing only fields at the specified indices.
       *
       * @param fieldIndices Indices of fields to keep.
       * @returns A new Schema of fields at the specified indices.
       */
      selectAt(fieldIndices) {
        const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
        return new _Schema(fields, this.metadata);
      }
      assign(...args) {
        const other = args[0] instanceof _Schema ? args[0] : Array.isArray(args[0]) ? new _Schema(args[0]) : new _Schema(args);
        const curFields = [...this.fields];
        const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
        const newFields = other.fields.filter((f2) => {
          const i = curFields.findIndex((f) => f.name === f2.name);
          return ~i ? (curFields[i] = f2.clone({
            metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
          })) && false : true;
        });
        const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
        return new _Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
      }
    };
    exports2.Schema = Schema;
    Schema.prototype.fields = null;
    Schema.prototype.metadata = null;
    Schema.prototype.dictionaries = null;
    var Field = class _Field {
      /** @nocollapse */
      static new(...args) {
        let [name, type, nullable, metadata] = args;
        if (args[0] && typeof args[0] === "object") {
          ({ name } = args[0]);
          type === void 0 && (type = args[0].type);
          nullable === void 0 && (nullable = args[0].nullable);
          metadata === void 0 && (metadata = args[0].metadata);
        }
        return new _Field(`${name}`, type, nullable, metadata);
      }
      constructor(name, type, nullable = false, metadata) {
        this.name = name;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata || /* @__PURE__ */ new Map();
      }
      get typeId() {
        return this.type.typeId;
      }
      get [Symbol.toStringTag]() {
        return "Field";
      }
      toString() {
        return `${this.name}: ${this.type}`;
      }
      clone(...args) {
        let [name, type, nullable, metadata] = args;
        !args[0] || typeof args[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
        return _Field.new(name, type, nullable, metadata);
      }
    };
    exports2.Field = Field;
    Field.prototype.type = null;
    Field.prototype.name = null;
    Field.prototype.nullable = null;
    Field.prototype.metadata = null;
    function mergeMaps(m1, m2) {
      return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
    }
    function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
      for (let i = -1, n = fields.length; ++i < n; ) {
        const field = fields[i];
        const type = field.type;
        if (type_js_1.DataType.isDictionary(type)) {
          if (!dictionaries.has(type.id)) {
            dictionaries.set(type.id, type.dictionary);
          } else if (dictionaries.get(type.id) !== type.dictionary) {
            throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
          }
        }
        if (type.children && type.children.length > 0) {
          generateDictionaryMap(type.children, dictionaries);
        }
      }
      return dictionaries;
    }
  }
});

// node_modules/apache-arrow/ipc/metadata/file.js
var require_file = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileBlock = exports2.Footer = void 0;
    var block_js_1 = require_block();
    var footer_js_1 = require_footer();
    var flatbuffers = require_flatbuffers();
    var Builder = flatbuffers.Builder;
    var ByteBuffer = flatbuffers.ByteBuffer;
    var schema_js_1 = require_schema2();
    var enum_js_1 = require_enum();
    var buffer_js_1 = require_buffer();
    var bigint_js_1 = require_bigint();
    var Footer_ = class {
      /** @nocollapse */
      static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_1.toUint8Array)(buf));
        const footer = footer_js_1.Footer.getRootAsFooter(buf);
        const schema = schema_js_1.Schema.decode(footer.schema(), /* @__PURE__ */ new Map(), footer.version());
        return new OffHeapFooter(schema, footer);
      }
      /** @nocollapse */
      static encode(footer) {
        const b = new Builder();
        const schemaOffset = schema_js_1.Schema.encode(b, footer.schema);
        footer_js_1.Footer.startRecordBatchesVector(b, footer.numRecordBatches);
        for (const rb of [...footer.recordBatches()].slice().reverse()) {
          FileBlock.encode(b, rb);
        }
        const recordBatchesOffset = b.endVector();
        footer_js_1.Footer.startDictionariesVector(b, footer.numDictionaries);
        for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
          FileBlock.encode(b, db);
        }
        const dictionaryBatchesOffset = b.endVector();
        footer_js_1.Footer.startFooter(b);
        footer_js_1.Footer.addSchema(b, schemaOffset);
        footer_js_1.Footer.addVersion(b, enum_js_1.MetadataVersion.V5);
        footer_js_1.Footer.addRecordBatches(b, recordBatchesOffset);
        footer_js_1.Footer.addDictionaries(b, dictionaryBatchesOffset);
        footer_js_1.Footer.finishFooterBuffer(b, footer_js_1.Footer.endFooter(b));
        return b.asUint8Array();
      }
      get numRecordBatches() {
        return this._recordBatches.length;
      }
      get numDictionaries() {
        return this._dictionaryBatches.length;
      }
      constructor(schema, version = enum_js_1.MetadataVersion.V5, recordBatches, dictionaryBatches) {
        this.schema = schema;
        this.version = version;
        recordBatches && (this._recordBatches = recordBatches);
        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
      }
      *recordBatches() {
        for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
          if (block = this.getRecordBatch(i)) {
            yield block;
          }
        }
      }
      *dictionaryBatches() {
        for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
          if (block = this.getDictionaryBatch(i)) {
            yield block;
          }
        }
      }
      getRecordBatch(index) {
        return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
      }
      getDictionaryBatch(index) {
        return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
      }
    };
    exports2.Footer = Footer_;
    var OffHeapFooter = class extends Footer_ {
      get numRecordBatches() {
        return this._footer.recordBatchesLength();
      }
      get numDictionaries() {
        return this._footer.dictionariesLength();
      }
      constructor(schema, _footer) {
        super(schema, _footer.version());
        this._footer = _footer;
      }
      getRecordBatch(index) {
        if (index >= 0 && index < this.numRecordBatches) {
          const fileBlock = this._footer.recordBatches(index);
          if (fileBlock) {
            return FileBlock.decode(fileBlock);
          }
        }
        return null;
      }
      getDictionaryBatch(index) {
        if (index >= 0 && index < this.numDictionaries) {
          const fileBlock = this._footer.dictionaries(index);
          if (fileBlock) {
            return FileBlock.decode(fileBlock);
          }
        }
        return null;
      }
    };
    var FileBlock = class _FileBlock {
      /** @nocollapse */
      static decode(block) {
        return new _FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
      }
      /** @nocollapse */
      static encode(b, fileBlock) {
        const { metaDataLength } = fileBlock;
        const offset = BigInt(fileBlock.offset);
        const bodyLength = BigInt(fileBlock.bodyLength);
        return block_js_1.Block.createBlock(b, offset, metaDataLength, bodyLength);
      }
      constructor(metaDataLength, bodyLength, offset) {
        this.metaDataLength = metaDataLength;
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
      }
    };
    exports2.FileBlock = FileBlock;
  }
});

// node_modules/apache-arrow/io/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/apache-arrow/io/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncQueue = exports2.ReadableInterop = exports2.ArrowJSON = exports2.ITERATOR_DONE = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var adapters_js_1 = require_adapters();
    exports2.ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
    var ArrowJSON = class {
      constructor(_json) {
        this._json = _json;
      }
      get schema() {
        return this._json["schema"];
      }
      get batches() {
        return this._json["batches"] || [];
      }
      get dictionaries() {
        return this._json["dictionaries"] || [];
      }
    };
    exports2.ArrowJSON = ArrowJSON;
    var ReadableInterop = class {
      tee() {
        return this._getDOMStream().tee();
      }
      pipe(writable, options) {
        return this._getNodeStream().pipe(writable, options);
      }
      pipeTo(writable, options) {
        return this._getDOMStream().pipeTo(writable, options);
      }
      pipeThrough(duplex, options) {
        return this._getDOMStream().pipeThrough(duplex, options);
      }
      _getDOMStream() {
        return this._DOMStream || (this._DOMStream = this.toDOMStream());
      }
      _getNodeStream() {
        return this._nodeStream || (this._nodeStream = this.toNodeStream());
      }
    };
    exports2.ReadableInterop = ReadableInterop;
    var AsyncQueue = class extends ReadableInterop {
      constructor() {
        super();
        this._values = [];
        this.resolvers = [];
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
      }
      get closed() {
        return this._closedPromise;
      }
      cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.return(reason);
        });
      }
      write(value) {
        if (this._ensureOpen()) {
          this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
        }
      }
      abort(value) {
        if (this._closedPromiseResolve) {
          this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
        }
      }
      close() {
        if (this._closedPromiseResolve) {
          const { resolvers } = this;
          while (resolvers.length > 0) {
            resolvers.shift().resolve(exports2.ITERATOR_DONE);
          }
          this._closedPromiseResolve();
          this._closedPromiseResolve = void 0;
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      toDOMStream(options) {
        return adapters_js_1.default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
      }
      toNodeStream(options) {
        return adapters_js_1.default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
      }
      throw(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.abort(_);
          return exports2.ITERATOR_DONE;
        });
      }
      return(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.close();
          return exports2.ITERATOR_DONE;
        });
      }
      read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return (yield this.next(size, "read")).value;
        });
      }
      peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return (yield this.next(size, "peek")).value;
        });
      }
      next(..._args) {
        if (this._values.length > 0) {
          return Promise.resolve({ done: false, value: this._values.shift() });
        } else if (this._error) {
          return Promise.reject({ done: true, value: this._error.error });
        } else if (!this._closedPromiseResolve) {
          return Promise.resolve(exports2.ITERATOR_DONE);
        } else {
          return new Promise((resolve, reject) => {
            this.resolvers.push({ resolve, reject });
          });
        }
      }
      _ensureOpen() {
        if (this._closedPromiseResolve) {
          return true;
        }
        throw new Error(`AsyncQueue is closed`);
      }
    };
    exports2.AsyncQueue = AsyncQueue;
  }
});

// node_modules/apache-arrow/io/stream.js
var require_stream = __commonJS({
  "node_modules/apache-arrow/io/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncByteStream = exports2.ByteStream = exports2.AsyncByteQueue = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var adapters_js_1 = require_adapters();
    var utf8_js_1 = require_utf8();
    var interfaces_js_1 = require_interfaces();
    var buffer_js_1 = require_buffer();
    var compat_js_1 = require_compat();
    var AsyncByteQueue = class extends interfaces_js_1.AsyncQueue {
      write(value) {
        if ((value = (0, buffer_js_1.toUint8Array)(value)).byteLength > 0) {
          return super.write(value);
        }
      }
      toString(sync = false) {
        return sync ? (0, utf8_js_1.decodeUtf8)(this.toUint8Array(true)) : this.toUint8Array(false).then(utf8_js_1.decodeUtf8);
      }
      toUint8Array(sync = false) {
        return sync ? (0, buffer_js_1.joinUint8Arrays)(this._values)[0] : (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
          var _a, e_1, _b, _c;
          const buffers = [];
          let byteLength = 0;
          try {
            for (var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const chunk = _c;
              buffers.push(chunk);
              byteLength += chunk.byteLength;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return (0, buffer_js_1.joinUint8Arrays)(buffers, byteLength)[0];
        }))();
      }
    };
    exports2.AsyncByteQueue = AsyncByteQueue;
    var ByteStream = class {
      constructor(source) {
        if (source) {
          this.source = new ByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
      }
      [Symbol.iterator]() {
        return this;
      }
      next(value) {
        return this.source.next(value);
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      peek(size) {
        return this.source.peek(size);
      }
      read(size) {
        return this.source.read(size);
      }
    };
    exports2.ByteStream = ByteStream;
    var AsyncByteStream = class _AsyncByteStream {
      constructor(source) {
        if (source instanceof _AsyncByteStream) {
          this.source = source.source;
        } else if (source instanceof AsyncByteQueue) {
          this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        } else if ((0, compat_js_1.isReadableNodeStream)(source)) {
          this.source = new AsyncByteStreamSource(adapters_js_1.default.fromNodeStream(source));
        } else if ((0, compat_js_1.isReadableDOMStream)(source)) {
          this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source));
        } else if ((0, compat_js_1.isFetchResponse)(source)) {
          this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source.body));
        } else if ((0, compat_js_1.isIterable)(source)) {
          this.source = new AsyncByteStreamSource(adapters_js_1.default.fromIterable(source));
        } else if ((0, compat_js_1.isPromise)(source)) {
          this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        } else if ((0, compat_js_1.isAsyncIterable)(source)) {
          this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      next(value) {
        return this.source.next(value);
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      get closed() {
        return this.source.closed;
      }
      cancel(reason) {
        return this.source.cancel(reason);
      }
      peek(size) {
        return this.source.peek(size);
      }
      read(size) {
        return this.source.read(size);
      }
    };
    exports2.AsyncByteStream = AsyncByteStream;
    var ByteStreamSource = class {
      constructor(source) {
        this.source = source;
      }
      cancel(reason) {
        this.return(reason);
      }
      peek(size) {
        return this.next(size, "peek").value;
      }
      read(size) {
        return this.next(size, "read").value;
      }
      next(size, cmd = "read") {
        return this.source.next({ cmd, size });
      }
      throw(value) {
        return Object.create(this.source.throw && this.source.throw(value) || interfaces_js_1.ITERATOR_DONE);
      }
      return(value) {
        return Object.create(this.source.return && this.source.return(value) || interfaces_js_1.ITERATOR_DONE);
      }
    };
    var AsyncByteStreamSource = class {
      constructor(source) {
        this.source = source;
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
      }
      cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.return(reason);
        });
      }
      get closed() {
        return this._closedPromise;
      }
      read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return (yield this.next(size, "read")).value;
        });
      }
      peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return (yield this.next(size, "peek")).value;
        });
      }
      next(size_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (size, cmd = "read") {
          return yield this.source.next({ cmd, size });
        });
      }
      throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const result = this.source.throw && (yield this.source.throw(value)) || interfaces_js_1.ITERATOR_DONE;
          this._closedPromiseResolve && this._closedPromiseResolve();
          this._closedPromiseResolve = void 0;
          return Object.create(result);
        });
      }
      return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const result = this.source.return && (yield this.source.return(value)) || interfaces_js_1.ITERATOR_DONE;
          this._closedPromiseResolve && this._closedPromiseResolve();
          this._closedPromiseResolve = void 0;
          return Object.create(result);
        });
      }
    };
  }
});

// node_modules/apache-arrow/io/file.js
var require_file2 = __commonJS({
  "node_modules/apache-arrow/io/file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncRandomAccessFile = exports2.RandomAccessFile = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var stream_js_1 = require_stream();
    var buffer_js_1 = require_buffer();
    var RandomAccessFile = class extends stream_js_1.ByteStream {
      constructor(buffer, byteLength) {
        super();
        this.position = 0;
        this.buffer = (0, buffer_js_1.toUint8Array)(buffer);
        this.size = byteLength === void 0 ? this.buffer.byteLength : byteLength;
      }
      readInt32(position) {
        const { buffer, byteOffset } = this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      }
      seek(position) {
        this.position = Math.min(position, this.size);
        return position < this.size;
      }
      read(nBytes) {
        const { buffer, size, position } = this;
        if (buffer && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Number.POSITIVE_INFINITY;
          }
          this.position = Math.min(size, position + Math.min(size - position, nBytes));
          return buffer.subarray(position, this.position);
        }
        return null;
      }
      readAt(position, nBytes) {
        const buf = this.buffer;
        const end = Math.min(this.size, position + nBytes);
        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
      }
      close() {
        this.buffer && (this.buffer = null);
      }
      throw(value) {
        this.close();
        return { done: true, value };
      }
      return(value) {
        this.close();
        return { done: true, value };
      }
    };
    exports2.RandomAccessFile = RandomAccessFile;
    var AsyncRandomAccessFile = class extends stream_js_1.AsyncByteStream {
      constructor(file, byteLength) {
        super();
        this.position = 0;
        this._handle = file;
        if (typeof byteLength === "number") {
          this.size = byteLength;
        } else {
          this._pending = (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.size = (yield file.stat()).size;
            delete this._pending;
          }))();
        }
      }
      readInt32(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { buffer, byteOffset } = yield this.readAt(position, 4);
          return new DataView(buffer, byteOffset).getInt32(0, true);
        });
      }
      seek(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this._pending && (yield this._pending);
          this.position = Math.min(position, this.size);
          return position < this.size;
        });
      }
      read(nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this._pending && (yield this._pending);
          const { _handle: file, size, position } = this;
          if (file && position < size) {
            if (typeof nBytes !== "number") {
              nBytes = Number.POSITIVE_INFINITY;
            }
            let pos = position, offset = 0, bytesRead = 0;
            const end = Math.min(size, pos + Math.min(size - pos, nBytes));
            const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
            while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
              ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
            }
            return buffer;
          }
          return null;
        });
      }
      readAt(position, nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this._pending && (yield this._pending);
          const { _handle: file, size } = this;
          if (file && position + nBytes < size) {
            const end = Math.min(size, position + nBytes);
            const buffer = new Uint8Array(end - position);
            return (yield file.read(buffer, 0, nBytes, position)).buffer;
          }
          return new Uint8Array(nBytes);
        });
      }
      close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const f = this._handle;
          this._handle = null;
          f && (yield f.close());
        });
      }
      throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.close();
          return { done: true, value };
        });
      }
      return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.close();
          return { done: true, value };
        });
      }
    };
    exports2.AsyncRandomAccessFile = AsyncRandomAccessFile;
  }
});

// node_modules/apache-arrow/util/int.js
var require_int2 = __commonJS({
  "node_modules/apache-arrow/util/int.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Int128 = exports2.Int64 = exports2.Uint64 = exports2.BaseInt64 = void 0;
    var carryBit16 = 1 << 16;
    function intAsHex(value) {
      if (value < 0) {
        value = 4294967295 + value + 1;
      }
      return `0x${value.toString(16)}`;
    }
    var kInt32DecimalDigits = 8;
    var kPowersOfTen = [
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8
    ];
    var BaseInt64 = class {
      constructor(buffer) {
        this.buffer = buffer;
      }
      high() {
        return this.buffer[1];
      }
      low() {
        return this.buffer[0];
      }
      _times(other) {
        const L = new Uint32Array([
          this.buffer[1] >>> 16,
          this.buffer[1] & 65535,
          this.buffer[0] >>> 16,
          this.buffer[0] & 65535
        ]);
        const R = new Uint32Array([
          other.buffer[1] >>> 16,
          other.buffer[1] & 65535,
          other.buffer[0] >>> 16,
          other.buffer[0] & 65535
        ]);
        let product = L[3] * R[3];
        this.buffer[0] = product & 65535;
        let sum = product >>> 16;
        product = L[2] * R[3];
        sum += product;
        product = L[3] * R[2] >>> 0;
        sum += product;
        this.buffer[0] += sum << 16;
        this.buffer[1] = sum >>> 0 < product ? carryBit16 : 0;
        this.buffer[1] += sum >>> 16;
        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
        this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
        return this;
      }
      _plus(other) {
        const sum = this.buffer[0] + other.buffer[0] >>> 0;
        this.buffer[1] += other.buffer[1];
        if (sum < this.buffer[0] >>> 0) {
          ++this.buffer[1];
        }
        this.buffer[0] = sum;
      }
      lessThan(other) {
        return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
      }
      equals(other) {
        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
      }
      greaterThan(other) {
        return other.lessThan(this);
      }
      hex() {
        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
      }
    };
    exports2.BaseInt64 = BaseInt64;
    var Uint64 = class _Uint64 extends BaseInt64 {
      times(other) {
        this._times(other);
        return this;
      }
      plus(other) {
        this._plus(other);
        return this;
      }
      /** @nocollapse */
      static from(val, out_buffer = new Uint32Array(2)) {
        return _Uint64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromNumber(num, out_buffer = new Uint32Array(2)) {
        return _Uint64.fromString(num.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromString(str, out_buffer = new Uint32Array(2)) {
        const length = str.length;
        const out = new _Uint64(out_buffer);
        for (let posn = 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new _Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
          const multiple = new _Uint64(new Uint32Array([kPowersOfTen[group], 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return out;
      }
      /** @nocollapse */
      static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n; ) {
          _Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
      }
      /** @nocollapse */
      static multiply(left, right) {
        const rtrn = new _Uint64(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      /** @nocollapse */
      static add(left, right) {
        const rtrn = new _Uint64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
    };
    exports2.Uint64 = Uint64;
    var Int64 = class _Int64 extends BaseInt64 {
      negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        if (this.buffer[0] == 0) {
          ++this.buffer[1];
        }
        return this;
      }
      times(other) {
        this._times(other);
        return this;
      }
      plus(other) {
        this._plus(other);
        return this;
      }
      lessThan(other) {
        const this_high = this.buffer[1] << 0;
        const other_high = other.buffer[1] << 0;
        return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
      }
      /** @nocollapse */
      static from(val, out_buffer = new Uint32Array(2)) {
        return _Int64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromNumber(num, out_buffer = new Uint32Array(2)) {
        return _Int64.fromString(num.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromString(str, out_buffer = new Uint32Array(2)) {
        const negate = str.startsWith("-");
        const length = str.length;
        const out = new _Int64(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new _Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
          const multiple = new _Int64(new Uint32Array([kPowersOfTen[group], 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return negate ? out.negate() : out;
      }
      /** @nocollapse */
      static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n; ) {
          _Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
      }
      /** @nocollapse */
      static multiply(left, right) {
        const rtrn = new _Int64(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      /** @nocollapse */
      static add(left, right) {
        const rtrn = new _Int64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
    };
    exports2.Int64 = Int64;
    var Int128 = class _Int128 {
      constructor(buffer) {
        this.buffer = buffer;
      }
      high() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      }
      low() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
      }
      negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        this.buffer[2] = ~this.buffer[2];
        this.buffer[3] = ~this.buffer[3];
        if (this.buffer[0] == 0) {
          ++this.buffer[1];
        }
        if (this.buffer[1] == 0) {
          ++this.buffer[2];
        }
        if (this.buffer[2] == 0) {
          ++this.buffer[3];
        }
        return this;
      }
      times(other) {
        const L0 = new Uint64(new Uint32Array([this.buffer[3], 0]));
        const L1 = new Uint64(new Uint32Array([this.buffer[2], 0]));
        const L2 = new Uint64(new Uint32Array([this.buffer[1], 0]));
        const L3 = new Uint64(new Uint32Array([this.buffer[0], 0]));
        const R0 = new Uint64(new Uint32Array([other.buffer[3], 0]));
        const R1 = new Uint64(new Uint32Array([other.buffer[2], 0]));
        const R2 = new Uint64(new Uint32Array([other.buffer[1], 0]));
        const R3 = new Uint64(new Uint32Array([other.buffer[0], 0]));
        let product = Uint64.multiply(L3, R3);
        this.buffer[0] = product.low();
        const sum = new Uint64(new Uint32Array([product.high(), 0]));
        product = Uint64.multiply(L2, R3);
        sum.plus(product);
        product = Uint64.multiply(L3, R2);
        sum.plus(product);
        this.buffer[1] = sum.low();
        this.buffer[3] = sum.lessThan(product) ? 1 : 0;
        this.buffer[2] = sum.high();
        const high = new Uint64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
        high.plus(Uint64.multiply(L1, R3)).plus(Uint64.multiply(L2, R2)).plus(Uint64.multiply(L3, R1));
        this.buffer[3] += Uint64.multiply(L0, R3).plus(Uint64.multiply(L1, R2)).plus(Uint64.multiply(L2, R1)).plus(Uint64.multiply(L3, R0)).low();
        return this;
      }
      plus(other) {
        const sums = new Uint32Array(4);
        sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
        sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
        sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
        sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
        if (sums[0] < this.buffer[0] >>> 0) {
          ++sums[1];
        }
        if (sums[1] < this.buffer[1] >>> 0) {
          ++sums[2];
        }
        if (sums[2] < this.buffer[2] >>> 0) {
          ++sums[3];
        }
        this.buffer[3] = sums[3];
        this.buffer[2] = sums[2];
        this.buffer[1] = sums[1];
        this.buffer[0] = sums[0];
        return this;
      }
      hex() {
        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
      }
      /** @nocollapse */
      static multiply(left, right) {
        const rtrn = new _Int128(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      /** @nocollapse */
      static add(left, right) {
        const rtrn = new _Int128(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
      /** @nocollapse */
      static from(val, out_buffer = new Uint32Array(4)) {
        return _Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromNumber(num, out_buffer = new Uint32Array(4)) {
        return _Int128.fromString(num.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromString(str, out_buffer = new Uint32Array(4)) {
        const negate = str.startsWith("-");
        const length = str.length;
        const out = new _Int128(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new _Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
          const multiple = new _Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return negate ? out.negate() : out;
      }
      /** @nocollapse */
      static convertArray(values) {
        const data = new Uint32Array(values.length * 4);
        for (let i = -1, n = values.length; ++i < n; ) {
          _Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
        }
        return data;
      }
    };
    exports2.Int128 = Int128;
  }
});

// node_modules/apache-arrow/visitor/vectorloader.js
var require_vectorloader = __commonJS({
  "node_modules/apache-arrow/visitor/vectorloader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONVectorLoader = exports2.VectorLoader = void 0;
    var data_js_1 = require_data();
    var schema_js_1 = require_schema2();
    var type_js_1 = require_type2();
    var visitor_js_1 = require_visitor();
    var bit_js_1 = require_bit();
    var utf8_js_1 = require_utf8();
    var int_js_1 = require_int2();
    var enum_js_1 = require_enum();
    var buffer_js_1 = require_buffer();
    var VectorLoader = class extends visitor_js_1.Visitor {
      constructor(bytes, nodes, buffers, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5) {
        super();
        this.nodesIndex = -1;
        this.buffersIndex = -1;
        this.bytes = bytes;
        this.nodes = nodes;
        this.buffers = buffers;
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
      }
      visit(node) {
        return super.visit(node instanceof schema_js_1.Field ? node.type : node);
      }
      visitNull(type, { length } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length });
      }
      visitBool(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitInt(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
      }
      visitLargeUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
      }
      visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
      }
      visitLargeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
      }
      visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitDate(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitTime(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
      }
      visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
      }
      visitUnion(type, { length, nullCount } = this.nextFieldNode()) {
        if (this.metadataVersion < enum_js_1.MetadataVersion.V5) {
          this.readNullBitmap(type, nullCount);
        }
        return type.mode === enum_js_1.UnionMode.Sparse ? this.visitSparseUnion(type, { length, nullCount }) : this.visitDenseUnion(type, { length, nullCount });
      }
      visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
      }
      visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
      }
      visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
      }
      visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitDuration(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
      }
      visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), "child": this.visit(type.children[0]) });
      }
      visitMap(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
      }
      nextFieldNode() {
        return this.nodes[++this.nodesIndex];
      }
      nextBufferRange() {
        return this.buffers[++this.buffersIndex];
      }
      readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
      }
      readOffsets(type, buffer) {
        return this.readData(type, buffer);
      }
      readTypeIds(type, buffer) {
        return this.readData(type, buffer);
      }
      readData(_type, { length, offset } = this.nextBufferRange()) {
        return this.bytes.subarray(offset, offset + length);
      }
      readDictionary(type) {
        return this.dictionaries.get(type.id);
      }
    };
    exports2.VectorLoader = VectorLoader;
    var JSONVectorLoader = class extends VectorLoader {
      constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
        super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
        this.sources = sources;
      }
      readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
        return nullCount <= 0 ? new Uint8Array(0) : (0, bit_js_1.packBools)(this.sources[offset]);
      }
      readOffsets(_type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(_type.OffsetArrayType, this.sources[offset]));
      }
      readTypeIds(type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, this.sources[offset]));
      }
      readData(type, { offset } = this.nextBufferRange()) {
        const { sources } = this;
        if (type_js_1.DataType.isTimestamp(type)) {
          return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        } else if ((type_js_1.DataType.isInt(type) || type_js_1.DataType.isTime(type)) && type.bitWidth === 64 || type_js_1.DataType.isDuration(type)) {
          return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        } else if (type_js_1.DataType.isDate(type) && type.unit === enum_js_1.DateUnit.MILLISECOND) {
          return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        } else if (type_js_1.DataType.isDecimal(type)) {
          return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int128.convertArray(sources[offset]));
        } else if (type_js_1.DataType.isBinary(type) || type_js_1.DataType.isLargeBinary(type) || type_js_1.DataType.isFixedSizeBinary(type)) {
          return binaryDataFromJSON(sources[offset]);
        } else if (type_js_1.DataType.isBool(type)) {
          return (0, bit_js_1.packBools)(sources[offset]);
        } else if (type_js_1.DataType.isUtf8(type) || type_js_1.DataType.isLargeUtf8(type)) {
          return (0, utf8_js_1.encodeUtf8)(sources[offset].join(""));
        }
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, sources[offset].map((x) => +x)));
      }
    };
    exports2.JSONVectorLoader = JSONVectorLoader;
    function binaryDataFromJSON(values) {
      const joined = values.join("");
      const data = new Uint8Array(joined.length / 2);
      for (let i = 0; i < joined.length; i += 2) {
        data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
      }
      return data;
    }
  }
});

// node_modules/apache-arrow/builder/binary.js
var require_binary2 = __commonJS({
  "node_modules/apache-arrow/builder/binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinaryBuilder = void 0;
    var buffer_js_1 = require_buffer3();
    var builder_js_1 = require_builder2();
    var buffer_js_2 = require_buffer();
    var BinaryBuilder = class extends builder_js_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, (0, buffer_js_2.toUint8Array)(value));
      }
      _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let offset = 0;
        for (const [index, value] of pending) {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            const length = value.length;
            data.set(value, offset);
            offsets.set(index, length);
            offset += length;
          }
        }
      }
    };
    exports2.BinaryBuilder = BinaryBuilder;
  }
});

// node_modules/apache-arrow/builder/largebinary.js
var require_largebinary = __commonJS({
  "node_modules/apache-arrow/builder/largebinary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LargeBinaryBuilder = void 0;
    var buffer_js_1 = require_buffer();
    var buffer_js_2 = require_buffer3();
    var builder_js_1 = require_builder2();
    var LargeBinaryBuilder = class extends builder_js_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_js_2.BufferBuilder(Uint8Array);
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, (0, buffer_js_1.toUint8Array)(value));
      }
      _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let offset = 0;
        for (const [index, value] of pending) {
          if (value === void 0) {
            offsets.set(index, BigInt(0));
          } else {
            const length = value.length;
            data.set(value, offset);
            offsets.set(index, BigInt(length));
            offset += length;
          }
        }
      }
    };
    exports2.LargeBinaryBuilder = LargeBinaryBuilder;
  }
});

// node_modules/apache-arrow/builder/bool.js
var require_bool2 = __commonJS({
  "node_modules/apache-arrow/builder/bool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BoolBuilder = void 0;
    var buffer_js_1 = require_buffer3();
    var builder_js_1 = require_builder2();
    var BoolBuilder = class extends builder_js_1.Builder {
      constructor(options) {
        super(options);
        this._values = new buffer_js_1.BitmapBufferBuilder();
      }
      setValue(index, value) {
        this._values.set(index, +value);
      }
    };
    exports2.BoolBuilder = BoolBuilder;
  }
});

// node_modules/apache-arrow/builder/date.js
var require_date3 = __commonJS({
  "node_modules/apache-arrow/builder/date.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DateMillisecondBuilder = exports2.DateDayBuilder = exports2.DateBuilder = void 0;
    var builder_js_1 = require_builder2();
    var set_js_1 = require_set();
    var DateBuilder = class extends builder_js_1.FixedWidthBuilder {
    };
    exports2.DateBuilder = DateBuilder;
    DateBuilder.prototype._setValue = set_js_1.setDate;
    var DateDayBuilder = class extends DateBuilder {
    };
    exports2.DateDayBuilder = DateDayBuilder;
    DateDayBuilder.prototype._setValue = set_js_1.setDateDay;
    var DateMillisecondBuilder = class extends DateBuilder {
    };
    exports2.DateMillisecondBuilder = DateMillisecondBuilder;
    DateMillisecondBuilder.prototype._setValue = set_js_1.setDateMillisecond;
  }
});

// node_modules/apache-arrow/builder/decimal.js
var require_decimal2 = __commonJS({
  "node_modules/apache-arrow/builder/decimal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecimalBuilder = void 0;
    var builder_js_1 = require_builder2();
    var set_js_1 = require_set();
    var DecimalBuilder = class extends builder_js_1.FixedWidthBuilder {
    };
    exports2.DecimalBuilder = DecimalBuilder;
    DecimalBuilder.prototype._setValue = set_js_1.setDecimal;
  }
});

// node_modules/apache-arrow/builder/dictionary.js
var require_dictionary = __commonJS({
  "node_modules/apache-arrow/builder/dictionary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DictionaryBuilder = void 0;
    var type_js_1 = require_type2();
    var builder_js_1 = require_builder2();
    var factories_js_1 = require_factories();
    var DictionaryBuilder = class extends builder_js_1.Builder {
      constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
        super({ type: new type_js_1.Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
        this._nulls = null;
        this._dictionaryOffset = 0;
        this._keysToIndices = /* @__PURE__ */ Object.create(null);
        this.indices = (0, factories_js_1.makeBuilder)({ "type": this.type.indices, "nullValues": nulls });
        this.dictionary = (0, factories_js_1.makeBuilder)({ "type": this.type.dictionary, "nullValues": null });
        if (typeof hashFn === "function") {
          this.valueToKey = hashFn;
        }
      }
      get values() {
        return this.indices.values;
      }
      get nullCount() {
        return this.indices.nullCount;
      }
      get nullBitmap() {
        return this.indices.nullBitmap;
      }
      get byteLength() {
        return this.indices.byteLength + this.dictionary.byteLength;
      }
      get reservedLength() {
        return this.indices.reservedLength + this.dictionary.reservedLength;
      }
      get reservedByteLength() {
        return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
      }
      isValid(value) {
        return this.indices.isValid(value);
      }
      setValid(index, valid) {
        const indices = this.indices;
        valid = indices.setValid(index, valid);
        this.length = indices.length;
        return valid;
      }
      setValue(index, value) {
        const keysToIndices = this._keysToIndices;
        const key = this.valueToKey(value);
        let idx = keysToIndices[key];
        if (idx === void 0) {
          keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
        }
        return this.indices.setValue(index, idx);
      }
      flush() {
        const type = this.type;
        const prev = this._dictionary;
        const curr = this.dictionary.toVector();
        const data = this.indices.flush().clone(type);
        data.dictionary = prev ? prev.concat(curr) : curr;
        this.finished || (this._dictionaryOffset += curr.length);
        this._dictionary = data.dictionary;
        this.clear();
        return data;
      }
      finish() {
        this.indices.finish();
        this.dictionary.finish();
        this._dictionaryOffset = 0;
        this._keysToIndices = /* @__PURE__ */ Object.create(null);
        return super.finish();
      }
      clear() {
        this.indices.clear();
        this.dictionary.clear();
        return super.clear();
      }
      valueToKey(val) {
        return typeof val === "string" ? val : `${val}`;
      }
    };
    exports2.DictionaryBuilder = DictionaryBuilder;
  }
});

// node_modules/apache-arrow/builder/fixedsizebinary.js
var require_fixedsizebinary = __commonJS({
  "node_modules/apache-arrow/builder/fixedsizebinary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FixedSizeBinaryBuilder = void 0;
    var builder_js_1 = require_builder2();
    var set_js_1 = require_set();
    var FixedSizeBinaryBuilder = class extends builder_js_1.FixedWidthBuilder {
    };
    exports2.FixedSizeBinaryBuilder = FixedSizeBinaryBuilder;
    FixedSizeBinaryBuilder.prototype._setValue = set_js_1.setFixedSizeBinary;
  }
});

// node_modules/apache-arrow/builder/fixedsizelist.js
var require_fixedsizelist = __commonJS({
  "node_modules/apache-arrow/builder/fixedsizelist.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FixedSizeListBuilder = void 0;
    var schema_js_1 = require_schema2();
    var builder_js_1 = require_builder2();
    var type_js_1 = require_type2();
    var FixedSizeListBuilder = class extends builder_js_1.Builder {
      setValue(index, value) {
        const [child] = this.children;
        const start = index * this.stride;
        for (let i = -1, n = value.length; ++i < n; ) {
          child.set(start + i, value[i]);
        }
      }
      addChild(child, name = "0") {
        if (this.numChildren > 0) {
          throw new Error("FixedSizeListBuilder can only have one child.");
        }
        const childIndex = this.children.push(child);
        this.type = new type_js_1.FixedSizeList(this.type.listSize, new schema_js_1.Field(name, child.type, true));
        return childIndex;
      }
    };
    exports2.FixedSizeListBuilder = FixedSizeListBuilder;
  }
});

// node_modules/apache-arrow/builder/float.js
var require_float = __commonJS({
  "node_modules/apache-arrow/builder/float.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Float64Builder = exports2.Float32Builder = exports2.Float16Builder = exports2.FloatBuilder = void 0;
    var math_js_1 = require_math();
    var builder_js_1 = require_builder2();
    var FloatBuilder = class extends builder_js_1.FixedWidthBuilder {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports2.FloatBuilder = FloatBuilder;
    var Float16Builder = class extends FloatBuilder {
      setValue(index, value) {
        super.setValue(index, (0, math_js_1.float64ToUint16)(value));
      }
    };
    exports2.Float16Builder = Float16Builder;
    var Float32Builder = class extends FloatBuilder {
    };
    exports2.Float32Builder = Float32Builder;
    var Float64Builder = class extends FloatBuilder {
    };
    exports2.Float64Builder = Float64Builder;
  }
});

// node_modules/apache-arrow/builder/interval.js
var require_interval2 = __commonJS({
  "node_modules/apache-arrow/builder/interval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntervalYearMonthBuilder = exports2.IntervalDayTimeBuilder = exports2.IntervalBuilder = void 0;
    var builder_js_1 = require_builder2();
    var set_js_1 = require_set();
    var IntervalBuilder = class extends builder_js_1.FixedWidthBuilder {
    };
    exports2.IntervalBuilder = IntervalBuilder;
    IntervalBuilder.prototype._setValue = set_js_1.setIntervalValue;
    var IntervalDayTimeBuilder = class extends IntervalBuilder {
    };
    exports2.IntervalDayTimeBuilder = IntervalDayTimeBuilder;
    IntervalDayTimeBuilder.prototype._setValue = set_js_1.setIntervalDayTime;
    var IntervalYearMonthBuilder = class extends IntervalBuilder {
    };
    exports2.IntervalYearMonthBuilder = IntervalYearMonthBuilder;
    IntervalYearMonthBuilder.prototype._setValue = set_js_1.setIntervalYearMonth;
  }
});

// node_modules/apache-arrow/builder/duration.js
var require_duration2 = __commonJS({
  "node_modules/apache-arrow/builder/duration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DurationNanosecondBuilder = exports2.DurationMicrosecondBuilder = exports2.DurationMillisecondBuilder = exports2.DurationSecondBuilder = exports2.DurationBuilder = void 0;
    var builder_js_1 = require_builder2();
    var set_js_1 = require_set();
    var DurationBuilder = class extends builder_js_1.FixedWidthBuilder {
    };
    exports2.DurationBuilder = DurationBuilder;
    DurationBuilder.prototype._setValue = set_js_1.setDuration;
    var DurationSecondBuilder = class extends DurationBuilder {
    };
    exports2.DurationSecondBuilder = DurationSecondBuilder;
    DurationSecondBuilder.prototype._setValue = set_js_1.setDurationSecond;
    var DurationMillisecondBuilder = class extends DurationBuilder {
    };
    exports2.DurationMillisecondBuilder = DurationMillisecondBuilder;
    DurationMillisecondBuilder.prototype._setValue = set_js_1.setDurationMillisecond;
    var DurationMicrosecondBuilder = class extends DurationBuilder {
    };
    exports2.DurationMicrosecondBuilder = DurationMicrosecondBuilder;
    DurationMicrosecondBuilder.prototype._setValue = set_js_1.setDurationMicrosecond;
    var DurationNanosecondBuilder = class extends DurationBuilder {
    };
    exports2.DurationNanosecondBuilder = DurationNanosecondBuilder;
    DurationNanosecondBuilder.prototype._setValue = set_js_1.setDurationNanosecond;
  }
});

// node_modules/apache-arrow/builder/int.js
var require_int3 = __commonJS({
  "node_modules/apache-arrow/builder/int.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Uint64Builder = exports2.Uint32Builder = exports2.Uint16Builder = exports2.Uint8Builder = exports2.Int64Builder = exports2.Int32Builder = exports2.Int16Builder = exports2.Int8Builder = exports2.IntBuilder = void 0;
    var builder_js_1 = require_builder2();
    var IntBuilder = class extends builder_js_1.FixedWidthBuilder {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports2.IntBuilder = IntBuilder;
    var Int8Builder = class extends IntBuilder {
    };
    exports2.Int8Builder = Int8Builder;
    var Int16Builder = class extends IntBuilder {
    };
    exports2.Int16Builder = Int16Builder;
    var Int32Builder = class extends IntBuilder {
    };
    exports2.Int32Builder = Int32Builder;
    var Int64Builder = class extends IntBuilder {
    };
    exports2.Int64Builder = Int64Builder;
    var Uint8Builder = class extends IntBuilder {
    };
    exports2.Uint8Builder = Uint8Builder;
    var Uint16Builder = class extends IntBuilder {
    };
    exports2.Uint16Builder = Uint16Builder;
    var Uint32Builder = class extends IntBuilder {
    };
    exports2.Uint32Builder = Uint32Builder;
    var Uint64Builder = class extends IntBuilder {
    };
    exports2.Uint64Builder = Uint64Builder;
  }
});

// node_modules/apache-arrow/builder/list.js
var require_list2 = __commonJS({
  "node_modules/apache-arrow/builder/list.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListBuilder = void 0;
    var schema_js_1 = require_schema2();
    var type_js_1 = require_type2();
    var buffer_js_1 = require_buffer3();
    var builder_js_1 = require_builder2();
    var ListBuilder = class extends builder_js_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._offsets = new buffer_js_1.OffsetsBufferBuilder(opts.type);
      }
      addChild(child, name = "0") {
        if (this.numChildren > 0) {
          throw new Error("ListBuilder can only have one child.");
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.List(new schema_js_1.Field(name, child.type, true));
        return this.numChildren - 1;
      }
      _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending) {
          if (typeof value === "undefined") {
            offsets.set(index, 0);
          } else {
            const v = value;
            const n = v.length;
            const start = offsets.set(index, n).buffer[index];
            for (let i = -1; ++i < n; ) {
              child.set(start + i, v[i]);
            }
          }
        }
      }
    };
    exports2.ListBuilder = ListBuilder;
  }
});

// node_modules/apache-arrow/builder/map.js
var require_map3 = __commonJS({
  "node_modules/apache-arrow/builder/map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapBuilder = void 0;
    var schema_js_1 = require_schema2();
    var type_js_1 = require_type2();
    var builder_js_1 = require_builder2();
    var MapBuilder = class extends builder_js_1.VariableWidthBuilder {
      set(index, value) {
        return super.set(index, value);
      }
      setValue(index, value) {
        const row = value instanceof Map ? value : new Map(Object.entries(value));
        const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.size);
        this._pendingLength += row.size;
        pending.set(index, row);
      }
      addChild(child, name = `${this.numChildren}`) {
        if (this.numChildren > 0) {
          throw new Error("ListBuilder can only have one child.");
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.Map_(new schema_js_1.Field(name, child.type, true), this.type.keysSorted);
        return this.numChildren - 1;
      }
      _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending) {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
            for (const val of value.entries()) {
              child.set(idx, val);
              if (++idx >= end)
                break;
            }
          }
        }
      }
    };
    exports2.MapBuilder = MapBuilder;
  }
});

// node_modules/apache-arrow/builder/null.js
var require_null2 = __commonJS({
  "node_modules/apache-arrow/builder/null.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NullBuilder = void 0;
    var builder_js_1 = require_builder2();
    var NullBuilder = class extends builder_js_1.Builder {
      // @ts-ignore
      setValue(index, value) {
      }
      setValid(index, valid) {
        this.length = Math.max(index + 1, this.length);
        return valid;
      }
    };
    exports2.NullBuilder = NullBuilder;
  }
});

// node_modules/apache-arrow/builder/struct.js
var require_struct3 = __commonJS({
  "node_modules/apache-arrow/builder/struct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StructBuilder = void 0;
    var schema_js_1 = require_schema2();
    var builder_js_1 = require_builder2();
    var type_js_1 = require_type2();
    var StructBuilder = class extends builder_js_1.Builder {
      setValue(index, value) {
        const { children, type } = this;
        switch (Array.isArray(value) || value.constructor) {
          case true:
            return type.children.forEach((_, i) => children[i].set(index, value[i]));
          case Map:
            return type.children.forEach((f, i) => children[i].set(index, value.get(f.name)));
          default:
            return type.children.forEach((f, i) => children[i].set(index, value[f.name]));
        }
      }
      /** @inheritdoc */
      setValid(index, valid) {
        if (!super.setValid(index, valid)) {
          this.children.forEach((child) => child.setValid(index, valid));
        }
        return valid;
      }
      addChild(child, name = `${this.numChildren}`) {
        const childIndex = this.children.push(child);
        this.type = new type_js_1.Struct([...this.type.children, new schema_js_1.Field(name, child.type, true)]);
        return childIndex;
      }
    };
    exports2.StructBuilder = StructBuilder;
  }
});

// node_modules/apache-arrow/builder/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/apache-arrow/builder/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimestampNanosecondBuilder = exports2.TimestampMicrosecondBuilder = exports2.TimestampMillisecondBuilder = exports2.TimestampSecondBuilder = exports2.TimestampBuilder = void 0;
    var builder_js_1 = require_builder2();
    var set_js_1 = require_set();
    var TimestampBuilder = class extends builder_js_1.FixedWidthBuilder {
    };
    exports2.TimestampBuilder = TimestampBuilder;
    TimestampBuilder.prototype._setValue = set_js_1.setTimestamp;
    var TimestampSecondBuilder = class extends TimestampBuilder {
    };
    exports2.TimestampSecondBuilder = TimestampSecondBuilder;
    TimestampSecondBuilder.prototype._setValue = set_js_1.setTimestampSecond;
    var TimestampMillisecondBuilder = class extends TimestampBuilder {
    };
    exports2.TimestampMillisecondBuilder = TimestampMillisecondBuilder;
    TimestampMillisecondBuilder.prototype._setValue = set_js_1.setTimestampMillisecond;
    var TimestampMicrosecondBuilder = class extends TimestampBuilder {
    };
    exports2.TimestampMicrosecondBuilder = TimestampMicrosecondBuilder;
    TimestampMicrosecondBuilder.prototype._setValue = set_js_1.setTimestampMicrosecond;
    var TimestampNanosecondBuilder = class extends TimestampBuilder {
    };
    exports2.TimestampNanosecondBuilder = TimestampNanosecondBuilder;
    TimestampNanosecondBuilder.prototype._setValue = set_js_1.setTimestampNanosecond;
  }
});

// node_modules/apache-arrow/builder/time.js
var require_time2 = __commonJS({
  "node_modules/apache-arrow/builder/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeNanosecondBuilder = exports2.TimeMicrosecondBuilder = exports2.TimeMillisecondBuilder = exports2.TimeSecondBuilder = exports2.TimeBuilder = void 0;
    var builder_js_1 = require_builder2();
    var set_js_1 = require_set();
    var TimeBuilder = class extends builder_js_1.FixedWidthBuilder {
    };
    exports2.TimeBuilder = TimeBuilder;
    TimeBuilder.prototype._setValue = set_js_1.setTime;
    var TimeSecondBuilder = class extends TimeBuilder {
    };
    exports2.TimeSecondBuilder = TimeSecondBuilder;
    TimeSecondBuilder.prototype._setValue = set_js_1.setTimeSecond;
    var TimeMillisecondBuilder = class extends TimeBuilder {
    };
    exports2.TimeMillisecondBuilder = TimeMillisecondBuilder;
    TimeMillisecondBuilder.prototype._setValue = set_js_1.setTimeMillisecond;
    var TimeMicrosecondBuilder = class extends TimeBuilder {
    };
    exports2.TimeMicrosecondBuilder = TimeMicrosecondBuilder;
    TimeMicrosecondBuilder.prototype._setValue = set_js_1.setTimeMicrosecond;
    var TimeNanosecondBuilder = class extends TimeBuilder {
    };
    exports2.TimeNanosecondBuilder = TimeNanosecondBuilder;
    TimeNanosecondBuilder.prototype._setValue = set_js_1.setTimeNanosecond;
  }
});

// node_modules/apache-arrow/builder/union.js
var require_union2 = __commonJS({
  "node_modules/apache-arrow/builder/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DenseUnionBuilder = exports2.SparseUnionBuilder = exports2.UnionBuilder = void 0;
    var schema_js_1 = require_schema2();
    var buffer_js_1 = require_buffer3();
    var builder_js_1 = require_builder2();
    var type_js_1 = require_type2();
    var UnionBuilder = class extends builder_js_1.Builder {
      constructor(options) {
        super(options);
        this._typeIds = new buffer_js_1.DataBufferBuilder(Int8Array, 0, 1);
        if (typeof options["valueToChildTypeId"] === "function") {
          this._valueToChildTypeId = options["valueToChildTypeId"];
        }
      }
      get typeIdToChildIndex() {
        return this.type.typeIdToChildIndex;
      }
      append(value, childTypeId) {
        return this.set(this.length, value, childTypeId);
      }
      set(index, value, childTypeId) {
        if (childTypeId === void 0) {
          childTypeId = this._valueToChildTypeId(this, value, index);
        }
        this.setValue(index, value, childTypeId);
        return this;
      }
      setValue(index, value, childTypeId) {
        this._typeIds.set(index, childTypeId);
        const childIndex = this.type.typeIdToChildIndex[childTypeId];
        const child = this.children[childIndex];
        child === null || child === void 0 ? void 0 : child.set(index, value);
      }
      addChild(child, name = `${this.children.length}`) {
        const childTypeId = this.children.push(child);
        const { type: { children, mode, typeIds } } = this;
        const fields = [...children, new schema_js_1.Field(name, child.type)];
        this.type = new type_js_1.Union(mode, [...typeIds, childTypeId], fields);
        return childTypeId;
      }
      /** @ignore */
      // @ts-ignore
      _valueToChildTypeId(builder, value, offset) {
        throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
      }
    };
    exports2.UnionBuilder = UnionBuilder;
    var SparseUnionBuilder = class extends UnionBuilder {
    };
    exports2.SparseUnionBuilder = SparseUnionBuilder;
    var DenseUnionBuilder = class extends UnionBuilder {
      constructor(options) {
        super(options);
        this._offsets = new buffer_js_1.DataBufferBuilder(Int32Array);
      }
      /** @ignore */
      setValue(index, value, childTypeId) {
        const id = this._typeIds.set(index, childTypeId).buffer[index];
        const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
        const denseIndex = this._offsets.set(index, child.length).buffer[index];
        child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
      }
    };
    exports2.DenseUnionBuilder = DenseUnionBuilder;
  }
});

// node_modules/apache-arrow/builder/utf8.js
var require_utf83 = __commonJS({
  "node_modules/apache-arrow/builder/utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utf8Builder = void 0;
    var utf8_js_1 = require_utf8();
    var binary_js_1 = require_binary2();
    var buffer_js_1 = require_buffer3();
    var builder_js_1 = require_builder2();
    var Utf8Builder = class extends builder_js_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, (0, utf8_js_1.encodeUtf8)(value));
      }
      // @ts-ignore
      _flushPending(pending, pendingLength) {
      }
    };
    exports2.Utf8Builder = Utf8Builder;
    Utf8Builder.prototype._flushPending = binary_js_1.BinaryBuilder.prototype._flushPending;
  }
});

// node_modules/apache-arrow/builder/largeutf8.js
var require_largeutf8 = __commonJS({
  "node_modules/apache-arrow/builder/largeutf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LargeUtf8Builder = void 0;
    var utf8_js_1 = require_utf8();
    var buffer_js_1 = require_buffer3();
    var builder_js_1 = require_builder2();
    var largebinary_js_1 = require_largebinary();
    var LargeUtf8Builder = class extends builder_js_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, (0, utf8_js_1.encodeUtf8)(value));
      }
      // @ts-ignore
      _flushPending(pending, pendingLength) {
      }
    };
    exports2.LargeUtf8Builder = LargeUtf8Builder;
    LargeUtf8Builder.prototype._flushPending = largebinary_js_1.LargeBinaryBuilder.prototype._flushPending;
  }
});

// node_modules/apache-arrow/visitor/builderctor.js
var require_builderctor = __commonJS({
  "node_modules/apache-arrow/visitor/builderctor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instance = exports2.GetBuilderCtor = void 0;
    var visitor_js_1 = require_visitor();
    var binary_js_1 = require_binary2();
    var largebinary_js_1 = require_largebinary();
    var bool_js_1 = require_bool2();
    var date_js_1 = require_date3();
    var decimal_js_1 = require_decimal2();
    var dictionary_js_1 = require_dictionary();
    var fixedsizebinary_js_1 = require_fixedsizebinary();
    var fixedsizelist_js_1 = require_fixedsizelist();
    var float_js_1 = require_float();
    var interval_js_1 = require_interval2();
    var duration_js_1 = require_duration2();
    var int_js_1 = require_int3();
    var list_js_1 = require_list2();
    var map_js_1 = require_map3();
    var null_js_1 = require_null2();
    var struct_js_1 = require_struct3();
    var timestamp_js_1 = require_timestamp2();
    var time_js_1 = require_time2();
    var union_js_1 = require_union2();
    var utf8_js_1 = require_utf83();
    var largeutf8_js_1 = require_largeutf8();
    var GetBuilderCtor = class extends visitor_js_1.Visitor {
      visitNull() {
        return null_js_1.NullBuilder;
      }
      visitBool() {
        return bool_js_1.BoolBuilder;
      }
      visitInt() {
        return int_js_1.IntBuilder;
      }
      visitInt8() {
        return int_js_1.Int8Builder;
      }
      visitInt16() {
        return int_js_1.Int16Builder;
      }
      visitInt32() {
        return int_js_1.Int32Builder;
      }
      visitInt64() {
        return int_js_1.Int64Builder;
      }
      visitUint8() {
        return int_js_1.Uint8Builder;
      }
      visitUint16() {
        return int_js_1.Uint16Builder;
      }
      visitUint32() {
        return int_js_1.Uint32Builder;
      }
      visitUint64() {
        return int_js_1.Uint64Builder;
      }
      visitFloat() {
        return float_js_1.FloatBuilder;
      }
      visitFloat16() {
        return float_js_1.Float16Builder;
      }
      visitFloat32() {
        return float_js_1.Float32Builder;
      }
      visitFloat64() {
        return float_js_1.Float64Builder;
      }
      visitUtf8() {
        return utf8_js_1.Utf8Builder;
      }
      visitLargeUtf8() {
        return largeutf8_js_1.LargeUtf8Builder;
      }
      visitBinary() {
        return binary_js_1.BinaryBuilder;
      }
      visitLargeBinary() {
        return largebinary_js_1.LargeBinaryBuilder;
      }
      visitFixedSizeBinary() {
        return fixedsizebinary_js_1.FixedSizeBinaryBuilder;
      }
      visitDate() {
        return date_js_1.DateBuilder;
      }
      visitDateDay() {
        return date_js_1.DateDayBuilder;
      }
      visitDateMillisecond() {
        return date_js_1.DateMillisecondBuilder;
      }
      visitTimestamp() {
        return timestamp_js_1.TimestampBuilder;
      }
      visitTimestampSecond() {
        return timestamp_js_1.TimestampSecondBuilder;
      }
      visitTimestampMillisecond() {
        return timestamp_js_1.TimestampMillisecondBuilder;
      }
      visitTimestampMicrosecond() {
        return timestamp_js_1.TimestampMicrosecondBuilder;
      }
      visitTimestampNanosecond() {
        return timestamp_js_1.TimestampNanosecondBuilder;
      }
      visitTime() {
        return time_js_1.TimeBuilder;
      }
      visitTimeSecond() {
        return time_js_1.TimeSecondBuilder;
      }
      visitTimeMillisecond() {
        return time_js_1.TimeMillisecondBuilder;
      }
      visitTimeMicrosecond() {
        return time_js_1.TimeMicrosecondBuilder;
      }
      visitTimeNanosecond() {
        return time_js_1.TimeNanosecondBuilder;
      }
      visitDecimal() {
        return decimal_js_1.DecimalBuilder;
      }
      visitList() {
        return list_js_1.ListBuilder;
      }
      visitStruct() {
        return struct_js_1.StructBuilder;
      }
      visitUnion() {
        return union_js_1.UnionBuilder;
      }
      visitDenseUnion() {
        return union_js_1.DenseUnionBuilder;
      }
      visitSparseUnion() {
        return union_js_1.SparseUnionBuilder;
      }
      visitDictionary() {
        return dictionary_js_1.DictionaryBuilder;
      }
      visitInterval() {
        return interval_js_1.IntervalBuilder;
      }
      visitIntervalDayTime() {
        return interval_js_1.IntervalDayTimeBuilder;
      }
      visitIntervalYearMonth() {
        return interval_js_1.IntervalYearMonthBuilder;
      }
      visitDuration() {
        return duration_js_1.DurationBuilder;
      }
      visitDurationSecond() {
        return duration_js_1.DurationSecondBuilder;
      }
      visitDurationMillisecond() {
        return duration_js_1.DurationMillisecondBuilder;
      }
      visitDurationMicrosecond() {
        return duration_js_1.DurationMicrosecondBuilder;
      }
      visitDurationNanosecond() {
        return duration_js_1.DurationNanosecondBuilder;
      }
      visitFixedSizeList() {
        return fixedsizelist_js_1.FixedSizeListBuilder;
      }
      visitMap() {
        return map_js_1.MapBuilder;
      }
    };
    exports2.GetBuilderCtor = GetBuilderCtor;
    exports2.instance = new GetBuilderCtor();
  }
});

// node_modules/apache-arrow/visitor/typecomparator.js
var require_typecomparator = __commonJS({
  "node_modules/apache-arrow/visitor/typecomparator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compareTypes = exports2.compareFields = exports2.compareSchemas = exports2.instance = exports2.TypeComparator = void 0;
    var visitor_js_1 = require_visitor();
    var TypeComparator = class extends visitor_js_1.Visitor {
      compareSchemas(schema, other) {
        return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
      }
      compareManyFields(fields, others) {
        return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));
      }
      compareFields(field, other) {
        return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
      }
    };
    exports2.TypeComparator = TypeComparator;
    function compareConstructor(type, other) {
      return other instanceof type.constructor;
    }
    function compareAny(type, other) {
      return type === other || compareConstructor(type, other);
    }
    function compareInt(type, other) {
      return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
    }
    function compareFloat(type, other) {
      return type === other || compareConstructor(type, other) && type.precision === other.precision;
    }
    function compareFixedSizeBinary(type, other) {
      return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
    }
    function compareDate(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit;
    }
    function compareTimestamp(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
    }
    function compareTime(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
    }
    function compareList(type, other) {
      return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports2.instance.compareManyFields(type.children, other.children);
    }
    function compareStruct(type, other) {
      return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports2.instance.compareManyFields(type.children, other.children);
    }
    function compareUnion(type, other) {
      return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i) => x === other.typeIds[i]) && exports2.instance.compareManyFields(type.children, other.children);
    }
    function compareDictionary(type, other) {
      return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && exports2.instance.visit(type.indices, other.indices) && exports2.instance.visit(type.dictionary, other.dictionary);
    }
    function compareInterval(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit;
    }
    function compareDuration(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit;
    }
    function compareFixedSizeList(type, other) {
      return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && exports2.instance.compareManyFields(type.children, other.children);
    }
    function compareMap(type, other) {
      return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && exports2.instance.compareManyFields(type.children, other.children);
    }
    TypeComparator.prototype.visitNull = compareAny;
    TypeComparator.prototype.visitBool = compareAny;
    TypeComparator.prototype.visitInt = compareInt;
    TypeComparator.prototype.visitInt8 = compareInt;
    TypeComparator.prototype.visitInt16 = compareInt;
    TypeComparator.prototype.visitInt32 = compareInt;
    TypeComparator.prototype.visitInt64 = compareInt;
    TypeComparator.prototype.visitUint8 = compareInt;
    TypeComparator.prototype.visitUint16 = compareInt;
    TypeComparator.prototype.visitUint32 = compareInt;
    TypeComparator.prototype.visitUint64 = compareInt;
    TypeComparator.prototype.visitFloat = compareFloat;
    TypeComparator.prototype.visitFloat16 = compareFloat;
    TypeComparator.prototype.visitFloat32 = compareFloat;
    TypeComparator.prototype.visitFloat64 = compareFloat;
    TypeComparator.prototype.visitUtf8 = compareAny;
    TypeComparator.prototype.visitLargeUtf8 = compareAny;
    TypeComparator.prototype.visitBinary = compareAny;
    TypeComparator.prototype.visitLargeBinary = compareAny;
    TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
    TypeComparator.prototype.visitDate = compareDate;
    TypeComparator.prototype.visitDateDay = compareDate;
    TypeComparator.prototype.visitDateMillisecond = compareDate;
    TypeComparator.prototype.visitTimestamp = compareTimestamp;
    TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
    TypeComparator.prototype.visitTime = compareTime;
    TypeComparator.prototype.visitTimeSecond = compareTime;
    TypeComparator.prototype.visitTimeMillisecond = compareTime;
    TypeComparator.prototype.visitTimeMicrosecond = compareTime;
    TypeComparator.prototype.visitTimeNanosecond = compareTime;
    TypeComparator.prototype.visitDecimal = compareAny;
    TypeComparator.prototype.visitList = compareList;
    TypeComparator.prototype.visitStruct = compareStruct;
    TypeComparator.prototype.visitUnion = compareUnion;
    TypeComparator.prototype.visitDenseUnion = compareUnion;
    TypeComparator.prototype.visitSparseUnion = compareUnion;
    TypeComparator.prototype.visitDictionary = compareDictionary;
    TypeComparator.prototype.visitInterval = compareInterval;
    TypeComparator.prototype.visitIntervalDayTime = compareInterval;
    TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
    TypeComparator.prototype.visitDuration = compareDuration;
    TypeComparator.prototype.visitDurationSecond = compareDuration;
    TypeComparator.prototype.visitDurationMillisecond = compareDuration;
    TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
    TypeComparator.prototype.visitDurationNanosecond = compareDuration;
    TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
    TypeComparator.prototype.visitMap = compareMap;
    exports2.instance = new TypeComparator();
    function compareSchemas(schema, other) {
      return exports2.instance.compareSchemas(schema, other);
    }
    exports2.compareSchemas = compareSchemas;
    function compareFields(field, other) {
      return exports2.instance.compareFields(field, other);
    }
    exports2.compareFields = compareFields;
    function compareTypes(type, other) {
      return exports2.instance.visit(type, other);
    }
    exports2.compareTypes = compareTypes;
  }
});

// node_modules/apache-arrow/factories.js
var require_factories = __commonJS({
  "node_modules/apache-arrow/factories.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.builderThroughAsyncIterable = exports2.builderThroughIterable = exports2.tableFromJSON = exports2.vectorFromArray = exports2.makeBuilder = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var schema_js_1 = require_schema2();
    var dtypes = require_type2();
    var data_js_1 = require_data();
    var vector_js_1 = require_vector2();
    var builderctor_js_1 = require_builderctor();
    var table_js_1 = require_table();
    var recordbatch_js_1 = require_recordbatch2();
    var typecomparator_js_1 = require_typecomparator();
    function makeBuilder(options) {
      const type = options.type;
      const builder = new (builderctor_js_1.instance.getVisitFn(type)())(options);
      if (type.children && type.children.length > 0) {
        const children = options["children"] || [];
        const defaultOptions = { "nullValues": options["nullValues"] };
        const getChildOptions = Array.isArray(children) ? (_, i) => children[i] || defaultOptions : ({ name }) => children[name] || defaultOptions;
        for (const [index, field] of type.children.entries()) {
          const { type: type2 } = field;
          const opts = getChildOptions(field, index);
          builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type2 })));
        }
      }
      return builder;
    }
    exports2.makeBuilder = makeBuilder;
    function vectorFromArray(init, type) {
      if (init instanceof data_js_1.Data || init instanceof vector_js_1.Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {
        return (0, vector_js_1.makeVector)(init);
      }
      const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };
      const chunks = [...builderThroughIterable(options)(init)];
      const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
      if (dtypes.DataType.isDictionary(vector.type)) {
        return vector.memoize();
      }
      return vector;
    }
    exports2.vectorFromArray = vectorFromArray;
    function tableFromJSON(array) {
      const vector = vectorFromArray(array);
      const batch = new recordbatch_js_1.RecordBatch(new schema_js_1.Schema(vector.type.children), vector.data[0]);
      return new table_js_1.Table(batch);
    }
    exports2.tableFromJSON = tableFromJSON;
    function inferType(value) {
      if (value.length === 0) {
        return new dtypes.Null();
      }
      let nullsCount = 0;
      let arraysCount = 0;
      let objectsCount = 0;
      let numbersCount = 0;
      let stringsCount = 0;
      let bigintsCount = 0;
      let booleansCount = 0;
      let datesCount = 0;
      for (const val of value) {
        if (val == null) {
          ++nullsCount;
          continue;
        }
        switch (typeof val) {
          case "bigint":
            ++bigintsCount;
            continue;
          case "boolean":
            ++booleansCount;
            continue;
          case "number":
            ++numbersCount;
            continue;
          case "string":
            ++stringsCount;
            continue;
          case "object":
            if (Array.isArray(val)) {
              ++arraysCount;
            } else if (Object.prototype.toString.call(val) === "[object Date]") {
              ++datesCount;
            } else {
              ++objectsCount;
            }
            continue;
        }
        throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected.");
      }
      if (numbersCount + nullsCount === value.length) {
        return new dtypes.Float64();
      } else if (stringsCount + nullsCount === value.length) {
        return new dtypes.Dictionary(new dtypes.Utf8(), new dtypes.Int32());
      } else if (bigintsCount + nullsCount === value.length) {
        return new dtypes.Int64();
      } else if (booleansCount + nullsCount === value.length) {
        return new dtypes.Bool();
      } else if (datesCount + nullsCount === value.length) {
        return new dtypes.TimestampMillisecond();
      } else if (arraysCount + nullsCount === value.length) {
        const array = value;
        const childType = inferType(array[array.findIndex((ary) => ary != null)]);
        if (array.every((ary) => ary == null || (0, typecomparator_js_1.compareTypes)(childType, inferType(ary)))) {
          return new dtypes.List(new schema_js_1.Field("", childType, true));
        }
      } else if (objectsCount + nullsCount === value.length) {
        const fields = /* @__PURE__ */ new Map();
        for (const row of value) {
          for (const key of Object.keys(row)) {
            if (!fields.has(key) && row[key] != null) {
              fields.set(key, new schema_js_1.Field(key, inferType([row[key]]), true));
            }
          }
        }
        return new dtypes.Struct([...fields.values()]);
      }
      throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected.");
    }
    function builderThroughIterable(options) {
      const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
      const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
      const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
      return function* (source) {
        let numChunks = 0;
        const builder = makeBuilder(options);
        for (const value of source) {
          if (builder.append(value)[sizeProperty] >= highWaterMark) {
            ++numChunks && (yield builder.toVector());
          }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
          yield builder.toVector();
        }
      };
    }
    exports2.builderThroughIterable = builderThroughIterable;
    function builderThroughAsyncIterable(options) {
      const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
      const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
      const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
      return function(source) {
        return tslib_1.__asyncGenerator(this, arguments, function* () {
          var _a, e_1, _b, _c;
          let numChunks = 0;
          const builder = makeBuilder(options);
          try {
            for (var _d = true, source_1 = tslib_1.__asyncValues(source), source_1_1; source_1_1 = yield tslib_1.__await(source_1.next()), _a = source_1_1.done, !_a; _d = true) {
              _c = source_1_1.value;
              _d = false;
              const value = _c;
              if (builder.append(value)[sizeProperty] >= highWaterMark) {
                ++numChunks && (yield yield tslib_1.__await(builder.toVector()));
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = source_1.return)) yield tslib_1.__await(_b.call(source_1));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (builder.finish().length > 0 || numChunks === 0) {
            yield yield tslib_1.__await(builder.toVector());
          }
        });
      };
    }
    exports2.builderThroughAsyncIterable = builderThroughAsyncIterable;
  }
});

// node_modules/apache-arrow/util/recordbatch.js
var require_recordbatch = __commonJS({
  "node_modules/apache-arrow/util/recordbatch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distributeVectorsIntoRecordBatches = void 0;
    var data_js_1 = require_data();
    var type_js_1 = require_type2();
    var recordbatch_js_1 = require_recordbatch2();
    function distributeVectorsIntoRecordBatches(schema, vecs) {
      return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
    }
    exports2.distributeVectorsIntoRecordBatches = distributeVectorsIntoRecordBatches;
    function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
      const fields = [...schema.fields];
      const batches = [];
      const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
      let numBatches = 0, batchLength = 0;
      let i = -1;
      const numColumns = cols.length;
      let child, children = [];
      while (memo.numBatches-- > 0) {
        for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
          children[i] = child = cols[i].shift();
          batchLength = Math.min(batchLength, child ? child.length : batchLength);
        }
        if (Number.isFinite(batchLength)) {
          children = distributeChildren(fields, batchLength, children, cols, memo);
          if (batchLength > 0) {
            batches[numBatches++] = (0, data_js_1.makeData)({
              type: new type_js_1.Struct(fields),
              length: batchLength,
              nullCount: 0,
              children: children.slice()
            });
          }
        }
      }
      return [
        schema = schema.assign(fields),
        batches.map((data) => new recordbatch_js_1.RecordBatch(schema, data))
      ];
    }
    function distributeChildren(fields, batchLength, children, columns, memo) {
      var _a;
      const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
      for (let i = -1, n = columns.length; ++i < n; ) {
        const child = children[i];
        const length = child === null || child === void 0 ? void 0 : child.length;
        if (length >= batchLength) {
          if (length === batchLength) {
            children[i] = child;
          } else {
            children[i] = child.slice(0, batchLength);
            memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));
          }
        } else {
          const field = fields[i];
          fields[i] = field.clone({ nullable: true });
          children[i] = (_a = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a !== void 0 ? _a : (0, data_js_1.makeData)({
            type: field.type,
            length: batchLength,
            nullCount: batchLength,
            nullBitmap: new Uint8Array(nullBitmapSize)
          });
        }
      }
      return children;
    }
  }
});

// node_modules/apache-arrow/table.js
var require_table = __commonJS({
  "node_modules/apache-arrow/table.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tableFromArrays = exports2.makeTable = exports2.Table = void 0;
    var enum_js_1 = require_enum();
    var data_js_1 = require_data();
    var factories_js_1 = require_factories();
    var vector_js_1 = require_vector2();
    var schema_js_1 = require_schema2();
    var type_js_1 = require_type2();
    var typecomparator_js_1 = require_typecomparator();
    var recordbatch_js_1 = require_recordbatch();
    var chunk_js_1 = require_chunk();
    var get_js_1 = require_get();
    var set_js_1 = require_set();
    var indexof_js_1 = require_indexof();
    var iterator_js_1 = require_iterator();
    var vector_js_2 = require_vector();
    var recordbatch_js_2 = require_recordbatch2();
    var Table = class _Table {
      constructor(...args) {
        var _b, _c;
        if (args.length === 0) {
          this.batches = [];
          this.schema = new schema_js_1.Schema([]);
          this._offsets = [0];
          return this;
        }
        let schema;
        let offsets;
        if (args[0] instanceof schema_js_1.Schema) {
          schema = args.shift();
        }
        if (args.at(-1) instanceof Uint32Array) {
          offsets = args.pop();
        }
        const unwrap = (x) => {
          if (x) {
            if (x instanceof recordbatch_js_2.RecordBatch) {
              return [x];
            } else if (x instanceof _Table) {
              return x.batches;
            } else if (x instanceof data_js_1.Data) {
              if (x.type instanceof type_js_1.Struct) {
                return [new recordbatch_js_2.RecordBatch(new schema_js_1.Schema(x.type.children), x)];
              }
            } else if (Array.isArray(x)) {
              return x.flatMap((v) => unwrap(v));
            } else if (typeof x[Symbol.iterator] === "function") {
              return [...x].flatMap((v) => unwrap(v));
            } else if (typeof x === "object") {
              const keys = Object.keys(x);
              const vecs = keys.map((k) => new vector_js_1.Vector([x[k]]));
              const batchSchema = schema !== null && schema !== void 0 ? schema : new schema_js_1.Schema(keys.map((k, i) => new schema_js_1.Field(String(k), vecs[i].type, vecs[i].nullable)));
              const [, batches2] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(batchSchema, vecs);
              return batches2.length === 0 ? [new recordbatch_js_2.RecordBatch(x)] : batches2;
            }
          }
          return [];
        };
        const batches = args.flatMap((v) => unwrap(v));
        schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new schema_js_1.Schema([]);
        if (!(schema instanceof schema_js_1.Schema)) {
          throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
        }
        for (const batch of batches) {
          if (!(batch instanceof recordbatch_js_2.RecordBatch)) {
            throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
          }
          if (!(0, typecomparator_js_1.compareSchemas)(schema, batch.schema)) {
            throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
          }
        }
        this.schema = schema;
        this.batches = batches;
        this._offsets = offsets !== null && offsets !== void 0 ? offsets : (0, chunk_js_1.computeChunkOffsets)(this.data);
      }
      /**
       * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
       */
      get data() {
        return this.batches.map(({ data }) => data);
      }
      /**
       * The number of columns in this Table.
       */
      get numCols() {
        return this.schema.fields.length;
      }
      /**
       * The number of rows in this Table.
       */
      get numRows() {
        return this.data.reduce((numRows, data) => numRows + data.length, 0);
      }
      /**
       * The number of null rows in this Table.
       */
      get nullCount() {
        if (this._nullCount === -1) {
          this._nullCount = (0, chunk_js_1.computeChunkNullCounts)(this.data);
        }
        return this._nullCount;
      }
      /**
       * Check whether an element is null.
       *
       * @param index The index at which to read the validity bitmap.
       */
      // @ts-ignore
      isValid(index) {
        return false;
      }
      /**
       * Get an element value by position.
       *
       * @param index The index of the element to read.
       */
      // @ts-ignore
      get(index) {
        return null;
      }
      /**
        * Get an element value by position.
        * @param index The index of the element to read. A negative index will count back from the last element.
        */
      // @ts-ignore
      at(index) {
        return this.get((0, vector_js_2.wrapIndex)(index, this.numRows));
      }
      /**
       * Set an element value by position.
       *
       * @param index The index of the element to write.
       * @param value The value to set.
       */
      // @ts-ignore
      set(index, value) {
        return;
      }
      /**
       * Retrieve the index of the first occurrence of a value in an Vector.
       *
       * @param element The value to locate in the Vector.
       * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
       */
      // @ts-ignore
      indexOf(element, offset) {
        return -1;
      }
      /**
       * Iterator for rows in this Table.
       */
      [Symbol.iterator]() {
        if (this.batches.length > 0) {
          return iterator_js_1.instance.visit(new vector_js_1.Vector(this.data));
        }
        return new Array(0)[Symbol.iterator]();
      }
      /**
       * Return a JavaScript Array of the Table rows.
       *
       * @returns An Array of Table rows.
       */
      toArray() {
        return [...this];
      }
      /**
       * Returns a string representation of the Table rows.
       *
       * @returns A string representation of the Table rows.
       */
      toString() {
        return `[
  ${this.toArray().join(",\n  ")}
]`;
      }
      /**
       * Combines two or more Tables of the same schema.
       *
       * @param others Additional Tables to add to the end of this Tables.
       */
      concat(...others) {
        const schema = this.schema;
        const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
        return new _Table(schema, data.map((data2) => new recordbatch_js_2.RecordBatch(schema, data2)));
      }
      /**
       * Return a zero-copy sub-section of this Table.
       *
       * @param begin The beginning of the specified portion of the Table.
       * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
       */
      slice(begin, end) {
        const schema = this.schema;
        [begin, end] = (0, vector_js_2.clampRange)({ length: this.numRows }, begin, end);
        const data = (0, chunk_js_1.sliceChunks)(this.data, this._offsets, begin, end);
        return new _Table(schema, data.map((chunk) => new recordbatch_js_2.RecordBatch(schema, chunk)));
      }
      /**
       * Returns a child Vector by name, or null if this Vector has no child with the given name.
       *
       * @param name The name of the child to retrieve.
       */
      getChild(name) {
        return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
      }
      /**
       * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
       *
       * @param index The index of the child to retrieve.
       */
      getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
          const data = this.data.map((data2) => data2.children[index]);
          if (data.length === 0) {
            const { type } = this.schema.fields[index];
            const empty = (0, data_js_1.makeData)({ type, length: 0, nullCount: 0 });
            data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
          }
          return new vector_js_1.Vector(data);
        }
        return null;
      }
      /**
       * Sets a child Vector by name.
       *
       * @param name The name of the child to overwrite.
       * @returns A new Table with the supplied child for the specified name.
       */
      setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
      }
      setChildAt(index, child) {
        let schema = this.schema;
        let batches = [...this.batches];
        if (index > -1 && index < this.numCols) {
          if (!child) {
            child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null(), length: this.numRows })]);
          }
          const fields = schema.fields.slice();
          const field = fields[index].clone({ type: child.type });
          const children = this.schema.fields.map((_, i) => this.getChildAt(i));
          [fields[index], children[index]] = [field, child];
          [schema, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, children);
        }
        return new _Table(schema, batches);
      }
      /**
       * Construct a new Table containing only specified columns.
       *
       * @param columnNames Names of columns to keep.
       * @returns A new Table of columns matching the specified names.
       */
      select(columnNames) {
        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
      }
      /**
       * Construct a new Table containing only columns at the specified indices.
       *
       * @param columnIndices Indices of columns to keep.
       * @returns A new Table of columns at the specified indices.
       */
      selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const data = this.batches.map((batch) => batch.selectAt(columnIndices));
        return new _Table(schema, data);
      }
      assign(other) {
        const fields = this.schema.fields;
        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
          const [indices2, oldToNew2] = memo;
          const i = fields.findIndex((f) => f.name === f2.name);
          ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
          return memo;
        }, [[], []]);
        const schema = this.schema.assign(other.schema);
        const columns = [
          ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === void 0 ? this.getChildAt(i) : other.getChildAt(j)),
          ...indices.map((i) => other.getChildAt(i))
        ].filter(Boolean);
        return new _Table(...(0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, columns));
      }
    };
    exports2.Table = Table;
    _a = Symbol.toStringTag;
    Table[_a] = ((proto) => {
      proto.schema = null;
      proto.batches = [];
      proto._offsets = new Uint32Array([0]);
      proto._nullCount = -1;
      proto[Symbol.isConcatSpreadable] = true;
      proto["isValid"] = (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid);
      proto["get"] = (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
      proto["set"] = (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
      proto["indexOf"] = (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
      return "Table";
    })(Table.prototype);
    function makeTable(input) {
      const vecs = {};
      const inputs = Object.entries(input);
      for (const [key, col] of inputs) {
        vecs[key] = (0, vector_js_1.makeVector)(col);
      }
      return new Table(vecs);
    }
    exports2.makeTable = makeTable;
    function tableFromArrays(input) {
      const vecs = {};
      const inputs = Object.entries(input);
      for (const [key, col] of inputs) {
        vecs[key] = (0, factories_js_1.vectorFromArray)(col);
      }
      return new Table(vecs);
    }
    exports2.tableFromArrays = tableFromArrays;
  }
});

// node_modules/apache-arrow/recordbatch.js
var require_recordbatch2 = __commonJS({
  "node_modules/apache-arrow/recordbatch.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._InternalEmptyPlaceholderRecordBatch = exports2.RecordBatch = void 0;
    var data_js_1 = require_data();
    var table_js_1 = require_table();
    var vector_js_1 = require_vector2();
    var schema_js_1 = require_schema2();
    var type_js_1 = require_type2();
    var vector_js_2 = require_vector();
    var get_js_1 = require_get();
    var set_js_1 = require_set();
    var indexof_js_1 = require_indexof();
    var iterator_js_1 = require_iterator();
    var RecordBatch = class _RecordBatch {
      constructor(...args) {
        switch (args.length) {
          case 2: {
            [this.schema] = args;
            if (!(this.schema instanceof schema_js_1.Schema)) {
              throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
            }
            [
              ,
              this.data = (0, data_js_1.makeData)({
                nullCount: 0,
                type: new type_js_1.Struct(this.schema.fields),
                children: this.schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type, nullCount: 0 }))
              })
            ] = args;
            if (!(this.data instanceof data_js_1.Data)) {
              throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
            }
            [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
            break;
          }
          case 1: {
            const [obj] = args;
            const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {
              memo.children[i] = obj[name];
              memo.length = Math.max(memo.length, obj[name].length);
              memo.fields[i] = schema_js_1.Field.new({ name, type: obj[name].type, nullable: true });
              return memo;
            }, {
              length: 0,
              fields: new Array(),
              children: new Array()
            });
            const schema = new schema_js_1.Schema(fields);
            const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length, children, nullCount: 0 });
            [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
            break;
          }
          default:
            throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
        }
      }
      get dictionaries() {
        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
      }
      /**
       * The number of columns in this RecordBatch.
       */
      get numCols() {
        return this.schema.fields.length;
      }
      /**
       * The number of rows in this RecordBatch.
       */
      get numRows() {
        return this.data.length;
      }
      /**
       * The number of null rows in this RecordBatch.
       */
      get nullCount() {
        return this.data.nullCount;
      }
      /**
       * Check whether an row is null.
       * @param index The index at which to read the validity bitmap.
       */
      isValid(index) {
        return this.data.getValid(index);
      }
      /**
       * Get a row by position.
       * @param index The index of the row to read.
       */
      get(index) {
        return get_js_1.instance.visit(this.data, index);
      }
      /**
        * Get a row value by position.
        * @param index The index of the row to read. A negative index will count back from the last row.
        */
      at(index) {
        return this.get((0, vector_js_2.wrapIndex)(index, this.numRows));
      }
      /**
       * Set a row by position.
       * @param index The index of the row to write.
       * @param value The value to set.
       */
      set(index, value) {
        return set_js_1.instance.visit(this.data, index, value);
      }
      /**
       * Retrieve the index of the first occurrence of a row in an RecordBatch.
       * @param element The row to locate in the RecordBatch.
       * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
       */
      indexOf(element, offset) {
        return indexof_js_1.instance.visit(this.data, element, offset);
      }
      /**
       * Iterator for rows in this RecordBatch.
       */
      [Symbol.iterator]() {
        return iterator_js_1.instance.visit(new vector_js_1.Vector([this.data]));
      }
      /**
       * Return a JavaScript Array of the RecordBatch rows.
       * @returns An Array of RecordBatch rows.
       */
      toArray() {
        return [...this];
      }
      /**
       * Combines two or more RecordBatch of the same schema.
       * @param others Additional RecordBatch to add to the end of this RecordBatch.
       */
      concat(...others) {
        return new table_js_1.Table(this.schema, [this, ...others]);
      }
      /**
       * Return a zero-copy sub-section of this RecordBatch.
       * @param start The beginning of the specified portion of the RecordBatch.
       * @param end The end of the specified portion of the RecordBatch. This is exclusive of the row at the index 'end'.
       */
      slice(begin, end) {
        const [slice] = new vector_js_1.Vector([this.data]).slice(begin, end).data;
        return new _RecordBatch(this.schema, slice);
      }
      /**
       * Returns a child Vector by name, or null if this Vector has no child with the given name.
       * @param name The name of the child to retrieve.
       */
      getChild(name) {
        var _b;
        return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
      }
      /**
       * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
       * @param index The index of the child to retrieve.
       */
      getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
          return new vector_js_1.Vector([this.data.children[index]]);
        }
        return null;
      }
      /**
       * Sets a child Vector by name.
       * @param name The name of the child to overwrite.
       * @returns A new RecordBatch with the new child for the specified name.
       */
      setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
      }
      setChildAt(index, child) {
        let schema = this.schema;
        let data = this.data;
        if (index > -1 && index < this.numCols) {
          if (!child) {
            child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null(), length: this.numRows })]);
          }
          const fields = schema.fields.slice();
          const children = data.children.slice();
          const field = fields[index].clone({ type: child.type });
          [fields[index], children[index]] = [field, child.data[0]];
          schema = new schema_js_1.Schema(fields, new Map(this.schema.metadata));
          data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), children });
        }
        return new _RecordBatch(schema, data);
      }
      /**
       * Construct a new RecordBatch containing only specified columns.
       *
       * @param columnNames Names of columns to keep.
       * @returns A new RecordBatch of columns matching the specified names.
       */
      select(columnNames) {
        const schema = this.schema.select(columnNames);
        const type = new type_js_1.Struct(schema.fields);
        const children = [];
        for (const name of columnNames) {
          const index = this.schema.fields.findIndex((f) => f.name === name);
          if (~index) {
            children[index] = this.data.children[index];
          }
        }
        return new _RecordBatch(schema, (0, data_js_1.makeData)({ type, length: this.numRows, children }));
      }
      /**
       * Construct a new RecordBatch containing only columns at the specified indices.
       *
       * @param columnIndices Indices of columns to keep.
       * @returns A new RecordBatch of columns matching at the specified indices.
       */
      selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
        const subset = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), length: this.numRows, children });
        return new _RecordBatch(schema, subset);
      }
    };
    exports2.RecordBatch = RecordBatch;
    _a = Symbol.toStringTag;
    RecordBatch[_a] = ((proto) => {
      proto._nullCount = -1;
      proto[Symbol.isConcatSpreadable] = true;
      return "RecordBatch";
    })(RecordBatch.prototype);
    function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
      var _b;
      const fields = [...schema.fields];
      const children = [...chunks];
      const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
      for (const [idx, field] of schema.fields.entries()) {
        const chunk = chunks[idx];
        if (!chunk || chunk.length !== maxLength) {
          fields[idx] = field.clone({ nullable: true });
          children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : (0, data_js_1.makeData)({
            type: field.type,
            length: maxLength,
            nullCount: maxLength,
            nullBitmap: new Uint8Array(nullBitmapSize)
          });
        }
      }
      return [
        schema.assign(fields),
        (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length: maxLength, children })
      ];
    }
    function collectDictionaries(fields, children, dictionaries = /* @__PURE__ */ new Map()) {
      var _b, _c;
      if (((_b = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b !== void 0 ? _b : 0) > 0 && (fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length)) {
        for (let i = -1, n = fields.length; ++i < n; ) {
          const { type } = fields[i];
          const data = children[i];
          for (const next of [data, ...((_c = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c === void 0 ? void 0 : _c.data) || []]) {
            collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
          }
          if (type_js_1.DataType.isDictionary(type)) {
            const { id } = type;
            if (!dictionaries.has(id)) {
              if (data === null || data === void 0 ? void 0 : data.dictionary) {
                dictionaries.set(id, data.dictionary);
              }
            } else if (dictionaries.get(id) !== data.dictionary) {
              throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
            }
          }
        }
      }
      return dictionaries;
    }
    var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {
      constructor(schema) {
        const children = schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type }));
        const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), nullCount: 0, children });
        super(schema, data);
      }
    };
    exports2._InternalEmptyPlaceholderRecordBatch = _InternalEmptyPlaceholderRecordBatch;
  }
});

// node_modules/apache-arrow/fb/message.js
var require_message = __commonJS({
  "node_modules/apache-arrow/fb/message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = void 0;
    var flatbuffers = require_flatbuffers();
    var key_value_js_1 = require_key_value();
    var message_header_js_1 = require_message_header();
    var metadata_version_js_1 = require_metadata_version();
    var Message = class _Message {
      constructor() {
        this.bb = null;
        this.bb_pos = 0;
      }
      __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
      }
      static getRootAsMessage(bb, obj) {
        return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      static getSizePrefixedRootAsMessage(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
      }
      version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
      }
      headerType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : message_header_js_1.MessageHeader.NONE;
      }
      header(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
      }
      bodyLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
      }
      customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
      }
      customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
      }
      static startMessage(builder) {
        builder.startObject(5);
      }
      static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
      }
      static addHeaderType(builder, headerType) {
        builder.addFieldInt8(1, headerType, message_header_js_1.MessageHeader.NONE);
      }
      static addHeader(builder, headerOffset) {
        builder.addFieldOffset(2, headerOffset, 0);
      }
      static addBodyLength(builder, bodyLength) {
        builder.addFieldInt64(3, bodyLength, BigInt("0"));
      }
      static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
      }
      static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
          builder.addOffset(data[i]);
        }
        return builder.endVector();
      }
      static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
      }
      static endMessage(builder) {
        const offset = builder.endObject();
        return offset;
      }
      static finishMessageBuffer(builder, offset) {
        builder.finish(offset);
      }
      static finishSizePrefixedMessageBuffer(builder, offset) {
        builder.finish(offset, void 0, true);
      }
      static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
        _Message.startMessage(builder);
        _Message.addVersion(builder, version);
        _Message.addHeaderType(builder, headerType);
        _Message.addHeader(builder, headerOffset);
        _Message.addBodyLength(builder, bodyLength);
        _Message.addCustomMetadata(builder, customMetadataOffset);
        return _Message.endMessage(builder);
      }
    };
    exports2.Message = Message;
  }
});

// node_modules/apache-arrow/visitor/typeassembler.js
var require_typeassembler = __commonJS({
  "node_modules/apache-arrow/visitor/typeassembler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instance = exports2.TypeAssembler = void 0;
    var visitor_js_1 = require_visitor();
    var null_js_1 = require_null();
    var int_js_1 = require_int();
    var floating_point_js_1 = require_floating_point();
    var binary_js_1 = require_binary();
    var large_binary_js_1 = require_large_binary();
    var bool_js_1 = require_bool();
    var utf8_js_1 = require_utf82();
    var large_utf8_js_1 = require_large_utf8();
    var decimal_js_1 = require_decimal();
    var date_js_1 = require_date2();
    var time_js_1 = require_time();
    var timestamp_js_1 = require_timestamp();
    var interval_js_1 = require_interval();
    var duration_js_1 = require_duration();
    var list_js_1 = require_list();
    var struct__js_1 = require_struct();
    var union_js_1 = require_union();
    var dictionary_encoding_js_1 = require_dictionary_encoding();
    var fixed_size_binary_js_1 = require_fixed_size_binary();
    var fixed_size_list_js_1 = require_fixed_size_list();
    var map_js_1 = require_map();
    var TypeAssembler = class extends visitor_js_1.Visitor {
      visit(node, builder) {
        return node == null || builder == null ? void 0 : super.visit(node, builder);
      }
      visitNull(_node, b) {
        null_js_1.Null.startNull(b);
        return null_js_1.Null.endNull(b);
      }
      visitInt(node, b) {
        int_js_1.Int.startInt(b);
        int_js_1.Int.addBitWidth(b, node.bitWidth);
        int_js_1.Int.addIsSigned(b, node.isSigned);
        return int_js_1.Int.endInt(b);
      }
      visitFloat(node, b) {
        floating_point_js_1.FloatingPoint.startFloatingPoint(b);
        floating_point_js_1.FloatingPoint.addPrecision(b, node.precision);
        return floating_point_js_1.FloatingPoint.endFloatingPoint(b);
      }
      visitBinary(_node, b) {
        binary_js_1.Binary.startBinary(b);
        return binary_js_1.Binary.endBinary(b);
      }
      visitLargeBinary(_node, b) {
        large_binary_js_1.LargeBinary.startLargeBinary(b);
        return large_binary_js_1.LargeBinary.endLargeBinary(b);
      }
      visitBool(_node, b) {
        bool_js_1.Bool.startBool(b);
        return bool_js_1.Bool.endBool(b);
      }
      visitUtf8(_node, b) {
        utf8_js_1.Utf8.startUtf8(b);
        return utf8_js_1.Utf8.endUtf8(b);
      }
      visitLargeUtf8(_node, b) {
        large_utf8_js_1.LargeUtf8.startLargeUtf8(b);
        return large_utf8_js_1.LargeUtf8.endLargeUtf8(b);
      }
      visitDecimal(node, b) {
        decimal_js_1.Decimal.startDecimal(b);
        decimal_js_1.Decimal.addScale(b, node.scale);
        decimal_js_1.Decimal.addPrecision(b, node.precision);
        decimal_js_1.Decimal.addBitWidth(b, node.bitWidth);
        return decimal_js_1.Decimal.endDecimal(b);
      }
      visitDate(node, b) {
        date_js_1.Date.startDate(b);
        date_js_1.Date.addUnit(b, node.unit);
        return date_js_1.Date.endDate(b);
      }
      visitTime(node, b) {
        time_js_1.Time.startTime(b);
        time_js_1.Time.addUnit(b, node.unit);
        time_js_1.Time.addBitWidth(b, node.bitWidth);
        return time_js_1.Time.endTime(b);
      }
      visitTimestamp(node, b) {
        const timezone = node.timezone && b.createString(node.timezone) || void 0;
        timestamp_js_1.Timestamp.startTimestamp(b);
        timestamp_js_1.Timestamp.addUnit(b, node.unit);
        if (timezone !== void 0) {
          timestamp_js_1.Timestamp.addTimezone(b, timezone);
        }
        return timestamp_js_1.Timestamp.endTimestamp(b);
      }
      visitInterval(node, b) {
        interval_js_1.Interval.startInterval(b);
        interval_js_1.Interval.addUnit(b, node.unit);
        return interval_js_1.Interval.endInterval(b);
      }
      visitDuration(node, b) {
        duration_js_1.Duration.startDuration(b);
        duration_js_1.Duration.addUnit(b, node.unit);
        return duration_js_1.Duration.endDuration(b);
      }
      visitList(_node, b) {
        list_js_1.List.startList(b);
        return list_js_1.List.endList(b);
      }
      visitStruct(_node, b) {
        struct__js_1.Struct_.startStruct_(b);
        return struct__js_1.Struct_.endStruct_(b);
      }
      visitUnion(node, b) {
        union_js_1.Union.startTypeIdsVector(b, node.typeIds.length);
        const typeIds = union_js_1.Union.createTypeIdsVector(b, node.typeIds);
        union_js_1.Union.startUnion(b);
        union_js_1.Union.addMode(b, node.mode);
        union_js_1.Union.addTypeIds(b, typeIds);
        return union_js_1.Union.endUnion(b);
      }
      visitDictionary(node, b) {
        const indexType = this.visit(node.indices, b);
        dictionary_encoding_js_1.DictionaryEncoding.startDictionaryEncoding(b);
        dictionary_encoding_js_1.DictionaryEncoding.addId(b, BigInt(node.id));
        dictionary_encoding_js_1.DictionaryEncoding.addIsOrdered(b, node.isOrdered);
        if (indexType !== void 0) {
          dictionary_encoding_js_1.DictionaryEncoding.addIndexType(b, indexType);
        }
        return dictionary_encoding_js_1.DictionaryEncoding.endDictionaryEncoding(b);
      }
      visitFixedSizeBinary(node, b) {
        fixed_size_binary_js_1.FixedSizeBinary.startFixedSizeBinary(b);
        fixed_size_binary_js_1.FixedSizeBinary.addByteWidth(b, node.byteWidth);
        return fixed_size_binary_js_1.FixedSizeBinary.endFixedSizeBinary(b);
      }
      visitFixedSizeList(node, b) {
        fixed_size_list_js_1.FixedSizeList.startFixedSizeList(b);
        fixed_size_list_js_1.FixedSizeList.addListSize(b, node.listSize);
        return fixed_size_list_js_1.FixedSizeList.endFixedSizeList(b);
      }
      visitMap(node, b) {
        map_js_1.Map.startMap(b);
        map_js_1.Map.addKeysSorted(b, node.keysSorted);
        return map_js_1.Map.endMap(b);
      }
    };
    exports2.TypeAssembler = TypeAssembler;
    exports2.instance = new TypeAssembler();
  }
});

// node_modules/apache-arrow/ipc/metadata/json.js
var require_json = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fieldFromJSON = exports2.dictionaryBatchFromJSON = exports2.recordBatchFromJSON = exports2.schemaFromJSON = void 0;
    var schema_js_1 = require_schema2();
    var type_js_1 = require_type2();
    var message_js_1 = require_message2();
    var enum_js_1 = require_enum();
    function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
      return new schema_js_1.Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["metadata"]), dictionaries);
    }
    exports2.schemaFromJSON = schemaFromJSON;
    function recordBatchFromJSON(b) {
      return new message_js_1.RecordBatch(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
    }
    exports2.recordBatchFromJSON = recordBatchFromJSON;
    function dictionaryBatchFromJSON(b) {
      return new message_js_1.DictionaryBatch(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
    }
    exports2.dictionaryBatchFromJSON = dictionaryBatchFromJSON;
    function schemaFieldsFromJSON(_schema, dictionaries) {
      return (_schema["fields"] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
    }
    function fieldChildrenFromJSON(_field, dictionaries) {
      return (_field["children"] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
    }
    function fieldNodesFromJSON(xs) {
      return (xs || []).reduce((fieldNodes, column) => [
        ...fieldNodes,
        new message_js_1.FieldNode(column["count"], nullCountFromJSON(column["VALIDITY"])),
        ...fieldNodesFromJSON(column["children"])
      ], []);
    }
    function buffersFromJSON(xs, buffers = []) {
      for (let i = -1, n = (xs || []).length; ++i < n; ) {
        const column = xs[i];
        column["VALIDITY"] && buffers.push(new message_js_1.BufferRegion(buffers.length, column["VALIDITY"].length));
        column["TYPE_ID"] && buffers.push(new message_js_1.BufferRegion(buffers.length, column["TYPE_ID"].length));
        column["OFFSET"] && buffers.push(new message_js_1.BufferRegion(buffers.length, column["OFFSET"].length));
        column["DATA"] && buffers.push(new message_js_1.BufferRegion(buffers.length, column["DATA"].length));
        buffers = buffersFromJSON(column["children"], buffers);
      }
      return buffers;
    }
    function nullCountFromJSON(validity) {
      return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);
    }
    function fieldFromJSON(_field, dictionaries) {
      let id;
      let keys;
      let field;
      let dictMeta;
      let type;
      let dictType;
      if (!dictionaries || !(dictMeta = _field["dictionary"])) {
        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
        field = new schema_js_1.Field(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
      } else if (!dictionaries.has(id = dictMeta["id"])) {
        keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
        dictType = new type_js_1.Dictionary(type, keys, id, dictMeta["isOrdered"]);
        field = new schema_js_1.Field(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
      } else {
        keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictType = new type_js_1.Dictionary(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
        field = new schema_js_1.Field(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
      }
      return field || null;
    }
    exports2.fieldFromJSON = fieldFromJSON;
    function customMetadataFromJSON(metadata = []) {
      return new Map(metadata.map(({ key, value }) => [key, value]));
    }
    function indexTypeFromJSON(_type) {
      return new type_js_1.Int(_type["isSigned"], _type["bitWidth"]);
    }
    function typeFromJSON(f, children) {
      const typeId = f["type"]["name"];
      switch (typeId) {
        case "NONE":
          return new type_js_1.Null();
        case "null":
          return new type_js_1.Null();
        case "binary":
          return new type_js_1.Binary();
        case "largebinary":
          return new type_js_1.LargeBinary();
        case "utf8":
          return new type_js_1.Utf8();
        case "largeutf8":
          return new type_js_1.LargeUtf8();
        case "bool":
          return new type_js_1.Bool();
        case "list":
          return new type_js_1.List((children || [])[0]);
        case "struct":
          return new type_js_1.Struct(children || []);
        case "struct_":
          return new type_js_1.Struct(children || []);
      }
      switch (typeId) {
        case "int": {
          const t = f["type"];
          return new type_js_1.Int(t["isSigned"], t["bitWidth"]);
        }
        case "floatingpoint": {
          const t = f["type"];
          return new type_js_1.Float(enum_js_1.Precision[t["precision"]]);
        }
        case "decimal": {
          const t = f["type"];
          return new type_js_1.Decimal(t["scale"], t["precision"], t["bitWidth"]);
        }
        case "date": {
          const t = f["type"];
          return new type_js_1.Date_(enum_js_1.DateUnit[t["unit"]]);
        }
        case "time": {
          const t = f["type"];
          return new type_js_1.Time(enum_js_1.TimeUnit[t["unit"]], t["bitWidth"]);
        }
        case "timestamp": {
          const t = f["type"];
          return new type_js_1.Timestamp(enum_js_1.TimeUnit[t["unit"]], t["timezone"]);
        }
        case "interval": {
          const t = f["type"];
          return new type_js_1.Interval(enum_js_1.IntervalUnit[t["unit"]]);
        }
        case "duration": {
          const t = f["type"];
          return new type_js_1.Duration(enum_js_1.TimeUnit[t["unit"]]);
        }
        case "union": {
          const t = f["type"];
          const [m, ...ms] = (t["mode"] + "").toLowerCase();
          const mode = m.toUpperCase() + ms.join("");
          return new type_js_1.Union(enum_js_1.UnionMode[mode], t["typeIds"] || [], children || []);
        }
        case "fixedsizebinary": {
          const t = f["type"];
          return new type_js_1.FixedSizeBinary(t["byteWidth"]);
        }
        case "fixedsizelist": {
          const t = f["type"];
          return new type_js_1.FixedSizeList(t["listSize"], (children || [])[0]);
        }
        case "map": {
          const t = f["type"];
          return new type_js_1.Map_((children || [])[0], t["keysSorted"]);
        }
      }
      throw new Error(`Unrecognized type: "${typeId}"`);
    }
  }
});

// node_modules/apache-arrow/ipc/metadata/message.js
var require_message2 = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FieldNode = exports2.BufferRegion = exports2.DictionaryBatch = exports2.RecordBatch = exports2.Message = void 0;
    var flatbuffers = require_flatbuffers();
    var schema_js_1 = require_schema();
    var int_js_1 = require_int();
    var record_batch_js_1 = require_record_batch();
    var dictionary_batch_js_1 = require_dictionary_batch();
    var buffer_js_1 = require_buffer2();
    var field_js_1 = require_field();
    var field_node_js_1 = require_field_node();
    var type_js_1 = require_type();
    var key_value_js_1 = require_key_value();
    var endianness_js_1 = require_endianness();
    var floating_point_js_1 = require_floating_point();
    var decimal_js_1 = require_decimal();
    var date_js_1 = require_date2();
    var time_js_1 = require_time();
    var timestamp_js_1 = require_timestamp();
    var interval_js_1 = require_interval();
    var duration_js_1 = require_duration();
    var union_js_1 = require_union();
    var fixed_size_binary_js_1 = require_fixed_size_binary();
    var fixed_size_list_js_1 = require_fixed_size_list();
    var map_js_1 = require_map();
    var message_js_1 = require_message();
    var schema_js_2 = require_schema2();
    var buffer_js_2 = require_buffer();
    var bigint_js_1 = require_bigint();
    var enum_js_1 = require_enum();
    var typeassembler_js_1 = require_typeassembler();
    var json_js_1 = require_json();
    var Builder = flatbuffers.Builder;
    var ByteBuffer = flatbuffers.ByteBuffer;
    var type_js_2 = require_type2();
    var Message = class _Message {
      /** @nocollapse */
      static fromJSON(msg, headerType) {
        const message = new _Message(0, enum_js_1.MetadataVersion.V5, headerType);
        message._createHeader = messageHeaderFromJSON(msg, headerType);
        return message;
      }
      /** @nocollapse */
      static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_2.toUint8Array)(buf));
        const _message = message_js_1.Message.getRootAsMessage(buf);
        const bodyLength = _message.bodyLength();
        const version = _message.version();
        const headerType = _message.headerType();
        const message = new _Message(bodyLength, version, headerType);
        message._createHeader = decodeMessageHeader(_message, headerType);
        return message;
      }
      /** @nocollapse */
      static encode(message) {
        const b = new Builder();
        let headerOffset = -1;
        if (message.isSchema()) {
          headerOffset = schema_js_2.Schema.encode(b, message.header());
        } else if (message.isRecordBatch()) {
          headerOffset = RecordBatch.encode(b, message.header());
        } else if (message.isDictionaryBatch()) {
          headerOffset = DictionaryBatch.encode(b, message.header());
        }
        message_js_1.Message.startMessage(b);
        message_js_1.Message.addVersion(b, enum_js_1.MetadataVersion.V5);
        message_js_1.Message.addHeader(b, headerOffset);
        message_js_1.Message.addHeaderType(b, message.headerType);
        message_js_1.Message.addBodyLength(b, BigInt(message.bodyLength));
        message_js_1.Message.finishMessageBuffer(b, message_js_1.Message.endMessage(b));
        return b.asUint8Array();
      }
      /** @nocollapse */
      static from(header, bodyLength = 0) {
        if (header instanceof schema_js_2.Schema) {
          return new _Message(0, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.Schema, header);
        }
        if (header instanceof RecordBatch) {
          return new _Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.RecordBatch, header);
        }
        if (header instanceof DictionaryBatch) {
          return new _Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.DictionaryBatch, header);
        }
        throw new Error(`Unrecognized Message header: ${header}`);
      }
      get type() {
        return this.headerType;
      }
      get version() {
        return this._version;
      }
      get headerType() {
        return this._headerType;
      }
      get bodyLength() {
        return this._bodyLength;
      }
      header() {
        return this._createHeader();
      }
      isSchema() {
        return this.headerType === enum_js_1.MessageHeader.Schema;
      }
      isRecordBatch() {
        return this.headerType === enum_js_1.MessageHeader.RecordBatch;
      }
      isDictionaryBatch() {
        return this.headerType === enum_js_1.MessageHeader.DictionaryBatch;
      }
      constructor(bodyLength, version, headerType, header) {
        this._version = version;
        this._headerType = headerType;
        this.body = new Uint8Array(0);
        header && (this._createHeader = () => header);
        this._bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
      }
    };
    exports2.Message = Message;
    var RecordBatch = class {
      get nodes() {
        return this._nodes;
      }
      get length() {
        return this._length;
      }
      get buffers() {
        return this._buffers;
      }
      constructor(length, nodes, buffers) {
        this._nodes = nodes;
        this._buffers = buffers;
        this._length = (0, bigint_js_1.bigIntToNumber)(length);
      }
    };
    exports2.RecordBatch = RecordBatch;
    var DictionaryBatch = class {
      get id() {
        return this._id;
      }
      get data() {
        return this._data;
      }
      get isDelta() {
        return this._isDelta;
      }
      get length() {
        return this.data.length;
      }
      get nodes() {
        return this.data.nodes;
      }
      get buffers() {
        return this.data.buffers;
      }
      constructor(data, id, isDelta = false) {
        this._data = data;
        this._isDelta = isDelta;
        this._id = (0, bigint_js_1.bigIntToNumber)(id);
      }
    };
    exports2.DictionaryBatch = DictionaryBatch;
    var BufferRegion = class {
      constructor(offset, length) {
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
      }
    };
    exports2.BufferRegion = BufferRegion;
    var FieldNode = class {
      constructor(length, nullCount) {
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
        this.nullCount = (0, bigint_js_1.bigIntToNumber)(nullCount);
      }
    };
    exports2.FieldNode = FieldNode;
    function messageHeaderFromJSON(message, type) {
      return () => {
        switch (type) {
          case enum_js_1.MessageHeader.Schema:
            return schema_js_2.Schema.fromJSON(message);
          case enum_js_1.MessageHeader.RecordBatch:
            return RecordBatch.fromJSON(message);
          case enum_js_1.MessageHeader.DictionaryBatch:
            return DictionaryBatch.fromJSON(message);
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
      };
    }
    function decodeMessageHeader(message, type) {
      return () => {
        switch (type) {
          case enum_js_1.MessageHeader.Schema:
            return schema_js_2.Schema.decode(message.header(new schema_js_1.Schema()), /* @__PURE__ */ new Map(), message.version());
          case enum_js_1.MessageHeader.RecordBatch:
            return RecordBatch.decode(message.header(new record_batch_js_1.RecordBatch()), message.version());
          case enum_js_1.MessageHeader.DictionaryBatch:
            return DictionaryBatch.decode(message.header(new dictionary_batch_js_1.DictionaryBatch()), message.version());
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
      };
    }
    schema_js_2.Field["encode"] = encodeField;
    schema_js_2.Field["decode"] = decodeField;
    schema_js_2.Field["fromJSON"] = json_js_1.fieldFromJSON;
    schema_js_2.Schema["encode"] = encodeSchema;
    schema_js_2.Schema["decode"] = decodeSchema;
    schema_js_2.Schema["fromJSON"] = json_js_1.schemaFromJSON;
    RecordBatch["encode"] = encodeRecordBatch;
    RecordBatch["decode"] = decodeRecordBatch;
    RecordBatch["fromJSON"] = json_js_1.recordBatchFromJSON;
    DictionaryBatch["encode"] = encodeDictionaryBatch;
    DictionaryBatch["decode"] = decodeDictionaryBatch;
    DictionaryBatch["fromJSON"] = json_js_1.dictionaryBatchFromJSON;
    FieldNode["encode"] = encodeFieldNode;
    FieldNode["decode"] = decodeFieldNode;
    BufferRegion["encode"] = encodeBufferRegion;
    BufferRegion["decode"] = decodeBufferRegion;
    function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map(), version = enum_js_1.MetadataVersion.V5) {
      const fields = decodeSchemaFields(_schema, dictionaries);
      return new schema_js_2.Schema(fields, decodeCustomMetadata(_schema), dictionaries, version);
    }
    function decodeRecordBatch(batch, version = enum_js_1.MetadataVersion.V5) {
      if (batch.compression() !== null) {
        throw new Error("Record batch compression not implemented");
      }
      return new RecordBatch(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
    }
    function decodeDictionaryBatch(batch, version = enum_js_1.MetadataVersion.V5) {
      return new DictionaryBatch(RecordBatch.decode(batch.data(), version), batch.id(), batch.isDelta());
    }
    function decodeBufferRegion(b) {
      return new BufferRegion(b.offset(), b.length());
    }
    function decodeFieldNode(f) {
      return new FieldNode(f.length(), f.nullCount());
    }
    function decodeFieldNodes(batch) {
      const nodes = [];
      for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {
        if (f = batch.nodes(i)) {
          nodes[++j] = FieldNode.decode(f);
        }
      }
      return nodes;
    }
    function decodeBuffers(batch, version) {
      const bufferRegions = [];
      for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {
        if (b = batch.buffers(i)) {
          if (version < enum_js_1.MetadataVersion.V4) {
            b.bb_pos += 8 * (i + 1);
          }
          bufferRegions[++j] = BufferRegion.decode(b);
        }
      }
      return bufferRegions;
    }
    function decodeSchemaFields(schema, dictionaries) {
      const fields = [];
      for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {
        if (f = schema.fields(i)) {
          fields[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
      }
      return fields;
    }
    function decodeFieldChildren(field, dictionaries) {
      const children = [];
      for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n; ) {
        if (f = field.children(i)) {
          children[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
      }
      return children;
    }
    function decodeField(f, dictionaries) {
      let id;
      let field;
      let type;
      let keys;
      let dictType;
      let dictMeta;
      if (!dictionaries || !(dictMeta = f.dictionary())) {
        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
        field = new schema_js_2.Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));
      } else if (!dictionaries.has(id = (0, bigint_js_1.bigIntToNumber)(dictMeta.id()))) {
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
        dictType = new type_js_2.Dictionary(type, keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
      } else {
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictType = new type_js_2.Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
      }
      return field || null;
    }
    function decodeCustomMetadata(parent) {
      const data = /* @__PURE__ */ new Map();
      if (parent) {
        for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {
          if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
            data.set(key, entry.value());
          }
        }
      }
      return data;
    }
    function decodeIndexType(_type) {
      return new type_js_2.Int(_type.isSigned(), _type.bitWidth());
    }
    function decodeFieldType(f, children) {
      const typeId = f.typeType();
      switch (typeId) {
        case type_js_1.Type["NONE"]:
          return new type_js_2.Null();
        case type_js_1.Type["Null"]:
          return new type_js_2.Null();
        case type_js_1.Type["Binary"]:
          return new type_js_2.Binary();
        case type_js_1.Type["LargeBinary"]:
          return new type_js_2.LargeBinary();
        case type_js_1.Type["Utf8"]:
          return new type_js_2.Utf8();
        case type_js_1.Type["LargeUtf8"]:
          return new type_js_2.LargeUtf8();
        case type_js_1.Type["Bool"]:
          return new type_js_2.Bool();
        case type_js_1.Type["List"]:
          return new type_js_2.List((children || [])[0]);
        case type_js_1.Type["Struct_"]:
          return new type_js_2.Struct(children || []);
      }
      switch (typeId) {
        case type_js_1.Type["Int"]: {
          const t = f.type(new int_js_1.Int());
          return new type_js_2.Int(t.isSigned(), t.bitWidth());
        }
        case type_js_1.Type["FloatingPoint"]: {
          const t = f.type(new floating_point_js_1.FloatingPoint());
          return new type_js_2.Float(t.precision());
        }
        case type_js_1.Type["Decimal"]: {
          const t = f.type(new decimal_js_1.Decimal());
          return new type_js_2.Decimal(t.scale(), t.precision(), t.bitWidth());
        }
        case type_js_1.Type["Date"]: {
          const t = f.type(new date_js_1.Date());
          return new type_js_2.Date_(t.unit());
        }
        case type_js_1.Type["Time"]: {
          const t = f.type(new time_js_1.Time());
          return new type_js_2.Time(t.unit(), t.bitWidth());
        }
        case type_js_1.Type["Timestamp"]: {
          const t = f.type(new timestamp_js_1.Timestamp());
          return new type_js_2.Timestamp(t.unit(), t.timezone());
        }
        case type_js_1.Type["Interval"]: {
          const t = f.type(new interval_js_1.Interval());
          return new type_js_2.Interval(t.unit());
        }
        case type_js_1.Type["Duration"]: {
          const t = f.type(new duration_js_1.Duration());
          return new type_js_2.Duration(t.unit());
        }
        case type_js_1.Type["Union"]: {
          const t = f.type(new union_js_1.Union());
          return new type_js_2.Union(t.mode(), t.typeIdsArray() || [], children || []);
        }
        case type_js_1.Type["FixedSizeBinary"]: {
          const t = f.type(new fixed_size_binary_js_1.FixedSizeBinary());
          return new type_js_2.FixedSizeBinary(t.byteWidth());
        }
        case type_js_1.Type["FixedSizeList"]: {
          const t = f.type(new fixed_size_list_js_1.FixedSizeList());
          return new type_js_2.FixedSizeList(t.listSize(), (children || [])[0]);
        }
        case type_js_1.Type["Map"]: {
          const t = f.type(new map_js_1.Map());
          return new type_js_2.Map_((children || [])[0], t.keysSorted());
        }
      }
      throw new Error(`Unrecognized type: "${type_js_1.Type[typeId]}" (${typeId})`);
    }
    function encodeSchema(b, schema) {
      const fieldOffsets = schema.fields.map((f) => schema_js_2.Field.encode(b, f));
      schema_js_1.Schema.startFieldsVector(b, fieldOffsets.length);
      const fieldsVectorOffset = schema_js_1.Schema.createFieldsVector(b, fieldOffsets);
      const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : schema_js_1.Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        key_value_js_1.KeyValue.startKeyValue(b);
        key_value_js_1.KeyValue.addKey(b, key);
        key_value_js_1.KeyValue.addValue(b, val);
        return key_value_js_1.KeyValue.endKeyValue(b);
      }));
      schema_js_1.Schema.startSchema(b);
      schema_js_1.Schema.addFields(b, fieldsVectorOffset);
      schema_js_1.Schema.addEndianness(b, platformIsLittleEndian ? endianness_js_1.Endianness.Little : endianness_js_1.Endianness.Big);
      if (metadataOffset !== -1) {
        schema_js_1.Schema.addCustomMetadata(b, metadataOffset);
      }
      return schema_js_1.Schema.endSchema(b);
    }
    function encodeField(b, field) {
      let nameOffset = -1;
      let typeOffset = -1;
      let dictionaryOffset = -1;
      const type = field.type;
      let typeId = field.typeId;
      if (!type_js_2.DataType.isDictionary(type)) {
        typeOffset = typeassembler_js_1.instance.visit(type, b);
      } else {
        typeId = type.dictionary.typeId;
        dictionaryOffset = typeassembler_js_1.instance.visit(type, b);
        typeOffset = typeassembler_js_1.instance.visit(type.dictionary, b);
      }
      const childOffsets = (type.children || []).map((f) => schema_js_2.Field.encode(b, f));
      const childrenVectorOffset = field_js_1.Field.createChildrenVector(b, childOffsets);
      const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : field_js_1.Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        key_value_js_1.KeyValue.startKeyValue(b);
        key_value_js_1.KeyValue.addKey(b, key);
        key_value_js_1.KeyValue.addValue(b, val);
        return key_value_js_1.KeyValue.endKeyValue(b);
      }));
      if (field.name) {
        nameOffset = b.createString(field.name);
      }
      field_js_1.Field.startField(b);
      field_js_1.Field.addType(b, typeOffset);
      field_js_1.Field.addTypeType(b, typeId);
      field_js_1.Field.addChildren(b, childrenVectorOffset);
      field_js_1.Field.addNullable(b, !!field.nullable);
      if (nameOffset !== -1) {
        field_js_1.Field.addName(b, nameOffset);
      }
      if (dictionaryOffset !== -1) {
        field_js_1.Field.addDictionary(b, dictionaryOffset);
      }
      if (metadataOffset !== -1) {
        field_js_1.Field.addCustomMetadata(b, metadataOffset);
      }
      return field_js_1.Field.endField(b);
    }
    function encodeRecordBatch(b, recordBatch) {
      const nodes = recordBatch.nodes || [];
      const buffers = recordBatch.buffers || [];
      record_batch_js_1.RecordBatch.startNodesVector(b, nodes.length);
      for (const n of nodes.slice().reverse())
        FieldNode.encode(b, n);
      const nodesVectorOffset = b.endVector();
      record_batch_js_1.RecordBatch.startBuffersVector(b, buffers.length);
      for (const b_ of buffers.slice().reverse())
        BufferRegion.encode(b, b_);
      const buffersVectorOffset = b.endVector();
      record_batch_js_1.RecordBatch.startRecordBatch(b);
      record_batch_js_1.RecordBatch.addLength(b, BigInt(recordBatch.length));
      record_batch_js_1.RecordBatch.addNodes(b, nodesVectorOffset);
      record_batch_js_1.RecordBatch.addBuffers(b, buffersVectorOffset);
      return record_batch_js_1.RecordBatch.endRecordBatch(b);
    }
    function encodeDictionaryBatch(b, dictionaryBatch) {
      const dataOffset = RecordBatch.encode(b, dictionaryBatch.data);
      dictionary_batch_js_1.DictionaryBatch.startDictionaryBatch(b);
      dictionary_batch_js_1.DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
      dictionary_batch_js_1.DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
      dictionary_batch_js_1.DictionaryBatch.addData(b, dataOffset);
      return dictionary_batch_js_1.DictionaryBatch.endDictionaryBatch(b);
    }
    function encodeFieldNode(b, node) {
      return field_node_js_1.FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
    }
    function encodeBufferRegion(b, node) {
      return buffer_js_1.Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));
    }
    var platformIsLittleEndian = (() => {
      const buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(
        0,
        256,
        true
        /* littleEndian */
      );
      return new Int16Array(buffer)[0] === 256;
    })();
  }
});

// node_modules/apache-arrow/ipc/message.js
var require_message3 = __commonJS({
  "node_modules/apache-arrow/ipc/message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.magicX2AndPadding = exports2.magicAndPadding = exports2.magicLength = exports2.checkForMagicArrowString = exports2.MAGIC = exports2.MAGIC_STR = exports2.PADDING = exports2.JSONMessageReader = exports2.AsyncMessageReader = exports2.MessageReader = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var enum_js_1 = require_enum();
    var flatbuffers_1 = require_flatbuffers();
    var message_js_1 = require_message2();
    var compat_js_1 = require_compat();
    var file_js_1 = require_file2();
    var buffer_js_1 = require_buffer();
    var stream_js_1 = require_stream();
    var interfaces_js_1 = require_interfaces();
    var invalidMessageType = (type) => `Expected ${enum_js_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
    var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${enum_js_1.MessageHeader[type]} Message is null or length 0.`;
    var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
    var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
    var MessageReader = class {
      constructor(source) {
        this.source = source instanceof stream_js_1.ByteStream ? source : new stream_js_1.ByteStream(source);
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
          return interfaces_js_1.ITERATOR_DONE;
        }
        if (r.value === -1 && (r = this.readMetadataLength()).done) {
          return interfaces_js_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
          return interfaces_js_1.ITERATOR_DONE;
        }
        return r;
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      readMessage(type) {
        let r;
        if ((r = this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = (0, buffer_js_1.toUint8Array)(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return (
          /* 1. */
          buf.byteOffset % 8 === 0 && /* 2. */
          buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
        );
      }
      readSchema(throwIfNull = false) {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
      readMetadataLength() {
        const buf = this.source.read(exports2.PADDING);
        const bb = buf && new flatbuffers_1.ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len === 0, value: len };
      }
      readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
          return interfaces_js_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_js_1.Message.decode(buf) };
      }
    };
    exports2.MessageReader = MessageReader;
    var AsyncMessageReader = class {
      constructor(source, byteLength) {
        this.source = source instanceof stream_js_1.AsyncByteStream ? source : (0, compat_js_1.isFileHandle)(source) ? new file_js_1.AsyncRandomAccessFile(source, byteLength) : new stream_js_1.AsyncByteStream(source);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      next() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let r;
          if ((r = yield this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
          }
          if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
          }
          if ((r = yield this.readMetadata(r.value)).done) {
            return interfaces_js_1.ITERATOR_DONE;
          }
          return r;
        });
      }
      throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return yield this.source.throw(value);
        });
      }
      return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return yield this.source.return(value);
        });
      }
      readMessage(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let r;
          if ((r = yield this.next()).done) {
            return null;
          }
          if (type != null && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
          }
          return r.value;
        });
      }
      readMessageBody(bodyLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (bodyLength <= 0) {
            return new Uint8Array(0);
          }
          const buf = (0, buffer_js_1.toUint8Array)(yield this.source.read(bodyLength));
          if (buf.byteLength < bodyLength) {
            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
          }
          return (
            /* 1. */
            buf.byteOffset % 8 === 0 && /* 2. */
            buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
          );
        });
      }
      readSchema() {
        return tslib_1.__awaiter(this, arguments, void 0, function* (throwIfNull = false) {
          const type = enum_js_1.MessageHeader.Schema;
          const message = yield this.readMessage(type);
          const schema = message === null || message === void 0 ? void 0 : message.header();
          if (throwIfNull && !schema) {
            throw new Error(nullMessage(type));
          }
          return schema;
        });
      }
      readMetadataLength() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const buf = yield this.source.read(exports2.PADDING);
          const bb = buf && new flatbuffers_1.ByteBuffer(buf);
          const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
          return { done: len === 0, value: len };
        });
      }
      readMetadata(metadataLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const buf = yield this.source.read(metadataLength);
          if (!buf) {
            return interfaces_js_1.ITERATOR_DONE;
          }
          if (buf.byteLength < metadataLength) {
            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
          }
          return { done: false, value: message_js_1.Message.decode(buf) };
        });
      }
    };
    exports2.AsyncMessageReader = AsyncMessageReader;
    var JSONMessageReader = class extends MessageReader {
      constructor(source) {
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_js_1.ArrowJSON ? source : new interfaces_js_1.ArrowJSON(source);
      }
      next() {
        const { _json } = this;
        if (!this._schema) {
          this._schema = true;
          const message = message_js_1.Message.fromJSON(_json.schema, enum_js_1.MessageHeader.Schema);
          return { done: false, value: message };
        }
        if (this._dictionaryIndex < _json.dictionaries.length) {
          const batch = _json.dictionaries[this._dictionaryIndex++];
          this._body = batch["data"]["columns"];
          const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.DictionaryBatch);
          return { done: false, value: message };
        }
        if (this._batchIndex < _json.batches.length) {
          const batch = _json.batches[this._batchIndex++];
          this._body = batch["columns"];
          const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.RecordBatch);
          return { done: false, value: message };
        }
        this._body = [];
        return interfaces_js_1.ITERATOR_DONE;
      }
      readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        function flattenDataSources(xs) {
          return (xs || []).reduce((buffers, column) => [
            ...buffers,
            ...column["VALIDITY"] && [column["VALIDITY"]] || [],
            ...column["TYPE_ID"] && [column["TYPE_ID"]] || [],
            ...column["OFFSET"] && [column["OFFSET"]] || [],
            ...column["DATA"] && [column["DATA"]] || [],
            ...flattenDataSources(column["children"])
          ], []);
        }
      }
      readMessage(type) {
        let r;
        if ((r = this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      readSchema() {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (!message || !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
    };
    exports2.JSONMessageReader = JSONMessageReader;
    exports2.PADDING = 4;
    exports2.MAGIC_STR = "ARROW1";
    exports2.MAGIC = new Uint8Array(exports2.MAGIC_STR.length);
    for (let i = 0; i < exports2.MAGIC_STR.length; i += 1) {
      exports2.MAGIC[i] = exports2.MAGIC_STR.codePointAt(i);
    }
    function checkForMagicArrowString(buffer, index = 0) {
      for (let i = -1, n = exports2.MAGIC.length; ++i < n; ) {
        if (exports2.MAGIC[i] !== buffer[index + i]) {
          return false;
        }
      }
      return true;
    }
    exports2.checkForMagicArrowString = checkForMagicArrowString;
    exports2.magicLength = exports2.MAGIC.length;
    exports2.magicAndPadding = exports2.magicLength + exports2.PADDING;
    exports2.magicX2AndPadding = exports2.magicLength * 2 + exports2.PADDING;
  }
});

// node_modules/apache-arrow/ipc/reader.js
var require_reader = __commonJS({
  "node_modules/apache-arrow/ipc/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncRecordBatchFileReader = exports2.RecordBatchFileReader = exports2.AsyncRecordBatchStreamReader = exports2.RecordBatchStreamReader = exports2.RecordBatchReader = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var data_js_1 = require_data();
    var vector_js_1 = require_vector2();
    var type_js_1 = require_type2();
    var enum_js_1 = require_enum();
    var file_js_1 = require_file();
    var adapters_js_1 = require_adapters();
    var stream_js_1 = require_stream();
    var file_js_2 = require_file2();
    var vectorloader_js_1 = require_vectorloader();
    var recordbatch_js_1 = require_recordbatch2();
    var interfaces_js_1 = require_interfaces();
    var message_js_1 = require_message3();
    var compat_js_1 = require_compat();
    var RecordBatchReader = class _RecordBatchReader extends interfaces_js_1.ReadableInterop {
      constructor(impl) {
        super();
        this._impl = impl;
      }
      get closed() {
        return this._impl.closed;
      }
      get schema() {
        return this._impl.schema;
      }
      get autoDestroy() {
        return this._impl.autoDestroy;
      }
      get dictionaries() {
        return this._impl.dictionaries;
      }
      get numDictionaries() {
        return this._impl.numDictionaries;
      }
      get numRecordBatches() {
        return this._impl.numRecordBatches;
      }
      get footer() {
        return this._impl.isFile() ? this._impl.footer : null;
      }
      isSync() {
        return this._impl.isSync();
      }
      isAsync() {
        return this._impl.isAsync();
      }
      isFile() {
        return this._impl.isFile();
      }
      isStream() {
        return this._impl.isStream();
      }
      next() {
        return this._impl.next();
      }
      throw(value) {
        return this._impl.throw(value);
      }
      return(value) {
        return this._impl.return(value);
      }
      cancel() {
        return this._impl.cancel();
      }
      reset(schema) {
        this._impl.reset(schema);
        this._DOMStream = void 0;
        this._nodeStream = void 0;
        return this;
      }
      open(options) {
        const opening = this._impl.open(options);
        return (0, compat_js_1.isPromise)(opening) ? opening.then(() => this) : this;
      }
      readRecordBatch(index) {
        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
      }
      [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
      }
      [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
      }
      toDOMStream() {
        return adapters_js_1.default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
      }
      toNodeStream() {
        return adapters_js_1.default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
      }
      /** @nocollapse */
      // @ts-ignore
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      /** @nocollapse */
      static throughDOM(writableStrategy, readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      /** @nocollapse */
      static from(source) {
        if (source instanceof _RecordBatchReader) {
          return source;
        } else if ((0, compat_js_1.isArrowJSON)(source)) {
          return fromArrowJSON(source);
        } else if ((0, compat_js_1.isFileHandle)(source)) {
          return fromFileHandle(source);
        } else if ((0, compat_js_1.isPromise)(source)) {
          return (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield _RecordBatchReader.from(yield source);
          }))();
        } else if ((0, compat_js_1.isFetchResponse)(source) || (0, compat_js_1.isReadableDOMStream)(source) || (0, compat_js_1.isReadableNodeStream)(source) || (0, compat_js_1.isAsyncIterable)(source)) {
          return fromAsyncByteStream(new stream_js_1.AsyncByteStream(source));
        }
        return fromByteStream(new stream_js_1.ByteStream(source));
      }
      /** @nocollapse */
      static readAll(source) {
        if (source instanceof _RecordBatchReader) {
          return source.isSync() ? readAllSync(source) : readAllAsync(source);
        } else if ((0, compat_js_1.isArrowJSON)(source) || ArrayBuffer.isView(source) || (0, compat_js_1.isIterable)(source) || (0, compat_js_1.isIteratorResult)(source)) {
          return readAllSync(source);
        }
        return readAllAsync(source);
      }
    };
    exports2.RecordBatchReader = RecordBatchReader;
    var RecordBatchStreamReader = class extends RecordBatchReader {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
      readAll() {
        return [...this];
      }
      [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
      }
      [Symbol.asyncIterator]() {
        return tslib_1.__asyncGenerator(this, arguments, function* _a() {
          yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(this[Symbol.iterator]())));
        });
      }
    };
    exports2.RecordBatchStreamReader = RecordBatchStreamReader;
    var AsyncRecordBatchStreamReader = class extends RecordBatchReader {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
      readAll() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          var _a, e_1, _b, _c;
          const batches = new Array();
          try {
            for (var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const batch = _c;
              batches.push(batch);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return batches;
        });
      }
      [Symbol.iterator]() {
        throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
      }
      [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
      }
    };
    exports2.AsyncRecordBatchStreamReader = AsyncRecordBatchStreamReader;
    var RecordBatchFileReader = class extends RecordBatchStreamReader {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
    };
    exports2.RecordBatchFileReader = RecordBatchFileReader;
    var AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
    };
    exports2.AsyncRecordBatchFileReader = AsyncRecordBatchFileReader;
    var RecordBatchReaderImpl = class {
      get numDictionaries() {
        return this._dictionaryIndex;
      }
      get numRecordBatches() {
        return this._recordBatchIndex;
      }
      constructor(dictionaries = /* @__PURE__ */ new Map()) {
        this.closed = false;
        this.autoDestroy = true;
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.dictionaries = dictionaries;
      }
      isSync() {
        return false;
      }
      isAsync() {
        return false;
      }
      isFile() {
        return false;
      }
      isStream() {
        return false;
      }
      reset(schema) {
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.schema = schema;
        this.dictionaries = /* @__PURE__ */ new Map();
        return this;
      }
      _loadRecordBatch(header, body) {
        const children = this._loadVectors(header, body, this.schema.fields);
        const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(this.schema.fields), length: header.length, children });
        return new recordbatch_js_1.RecordBatch(this.schema, data);
      }
      _loadDictionaryBatch(header, body) {
        const { id, isDelta } = header;
        const { dictionaries, schema } = this;
        const dictionary = dictionaries.get(id);
        const type = schema.dictionaries.get(id);
        const data = this._loadVectors(header.data, body, [type]);
        return (dictionary && isDelta ? dictionary.concat(new vector_js_1.Vector(data)) : new vector_js_1.Vector(data)).memoize();
      }
      _loadVectors(header, body, types) {
        return new vectorloader_js_1.VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
      }
    };
    var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
      constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = !(0, compat_js_1.isArrowJSON)(source) ? new message_js_1.MessageReader(this._handle = source) : new message_js_1.JSONMessageReader(this._handle = source);
      }
      isSync() {
        return true;
      }
      isStream() {
        return true;
      }
      [Symbol.iterator]() {
        return this;
      }
      cancel() {
        if (!this.closed && (this.closed = true)) {
          this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      }
      open(options) {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = this._reader.readSchema()))) {
            this.cancel();
          }
        }
        return this;
      }
      throw(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return this.reset()._reader.throw(value);
        }
        return interfaces_js_1.ITERATOR_DONE;
      }
      return(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return this.reset()._reader.return(value);
        }
        return interfaces_js_1.ITERATOR_DONE;
      }
      next() {
        if (this.closed) {
          return interfaces_js_1.ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while (message = this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return this.return();
      }
      _readNextMessageAndValidate(type) {
        return this._reader.readMessage(type);
      }
    };
    var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
      constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = new message_js_1.AsyncMessageReader(this._handle = source);
      }
      isAsync() {
        return true;
      }
      isStream() {
        return true;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      cancel() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.closed && (this.closed = true)) {
            yield this.reset()._reader.return();
            this._reader = null;
            this.dictionaries = null;
          }
        });
      }
      open(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.closed) {
            this.autoDestroy = shouldAutoDestroy(this, options);
            if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
              yield this.cancel();
            }
          }
          return this;
        });
      }
      throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.closed && this.autoDestroy && (this.closed = true)) {
            return yield this.reset()._reader.throw(value);
          }
          return interfaces_js_1.ITERATOR_DONE;
        });
      }
      return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.closed && this.autoDestroy && (this.closed = true)) {
            return yield this.reset()._reader.return(value);
          }
          return interfaces_js_1.ITERATOR_DONE;
        });
      }
      next() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this.closed) {
            return interfaces_js_1.ITERATOR_DONE;
          }
          let message;
          const { _reader: reader } = this;
          while (message = yield this._readNextMessageAndValidate()) {
            if (message.isSchema()) {
              yield this.reset(message.header());
            } else if (message.isRecordBatch()) {
              this._recordBatchIndex++;
              const header = message.header();
              const buffer = yield reader.readMessageBody(message.bodyLength);
              const recordBatch = this._loadRecordBatch(header, buffer);
              return { done: false, value: recordBatch };
            } else if (message.isDictionaryBatch()) {
              this._dictionaryIndex++;
              const header = message.header();
              const buffer = yield reader.readMessageBody(message.bodyLength);
              const vector = this._loadDictionaryBatch(header, buffer);
              this.dictionaries.set(header.id, vector);
            }
          }
          if (this.schema && this._recordBatchIndex === 0) {
            this._recordBatchIndex++;
            return { done: false, value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
          }
          return yield this.return();
        });
      }
      _readNextMessageAndValidate(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return yield this._reader.readMessage(type);
        });
      }
    };
    var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
      get footer() {
        return this._footer;
      }
      get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
      }
      get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
      }
      constructor(source, dictionaries) {
        super(source instanceof file_js_2.RandomAccessFile ? source : new file_js_2.RandomAccessFile(source), dictionaries);
      }
      isSync() {
        return true;
      }
      isFile() {
        return true;
      }
      open(options) {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && this._readDictionaryBatch(this._dictionaryIndex++);
          }
        }
        return super.open(options);
      }
      readRecordBatch(index) {
        var _a;
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          this.open();
        }
        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
        if (block && this._handle.seek(block.offset)) {
          const message = this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
          if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
            const header = message.header();
            const buffer = this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      }
      _readDictionaryBatch(index) {
        var _a;
        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
        if (block && this._handle.seek(block.offset)) {
          const message = this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
          if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      }
      _readFooter() {
        const { _handle } = this;
        const offset = _handle.size - message_js_1.magicAndPadding;
        const length = _handle.readInt32(offset);
        const buffer = _handle.readAt(offset - length, length);
        return file_js_1.Footer.decode(buffer);
      }
      _readNextMessageAndValidate(type) {
        var _a;
        if (!this._footer) {
          this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(this._recordBatchIndex);
          if (block && this._handle.seek(block.offset)) {
            return this._reader.readMessage(type);
          }
        }
        return null;
      }
    };
    var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
      get footer() {
        return this._footer;
      }
      get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
      }
      get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
      }
      constructor(source, ...rest) {
        const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
        const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
        super(source instanceof file_js_2.AsyncRandomAccessFile ? source : new file_js_2.AsyncRandomAccessFile(source, byteLength), dictionaries);
      }
      isFile() {
        return true;
      }
      isAsync() {
        return true;
      }
      open(options) {
        const _super = Object.create(null, {
          open: { get: () => super.open }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.closed && !this._footer) {
            this.schema = (this._footer = yield this._readFooter()).schema;
            for (const block of this._footer.dictionaryBatches()) {
              block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
            }
          }
          return yield _super.open.call(this, options);
        });
      }
      readRecordBatch(index) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          var _a;
          if (this.closed) {
            return null;
          }
          if (!this._footer) {
            yield this.open();
          }
          const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
          if (block && (yield this._handle.seek(block.offset))) {
            const message = yield this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
            if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
              const header = message.header();
              const buffer = yield this._reader.readMessageBody(message.bodyLength);
              const recordBatch = this._loadRecordBatch(header, buffer);
              return recordBatch;
            }
          }
          return null;
        });
      }
      _readDictionaryBatch(index) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          var _a;
          const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
          if (block && (yield this._handle.seek(block.offset))) {
            const message = yield this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
            if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
              const header = message.header();
              const buffer = yield this._reader.readMessageBody(message.bodyLength);
              const vector = this._loadDictionaryBatch(header, buffer);
              this.dictionaries.set(header.id, vector);
            }
          }
        });
      }
      _readFooter() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { _handle } = this;
          _handle._pending && (yield _handle._pending);
          const offset = _handle.size - message_js_1.magicAndPadding;
          const length = yield _handle.readInt32(offset);
          const buffer = yield _handle.readAt(offset - length, length);
          return file_js_1.Footer.decode(buffer);
        });
      }
      _readNextMessageAndValidate(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._footer) {
            yield this.open();
          }
          if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
            const block = this._footer.getRecordBatch(this._recordBatchIndex);
            if (block && (yield this._handle.seek(block.offset))) {
              return yield this._reader.readMessage(type);
            }
          }
          return null;
        });
      }
    };
    var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
      constructor(source, dictionaries) {
        super(source, dictionaries);
      }
      _loadVectors(header, body, types) {
        return new vectorloader_js_1.JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
      }
    };
    function shouldAutoDestroy(self, options) {
      return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self["autoDestroy"];
    }
    function* readAllSync(source) {
      const reader = RecordBatchReader.from(source);
      try {
        if (!reader.open({ autoDestroy: false }).closed) {
          do {
            yield reader;
          } while (!reader.reset().open().closed);
        }
      } finally {
        reader.cancel();
      }
    }
    function readAllAsync(source) {
      return tslib_1.__asyncGenerator(this, arguments, function* readAllAsync_1() {
        const reader = yield tslib_1.__await(RecordBatchReader.from(source));
        try {
          if (!(yield tslib_1.__await(reader.open({ autoDestroy: false }))).closed) {
            do {
              yield yield tslib_1.__await(reader);
            } while (!(yield tslib_1.__await(reader.reset().open())).closed);
          }
        } finally {
          yield tslib_1.__await(reader.cancel());
        }
      });
    }
    function fromArrowJSON(source) {
      return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
    }
    function fromByteStream(source) {
      const bytes = source.peek(message_js_1.magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {
      }()));
    }
    function fromAsyncByteStream(source) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const bytes = yield source.peek(message_js_1.magicLength + 7 & ~7);
        return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
          return tslib_1.__asyncGenerator(this, arguments, function* () {
          });
        }()));
      });
    }
    function fromFileHandle(source) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { size } = yield source.stat();
        const file = new file_js_2.AsyncRandomAccessFile(source, size);
        if (size >= message_js_1.magicX2AndPadding && (0, message_js_1.checkForMagicArrowString)(yield file.readAt(0, message_js_1.magicLength + 7 & ~7))) {
          return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
        }
        return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
      });
    }
  }
});

// node_modules/apache-arrow/visitor/vectorassembler.js
var require_vectorassembler = __commonJS({
  "node_modules/apache-arrow/visitor/vectorassembler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VectorAssembler = void 0;
    var vector_js_1 = require_vector2();
    var visitor_js_1 = require_visitor();
    var enum_js_1 = require_enum();
    var recordbatch_js_1 = require_recordbatch2();
    var buffer_js_1 = require_buffer();
    var bit_js_1 = require_bit();
    var message_js_1 = require_message2();
    var type_js_1 = require_type2();
    var bigint_js_1 = require_bigint();
    var VectorAssembler = class _VectorAssembler extends visitor_js_1.Visitor {
      /** @nocollapse */
      static assemble(...args) {
        const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof recordbatch_js_1.RecordBatch ? node.data.children : node.data);
        const assembler = new _VectorAssembler();
        assembler.visitMany(unwrap(args));
        return assembler;
      }
      constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
      }
      visit(data) {
        if (data instanceof vector_js_1.Vector) {
          this.visitMany(data.data);
          return this;
        }
        const { type } = data;
        if (!type_js_1.DataType.isDictionary(type)) {
          const { length } = data;
          if (length > 2147483647) {
            throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
          }
          if (type_js_1.DataType.isUnion(type)) {
            this.nodes.push(new message_js_1.FieldNode(length, 0));
          } else {
            const { nullCount } = data;
            if (!type_js_1.DataType.isNull(type)) {
              addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : (0, bit_js_1.truncateBitmap)(data.offset, length, data.nullBitmap));
            }
            this.nodes.push(new message_js_1.FieldNode(length, nullCount));
          }
        }
        return super.visit(data);
      }
      visitNull(_null) {
        return this;
      }
      visitDictionary(data) {
        return this.visit(data.clone(data.type.indices));
      }
      get nodes() {
        return this._nodes;
      }
      get buffers() {
        return this._buffers;
      }
      get byteLength() {
        return this._byteLength;
      }
      get bufferRegions() {
        return this._bufferRegions;
      }
    };
    exports2.VectorAssembler = VectorAssembler;
    function addBuffer(values) {
      const byteLength = values.byteLength + 7 & ~7;
      this.buffers.push(values);
      this.bufferRegions.push(new message_js_1.BufferRegion(this._byteLength, byteLength));
      this._byteLength += byteLength;
      return this;
    }
    function assembleUnion(data) {
      var _a;
      const { type, length, typeIds, valueOffsets } = data;
      addBuffer.call(this, typeIds);
      if (type.mode === enum_js_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, data);
      } else if (type.mode === enum_js_1.UnionMode.Dense) {
        if (data.offset <= 0) {
          addBuffer.call(this, valueOffsets);
          return assembleNestedVector.call(this, data);
        } else {
          const shiftedOffsets = new Int32Array(length);
          const childOffsets = /* @__PURE__ */ Object.create(null);
          const childLengths = /* @__PURE__ */ Object.create(null);
          for (let typeId, shift, index = -1; ++index < length; ) {
            if ((typeId = typeIds[index]) === void 0) {
              continue;
            }
            if ((shift = childOffsets[typeId]) === void 0) {
              shift = childOffsets[typeId] = valueOffsets[index];
            }
            shiftedOffsets[index] = valueOffsets[index] - shift;
            childLengths[typeId] = ((_a = childLengths[typeId]) !== null && _a !== void 0 ? _a : 0) + 1;
          }
          addBuffer.call(this, shiftedOffsets);
          this.visitMany(data.children.map((child, childIndex) => {
            const typeId = type.typeIds[childIndex];
            const childOffset = childOffsets[typeId];
            const childLength = childLengths[typeId];
            return child.slice(childOffset, Math.min(length, childLength));
          }));
        }
      }
      return this;
    }
    function assembleBoolVector(data) {
      let values;
      if (data.nullCount >= data.length) {
        return addBuffer.call(this, new Uint8Array(0));
      } else if ((values = data.values) instanceof Uint8Array) {
        return addBuffer.call(this, (0, bit_js_1.truncateBitmap)(data.offset, data.length, values));
      }
      return addBuffer.call(this, (0, bit_js_1.packBools)(data.values));
    }
    function assembleFlatVector(data) {
      return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
    }
    function assembleFlatListVector(data) {
      const { length, values, valueOffsets } = data;
      const begin = (0, bigint_js_1.bigIntToNumber)(valueOffsets[0]);
      const end = (0, bigint_js_1.bigIntToNumber)(valueOffsets[length]);
      const byteLength = Math.min(end - begin, values.byteLength - begin);
      addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets));
      addBuffer.call(this, values.subarray(begin, begin + byteLength));
      return this;
    }
    function assembleListVector(data) {
      const { length, valueOffsets } = data;
      if (valueOffsets) {
        const { [0]: begin, [length]: end } = valueOffsets;
        addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets));
        return this.visit(data.children[0].slice(begin, end - begin));
      }
      return this.visit(data.children[0]);
    }
    function assembleNestedVector(data) {
      return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
    }
    VectorAssembler.prototype.visitBool = assembleBoolVector;
    VectorAssembler.prototype.visitInt = assembleFlatVector;
    VectorAssembler.prototype.visitFloat = assembleFlatVector;
    VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
    VectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;
    VectorAssembler.prototype.visitBinary = assembleFlatListVector;
    VectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;
    VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
    VectorAssembler.prototype.visitDate = assembleFlatVector;
    VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
    VectorAssembler.prototype.visitTime = assembleFlatVector;
    VectorAssembler.prototype.visitDecimal = assembleFlatVector;
    VectorAssembler.prototype.visitList = assembleListVector;
    VectorAssembler.prototype.visitStruct = assembleNestedVector;
    VectorAssembler.prototype.visitUnion = assembleUnion;
    VectorAssembler.prototype.visitInterval = assembleFlatVector;
    VectorAssembler.prototype.visitDuration = assembleFlatVector;
    VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
    VectorAssembler.prototype.visitMap = assembleListVector;
  }
});

// node_modules/apache-arrow/visitor/jsontypeassembler.js
var require_jsontypeassembler = __commonJS({
  "node_modules/apache-arrow/visitor/jsontypeassembler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONTypeAssembler = void 0;
    var visitor_js_1 = require_visitor();
    var type_js_1 = require_type();
    var enum_js_1 = require_enum();
    var JSONTypeAssembler = class extends visitor_js_1.Visitor {
      visit(node) {
        return node == null ? void 0 : super.visit(node);
      }
      visitNull({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitInt({ typeId, bitWidth, isSigned }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "bitWidth": bitWidth, "isSigned": isSigned };
      }
      visitFloat({ typeId, precision }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "precision": enum_js_1.Precision[precision] };
      }
      visitBinary({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitLargeBinary({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitBool({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitUtf8({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitLargeUtf8({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitDecimal({ typeId, scale, precision, bitWidth }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "scale": scale, "precision": precision, "bitWidth": bitWidth };
      }
      visitDate({ typeId, unit }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "unit": enum_js_1.DateUnit[unit] };
      }
      visitTime({ typeId, unit, bitWidth }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "unit": enum_js_1.TimeUnit[unit], bitWidth };
      }
      visitTimestamp({ typeId, timezone, unit }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "unit": enum_js_1.TimeUnit[unit], timezone };
      }
      visitInterval({ typeId, unit }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "unit": enum_js_1.IntervalUnit[unit] };
      }
      visitDuration({ typeId, unit }) {
        return { "name": type_js_1.Type[typeId].toLocaleLowerCase(), "unit": enum_js_1.TimeUnit[unit] };
      }
      visitList({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitStruct({ typeId }) {
        return { "name": type_js_1.Type[typeId].toLowerCase() };
      }
      visitUnion({ typeId, mode, typeIds }) {
        return {
          "name": type_js_1.Type[typeId].toLowerCase(),
          "mode": enum_js_1.UnionMode[mode].toUpperCase(),
          "typeIds": [...typeIds]
        };
      }
      visitDictionary(node) {
        return this.visit(node.dictionary);
      }
      visitFixedSizeBinary({ typeId, byteWidth }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "byteWidth": byteWidth };
      }
      visitFixedSizeList({ typeId, listSize }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "listSize": listSize };
      }
      visitMap({ typeId, keysSorted }) {
        return { "name": type_js_1.Type[typeId].toLowerCase(), "keysSorted": keysSorted };
      }
    };
    exports2.JSONTypeAssembler = JSONTypeAssembler;
  }
});

// node_modules/apache-arrow/visitor/jsonvectorassembler.js
var require_jsonvectorassembler = __commonJS({
  "node_modules/apache-arrow/visitor/jsonvectorassembler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JSONVectorAssembler = void 0;
    var bn_js_1 = require_bn();
    var vector_js_1 = require_vector2();
    var visitor_js_1 = require_visitor();
    var enum_js_1 = require_enum();
    var enum_js_2 = require_enum();
    var bit_js_1 = require_bit();
    var type_js_1 = require_type2();
    var JSONVectorAssembler = class _JSONVectorAssembler extends visitor_js_1.Visitor {
      /** @nocollapse */
      static assemble(...batches) {
        const assembler = new _JSONVectorAssembler();
        return batches.map(({ schema, data }) => {
          return assembler.visitMany(schema.fields, data.children);
        });
      }
      visit({ name }, data) {
        const { length } = data;
        const { offset, nullCount, nullBitmap } = data;
        const type = type_js_1.DataType.isDictionary(data.type) ? data.type.indices : data.type;
        const buffers = Object.assign([], data.buffers, { [enum_js_1.BufferType.VALIDITY]: void 0 });
        return Object.assign({ "name": name, "count": length, "VALIDITY": type_js_1.DataType.isNull(type) || type_js_1.DataType.isUnion(type) ? void 0 : nullCount <= 0 ? Array.from({ length }, () => 1) : [...new bit_js_1.BitIterator(nullBitmap, offset, length, null, bit_js_1.getBit)] }, super.visit(data.clone(type, offset, length, 0, buffers)));
      }
      visitNull() {
        return {};
      }
      visitBool({ values, offset, length }) {
        return { "DATA": [...new bit_js_1.BitIterator(values, offset, length, null, bit_js_1.getBool)] };
      }
      visitInt(data) {
        return {
          "DATA": data.type.bitWidth < 64 ? [...data.values] : [...bigNumsToStrings(data.values, 2)]
        };
      }
      visitFloat(data) {
        return { "DATA": [...data.values] };
      }
      visitUtf8(data) {
        return { "DATA": [...new vector_js_1.Vector([data])], "OFFSET": [...data.valueOffsets] };
      }
      visitLargeUtf8(data) {
        return { "DATA": [...new vector_js_1.Vector([data])], "OFFSET": [...bigNumsToStrings(data.valueOffsets, 2)] };
      }
      visitBinary(data) {
        return { "DATA": [...binaryToString(new vector_js_1.Vector([data]))], "OFFSET": [...data.valueOffsets] };
      }
      visitLargeBinary(data) {
        return { "DATA": [...binaryToString(new vector_js_1.Vector([data]))], "OFFSET": [...bigNumsToStrings(data.valueOffsets, 2)] };
      }
      visitFixedSizeBinary(data) {
        return { "DATA": [...binaryToString(new vector_js_1.Vector([data]))] };
      }
      visitDate(data) {
        return {
          "DATA": data.type.unit === enum_js_2.DateUnit.DAY ? [...data.values] : [...bigNumsToStrings(data.values, 2)]
        };
      }
      visitTimestamp(data) {
        return { "DATA": [...bigNumsToStrings(data.values, 2)] };
      }
      visitTime(data) {
        return {
          "DATA": data.type.unit < enum_js_2.TimeUnit.MICROSECOND ? [...data.values] : [...bigNumsToStrings(data.values, 2)]
        };
      }
      visitDecimal(data) {
        return { "DATA": [...bigNumsToStrings(data.values, 4)] };
      }
      visitList(data) {
        return {
          "OFFSET": [...data.valueOffsets],
          "children": this.visitMany(data.type.children, data.children)
        };
      }
      visitStruct(data) {
        return {
          "children": this.visitMany(data.type.children, data.children)
        };
      }
      visitUnion(data) {
        return {
          "TYPE_ID": [...data.typeIds],
          "OFFSET": data.type.mode === enum_js_2.UnionMode.Dense ? [...data.valueOffsets] : void 0,
          "children": this.visitMany(data.type.children, data.children)
        };
      }
      visitInterval(data) {
        return { "DATA": [...data.values] };
      }
      visitDuration(data) {
        return { "DATA": [...bigNumsToStrings(data.values, 2)] };
      }
      visitFixedSizeList(data) {
        return {
          "children": this.visitMany(data.type.children, data.children)
        };
      }
      visitMap(data) {
        return {
          "OFFSET": [...data.valueOffsets],
          "children": this.visitMany(data.type.children, data.children)
        };
      }
    };
    exports2.JSONVectorAssembler = JSONVectorAssembler;
    function* binaryToString(vector) {
      for (const octets of vector) {
        yield octets.reduce((str, byte) => {
          return `${str}${("0" + (byte & 255).toString(16)).slice(-2)}`;
        }, "").toUpperCase();
      }
    }
    function* bigNumsToStrings(values, stride) {
      const u32s = new Uint32Array(values.buffer);
      for (let i = -1, n = u32s.length / stride; ++i < n; ) {
        yield `${bn_js_1.BN.new(u32s.subarray((i + 0) * stride, (i + 1) * stride), false)}`;
      }
    }
  }
});

// node_modules/apache-arrow/ipc/writer.js
var require_writer = __commonJS({
  "node_modules/apache-arrow/ipc/writer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecordBatchJSONWriter = exports2.RecordBatchFileWriter = exports2.RecordBatchStreamWriter = exports2.RecordBatchWriter = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var table_js_1 = require_table();
    var message_js_1 = require_message3();
    var vector_js_1 = require_vector2();
    var type_js_1 = require_type2();
    var message_js_2 = require_message2();
    var metadata = require_message2();
    var file_js_1 = require_file();
    var enum_js_1 = require_enum();
    var typecomparator_js_1 = require_typecomparator();
    var stream_js_1 = require_stream();
    var vectorassembler_js_1 = require_vectorassembler();
    var jsontypeassembler_js_1 = require_jsontypeassembler();
    var jsonvectorassembler_js_1 = require_jsonvectorassembler();
    var buffer_js_1 = require_buffer();
    var recordbatch_js_1 = require_recordbatch2();
    var interfaces_js_1 = require_interfaces();
    var compat_js_1 = require_compat();
    var RecordBatchWriter = class extends interfaces_js_1.ReadableInterop {
      /** @nocollapse */
      // @ts-ignore
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      /** @nocollapse */
      static throughDOM(writableStrategy, readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      constructor(options) {
        super();
        this._position = 0;
        this._started = false;
        this._sink = new stream_js_1.AsyncByteQueue();
        this._schema = null;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._seenDictionaries = /* @__PURE__ */ new Map();
        this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
        (0, compat_js_1.isObject)(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
        this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
        this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
      }
      toString(sync = false) {
        return this._sink.toString(sync);
      }
      toUint8Array(sync = false) {
        return this._sink.toUint8Array(sync);
      }
      writeAll(input) {
        if ((0, compat_js_1.isPromise)(input)) {
          return input.then((x) => this.writeAll(x));
        } else if ((0, compat_js_1.isAsyncIterable)(input)) {
          return writeAllAsync(this, input);
        }
        return writeAll(this, input);
      }
      get closed() {
        return this._sink.closed;
      }
      [Symbol.asyncIterator]() {
        return this._sink[Symbol.asyncIterator]();
      }
      toDOMStream(options) {
        return this._sink.toDOMStream(options);
      }
      toNodeStream(options) {
        return this._sink.toNodeStream(options);
      }
      close() {
        return this.reset()._sink.close();
      }
      abort(reason) {
        return this.reset()._sink.abort(reason);
      }
      finish() {
        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
        return this;
      }
      reset(sink = this._sink, schema = null) {
        if (sink === this._sink || sink instanceof stream_js_1.AsyncByteQueue) {
          this._sink = sink;
        } else {
          this._sink = new stream_js_1.AsyncByteQueue();
          if (sink && (0, compat_js_1.isWritableDOMStream)(sink)) {
            this.toDOMStream({ type: "bytes" }).pipeTo(sink);
          } else if (sink && (0, compat_js_1.isWritableNodeStream)(sink)) {
            this.toNodeStream({ objectMode: false }).pipe(sink);
          }
        }
        if (this._started && this._schema) {
          this._writeFooter(this._schema);
        }
        this._started = false;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._seenDictionaries = /* @__PURE__ */ new Map();
        this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
        if (!schema || !(0, typecomparator_js_1.compareSchemas)(schema, this._schema)) {
          if (schema == null) {
            this._position = 0;
            this._schema = null;
          } else {
            this._started = true;
            this._schema = schema;
            this._writeSchema(schema);
          }
        }
        return this;
      }
      write(payload) {
        let schema = null;
        if (!this._sink) {
          throw new Error(`RecordBatchWriter is closed`);
        } else if (payload == null) {
          return this.finish() && void 0;
        } else if (payload instanceof table_js_1.Table && !(schema = payload.schema)) {
          return this.finish() && void 0;
        } else if (payload instanceof recordbatch_js_1.RecordBatch && !(schema = payload.schema)) {
          return this.finish() && void 0;
        }
        if (schema && !(0, typecomparator_js_1.compareSchemas)(schema, this._schema)) {
          if (this._started && this._autoDestroy) {
            return this.close();
          }
          this.reset(this._sink, schema);
        }
        if (payload instanceof recordbatch_js_1.RecordBatch) {
          if (!(payload instanceof recordbatch_js_1._InternalEmptyPlaceholderRecordBatch)) {
            this._writeRecordBatch(payload);
          }
        } else if (payload instanceof table_js_1.Table) {
          this.writeAll(payload.batches);
        } else if ((0, compat_js_1.isIterable)(payload)) {
          this.writeAll(payload);
        }
      }
      _writeMessage(message, alignment = 8) {
        const a = alignment - 1;
        const buffer = message_js_2.Message.encode(message);
        const flatbufferSize = buffer.byteLength;
        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
        const alignedSize = flatbufferSize + prefixSize + a & ~a;
        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
        if (message.headerType === enum_js_1.MessageHeader.RecordBatch) {
          this._recordBatchBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        } else if (message.headerType === enum_js_1.MessageHeader.DictionaryBatch) {
          this._dictionaryBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        if (!this._writeLegacyIpcFormat) {
          this._write(Int32Array.of(-1));
        }
        this._write(Int32Array.of(alignedSize - prefixSize));
        if (flatbufferSize > 0) {
          this._write(buffer);
        }
        return this._writePadding(nPaddingBytes);
      }
      _write(chunk) {
        if (this._started) {
          const buffer = (0, buffer_js_1.toUint8Array)(chunk);
          if (buffer && buffer.byteLength > 0) {
            this._sink.write(buffer);
            this._position += buffer.byteLength;
          }
        }
        return this;
      }
      _writeSchema(schema) {
        return this._writeMessage(message_js_2.Message.from(schema));
      }
      // @ts-ignore
      _writeFooter(schema) {
        return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
      }
      _writeMagic() {
        return this._write(message_js_1.MAGIC);
      }
      _writePadding(nBytes) {
        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
      }
      _writeRecordBatch(batch) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(batch);
        const recordBatch = new metadata.RecordBatch(batch.numRows, nodes, bufferRegions);
        const message = message_js_2.Message.from(recordBatch, byteLength);
        return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
      }
      _writeDictionaryBatch(dictionary, id, isDelta = false) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(new vector_js_1.Vector([dictionary]));
        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions);
        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);
        const message = message_js_2.Message.from(dictionaryBatch, byteLength);
        return this._writeMessage(message)._writeBodyBuffers(buffers);
      }
      _writeBodyBuffers(buffers) {
        let buffer;
        let size, padding;
        for (let i = -1, n = buffers.length; ++i < n; ) {
          if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
            this._write(buffer);
            if ((padding = (size + 7 & ~7) - size) > 0) {
              this._writePadding(padding);
            }
          }
        }
        return this;
      }
      _writeDictionaries(batch) {
        var _a, _b;
        for (const [id, dictionary] of batch.dictionaries) {
          const chunks = (_a = dictionary === null || dictionary === void 0 ? void 0 : dictionary.data) !== null && _a !== void 0 ? _a : [];
          const prevDictionary = this._seenDictionaries.get(id);
          const offset = (_b = this._dictionaryDeltaOffsets.get(id)) !== null && _b !== void 0 ? _b : 0;
          if (!prevDictionary || prevDictionary.data[0] !== chunks[0]) {
            for (const [index, chunk] of chunks.entries())
              this._writeDictionaryBatch(chunk, id, index > 0);
          } else if (offset < chunks.length) {
            for (const chunk of chunks.slice(offset))
              this._writeDictionaryBatch(chunk, id, true);
          }
          this._seenDictionaries.set(id, dictionary);
          this._dictionaryDeltaOffsets.set(id, chunks.length);
        }
        return this;
      }
    };
    exports2.RecordBatchWriter = RecordBatchWriter;
    var RecordBatchStreamWriter = class _RecordBatchStreamWriter extends RecordBatchWriter {
      /** @nocollapse */
      static writeAll(input, options) {
        const writer = new _RecordBatchStreamWriter(options);
        if ((0, compat_js_1.isPromise)(input)) {
          return input.then((x) => writer.writeAll(x));
        } else if ((0, compat_js_1.isAsyncIterable)(input)) {
          return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
      }
    };
    exports2.RecordBatchStreamWriter = RecordBatchStreamWriter;
    var RecordBatchFileWriter = class _RecordBatchFileWriter extends RecordBatchWriter {
      /** @nocollapse */
      static writeAll(input) {
        const writer = new _RecordBatchFileWriter();
        if ((0, compat_js_1.isPromise)(input)) {
          return input.then((x) => writer.writeAll(x));
        } else if ((0, compat_js_1.isAsyncIterable)(input)) {
          return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
      }
      constructor() {
        super();
        this._autoDestroy = true;
      }
      // @ts-ignore
      _writeSchema(schema) {
        return this._writeMagic()._writePadding(2);
      }
      _writeDictionaryBatch(dictionary, id, isDelta = false) {
        if (!isDelta && this._seenDictionaries.has(id)) {
          throw new Error("The Arrow File format does not support replacement dictionaries. ");
        }
        return super._writeDictionaryBatch(dictionary, id, isDelta);
      }
      _writeFooter(schema) {
        const buffer = file_js_1.Footer.encode(new file_js_1.Footer(schema, enum_js_1.MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
        return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
      }
    };
    exports2.RecordBatchFileWriter = RecordBatchFileWriter;
    var RecordBatchJSONWriter = class _RecordBatchJSONWriter extends RecordBatchWriter {
      /** @nocollapse */
      static writeAll(input) {
        return new _RecordBatchJSONWriter().writeAll(input);
      }
      constructor() {
        super();
        this._autoDestroy = true;
        this._recordBatches = [];
        this._recordBatchesWithDictionaries = [];
      }
      _writeMessage() {
        return this;
      }
      // @ts-ignore
      _writeFooter(schema) {
        return this;
      }
      _writeSchema(schema) {
        return this._write(`{
  "schema": ${JSON.stringify({ fields: schema.fields.map((field) => fieldToJSON(field)) }, null, 2)}`);
      }
      _writeDictionaries(batch) {
        if (batch.dictionaries.size > 0) {
          this._recordBatchesWithDictionaries.push(batch);
        }
        return this;
      }
      _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,
    `);
        this._write(dictionaryBatchToJSON(dictionary, id, isDelta));
        this._dictionaryBlocks.push(new file_js_1.FileBlock(0, 0, 0));
        return this;
      }
      _writeRecordBatch(batch) {
        this._writeDictionaries(batch);
        this._recordBatches.push(batch);
        return this;
      }
      close() {
        if (this._recordBatchesWithDictionaries.length > 0) {
          this._write(`,
  "dictionaries": [
`);
          for (const batch of this._recordBatchesWithDictionaries) {
            super._writeDictionaries(batch);
          }
          this._write(`
  ]`);
        }
        if (this._recordBatches.length > 0) {
          for (let i = -1, n = this._recordBatches.length; ++i < n; ) {
            this._write(i === 0 ? `,
  "batches": [
    ` : `,
    `);
            this._write(recordBatchToJSON(this._recordBatches[i]));
            this._recordBatchBlocks.push(new file_js_1.FileBlock(0, 0, 0));
          }
          this._write(`
  ]`);
        }
        if (this._schema) {
          this._write(`
}`);
        }
        this._recordBatchesWithDictionaries = [];
        this._recordBatches = [];
        return super.close();
      }
    };
    exports2.RecordBatchJSONWriter = RecordBatchJSONWriter;
    function writeAll(writer, input) {
      let chunks = input;
      if (input instanceof table_js_1.Table) {
        chunks = input.batches;
        writer.reset(void 0, input.schema);
      }
      for (const batch of chunks) {
        writer.write(batch);
      }
      return writer.finish();
    }
    function writeAllAsync(writer, batches) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a, batches_1, batches_1_1;
        var _b, e_1, _c, _d;
        try {
          for (_a = true, batches_1 = tslib_1.__asyncValues(batches); batches_1_1 = yield batches_1.next(), _b = batches_1_1.done, !_b; _a = true) {
            _d = batches_1_1.value;
            _a = false;
            const batch = _d;
            writer.write(batch);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_a && !_b && (_c = batches_1.return)) yield _c.call(batches_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return writer.finish();
      });
    }
    function fieldToJSON({ name, type, nullable }) {
      const assembler = new jsontypeassembler_js_1.JSONTypeAssembler();
      return {
        "name": name,
        "nullable": nullable,
        "type": assembler.visit(type),
        "children": (type.children || []).map((field) => fieldToJSON(field)),
        "dictionary": !type_js_1.DataType.isDictionary(type) ? void 0 : {
          "id": type.id,
          "isOrdered": type.isOrdered,
          "indexType": assembler.visit(type.indices)
        }
      };
    }
    function dictionaryBatchToJSON(dictionary, id, isDelta = false) {
      const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(new recordbatch_js_1.RecordBatch({ [id]: dictionary }));
      return JSON.stringify({
        "id": id,
        "isDelta": isDelta,
        "data": {
          "count": dictionary.length,
          "columns": columns
        }
      }, null, 2);
    }
    function recordBatchToJSON(records) {
      const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(records);
      return JSON.stringify({
        "count": records.numRows,
        "columns": columns
      }, null, 2);
    }
  }
});

// node_modules/apache-arrow/io/node/iterable.js
var require_iterable = __commonJS({
  "node_modules/apache-arrow/io/node/iterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toNodeStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_stream_1 = require("node:stream");
    var compat_js_1 = require_compat();
    function toNodeStream(source, options) {
      if ((0, compat_js_1.isAsyncIterable)(source)) {
        return new AsyncIterableReadable(source[Symbol.asyncIterator](), options);
      }
      if ((0, compat_js_1.isIterable)(source)) {
        return new IterableReadable(source[Symbol.iterator](), options);
      }
      throw new Error(`toNodeStream() must be called with an Iterable or AsyncIterable`);
    }
    exports2.toNodeStream = toNodeStream;
    var IterableReadable = class extends node_stream_1.Readable {
      constructor(it, options) {
        super(options);
        this._iterator = it;
        this._pulling = false;
        this._bytesMode = !options || !options.objectMode;
      }
      _read(size) {
        const it = this._iterator;
        if (it && !this._pulling && (this._pulling = true)) {
          this._pulling = this._pull(size, it);
        }
      }
      _destroy(e, cb) {
        const it = this._iterator;
        let fn;
        it && (fn = e != null && it.throw || it.return);
        fn === null || fn === void 0 ? void 0 : fn.call(it, e);
        cb && cb(null);
      }
      _pull(size, it) {
        const bm = this._bytesMode;
        let r = null;
        while (this.readable && !(r = it.next(bm ? size : null)).done) {
          if (size != null) {
            size -= bm && ArrayBuffer.isView(r.value) ? r.value.byteLength : 1;
          }
          if (!this.push(r.value) || size <= 0) {
            break;
          }
        }
        if (((r === null || r === void 0 ? void 0 : r.done) || !this.readable) && (this.push(null) || true)) {
          it.return && it.return();
        }
        return !this.readable;
      }
    };
    var AsyncIterableReadable = class extends node_stream_1.Readable {
      constructor(it, options) {
        super(options);
        this._iterator = it;
        this._pulling = false;
        this._bytesMode = !options || !options.objectMode;
      }
      _read(size) {
        const it = this._iterator;
        if (it && !this._pulling && (this._pulling = true)) {
          (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._pulling = yield this._pull(size, it);
          }))();
        }
      }
      _destroy(e, cb) {
        const it = this._iterator;
        let fn;
        it && (fn = e != null && it.throw || it.return);
        (fn === null || fn === void 0 ? void 0 : fn.call(it, e).then(() => cb && cb(null))) || cb && cb(null);
      }
      _pull(size, it) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const bm = this._bytesMode;
          let r = null;
          while (this.readable && !(r = yield it.next(bm ? size : null)).done) {
            if (size != null) {
              size -= bm && ArrayBuffer.isView(r.value) ? r.value.byteLength : 1;
            }
            if (!this.push(r.value) || size <= 0) {
              break;
            }
          }
          if (((r === null || r === void 0 ? void 0 : r.done) || !this.readable) && (this.push(null) || true)) {
            it.return && it.return();
          }
          return !this.readable;
        });
      }
    };
  }
});

// node_modules/apache-arrow/io/node/builder.js
var require_builder3 = __commonJS({
  "node_modules/apache-arrow/io/node/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.builderThroughNodeStream = void 0;
    var node_stream_1 = require("node:stream");
    var factories_js_1 = require_factories();
    function builderThroughNodeStream(options) {
      return new BuilderDuplex((0, factories_js_1.makeBuilder)(options), options);
    }
    exports2.builderThroughNodeStream = builderThroughNodeStream;
    var BuilderDuplex = class extends node_stream_1.Duplex {
      constructor(builder, options) {
        const { queueingStrategy = "count", autoDestroy = true } = options;
        const { highWaterMark = queueingStrategy !== "bytes" ? 1e3 : Math.pow(2, 14) } = options;
        super({ autoDestroy, highWaterMark: 1, allowHalfOpen: true, writableObjectMode: true, readableObjectMode: true });
        this._numChunks = 0;
        this._finished = false;
        this._builder = builder;
        this._desiredSize = highWaterMark;
        this._getSize = queueingStrategy !== "bytes" ? builderLength : builderByteLength;
      }
      _read(size) {
        this._maybeFlush(this._builder, this._desiredSize = size);
      }
      _final(cb) {
        this._maybeFlush(this._builder.finish(), this._desiredSize);
        cb && cb();
      }
      _write(value, _, cb) {
        const result = this._maybeFlush(this._builder.append(value), this._desiredSize);
        cb && cb();
        return result;
      }
      _destroy(err, cb) {
        this._builder.clear();
        cb && cb(err);
      }
      _maybeFlush(builder, size) {
        if (this._getSize(builder) >= size) {
          ++this._numChunks && this.push(builder.toVector());
        }
        if (builder.finished) {
          if (builder.length > 0 || this._numChunks === 0) {
            ++this._numChunks && this.push(builder.toVector());
          }
          if (!this._finished && (this._finished = true)) {
            this.push(null);
          }
          return false;
        }
        return this._getSize(builder) < this.writableHighWaterMark;
      }
    };
    var builderLength = (builder) => builder.length;
    var builderByteLength = (builder) => builder.byteLength;
  }
});

// node_modules/apache-arrow/io/node/reader.js
var require_reader2 = __commonJS({
  "node_modules/apache-arrow/io/node/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recordBatchReaderThroughNodeStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_stream_1 = require("node:stream");
    var stream_js_1 = require_stream();
    var reader_js_1 = require_reader();
    function recordBatchReaderThroughNodeStream(options) {
      return new RecordBatchReaderDuplex(options);
    }
    exports2.recordBatchReaderThroughNodeStream = recordBatchReaderThroughNodeStream;
    var RecordBatchReaderDuplex = class extends node_stream_1.Duplex {
      constructor(options) {
        super(Object.assign(Object.assign({ allowHalfOpen: false }, options), { readableObjectMode: true, writableObjectMode: false }));
        this._pulling = false;
        this._autoDestroy = true;
        this._reader = null;
        this._pulling = false;
        this._asyncQueue = new stream_js_1.AsyncByteQueue();
        this._autoDestroy = options && typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
      }
      _final(cb) {
        const aq = this._asyncQueue;
        aq === null || aq === void 0 ? void 0 : aq.close();
        cb && cb();
      }
      _write(x, _, cb) {
        const aq = this._asyncQueue;
        aq === null || aq === void 0 ? void 0 : aq.write(x);
        cb && cb();
        return true;
      }
      _read(size) {
        const aq = this._asyncQueue;
        if (aq && !this._pulling && (this._pulling = true)) {
          (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this._reader) {
              this._reader = yield this._open(aq);
            }
            this._pulling = yield this._pull(size, this._reader);
          }))();
        }
      }
      _destroy(err, cb) {
        const aq = this._asyncQueue;
        if (aq) {
          err ? aq.abort(err) : aq.close();
        }
        cb(this._asyncQueue = this._reader = null);
      }
      _open(source) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return yield (yield reader_js_1.RecordBatchReader.from(source)).open({ autoDestroy: this._autoDestroy });
        });
      }
      _pull(size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let r = null;
          while (this.readable && !(r = yield reader.next()).done) {
            if (!this.push(r.value) || size != null && --size <= 0) {
              break;
            }
          }
          if (!this.readable || (r === null || r === void 0 ? void 0 : r.done) && (reader.autoDestroy || (yield reader.reset().open()).closed)) {
            this.push(null);
            yield reader.cancel();
          }
          return !this.readable;
        });
      }
    };
  }
});

// node_modules/apache-arrow/io/node/writer.js
var require_writer2 = __commonJS({
  "node_modules/apache-arrow/io/node/writer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recordBatchWriterThroughNodeStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_stream_1 = require("node:stream");
    var stream_js_1 = require_stream();
    function recordBatchWriterThroughNodeStream(options) {
      return new RecordBatchWriterDuplex(new this(options));
    }
    exports2.recordBatchWriterThroughNodeStream = recordBatchWriterThroughNodeStream;
    var RecordBatchWriterDuplex = class extends node_stream_1.Duplex {
      constructor(writer, options) {
        super(Object.assign(Object.assign({ allowHalfOpen: false }, options), { writableObjectMode: true, readableObjectMode: false }));
        this._pulling = false;
        this._writer = writer;
        this._reader = new stream_js_1.AsyncByteStream(writer);
      }
      _final(cb) {
        const writer = this._writer;
        writer === null || writer === void 0 ? void 0 : writer.close();
        cb && cb();
      }
      _write(x, _, cb) {
        const writer = this._writer;
        writer === null || writer === void 0 ? void 0 : writer.write(x);
        cb && cb();
        return true;
      }
      _read(size) {
        const it = this._reader;
        if (it && !this._pulling && (this._pulling = true)) {
          (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._pulling = yield this._pull(size, it);
          }))();
        }
      }
      _destroy(err, cb) {
        const writer = this._writer;
        if (writer) {
          err ? writer.abort(err) : writer.close();
        }
        cb(this._reader = this._writer = null);
      }
      _pull(size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let r = null;
          while (this.readable && !(r = yield reader.next(size || null)).done) {
            if (size != null && r.value) {
              size -= r.value.byteLength;
            }
            if (!this.push(r.value) || size <= 0) {
              break;
            }
          }
          if ((r === null || r === void 0 ? void 0 : r.done) || !this.readable) {
            this.push(null);
            yield reader.cancel();
          }
          return !this.readable;
        });
      }
    };
  }
});

// node_modules/apache-arrow/io/whatwg/iterable.js
var require_iterable2 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/iterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toDOMStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var buffer_js_1 = require_buffer();
    var compat_js_1 = require_compat();
    function toDOMStream(source, options) {
      if ((0, compat_js_1.isAsyncIterable)(source)) {
        return asyncIterableAsReadableDOMStream(source, options);
      }
      if ((0, compat_js_1.isIterable)(source)) {
        return iterableAsReadableDOMStream(source, options);
      }
      throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
    }
    exports2.toDOMStream = toDOMStream;
    function iterableAsReadableDOMStream(source, options) {
      let it = null;
      const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
      const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
      return new ReadableStream(Object.assign(Object.assign({}, options), {
        start(controller) {
          next(controller, it || (it = source[Symbol.iterator]()));
        },
        pull(controller) {
          it ? next(controller, it) : controller.close();
        },
        cancel() {
          ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null);
        }
      }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
      function next(controller, it2) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = it2.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
    function asyncIterableAsReadableDOMStream(source, options) {
      let it = null;
      const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
      const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
      return new ReadableStream(Object.assign(Object.assign({}, options), {
        start(controller) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield next(controller, it || (it = source[Symbol.asyncIterator]()));
          });
        },
        pull(controller) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            it ? yield next(controller, it) : controller.close();
          });
        },
        cancel() {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null);
          });
        }
      }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
      function next(controller, it2) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let buf;
          let r = null;
          let size = controller.desiredSize || null;
          while (!(r = yield it2.next(bm ? size : null)).done) {
            if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
              size != null && bm && (size = size - buf.byteLength + 1);
              r.value = buf;
            }
            controller.enqueue(r.value);
            if (size != null && --size <= 0) {
              return;
            }
          }
          controller.close();
        });
      }
    }
  }
});

// node_modules/apache-arrow/io/whatwg/builder.js
var require_builder4 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuilderTransform = exports2.builderThroughDOMStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var factories_js_1 = require_factories();
    function builderThroughDOMStream(options) {
      return new BuilderTransform(options);
    }
    exports2.builderThroughDOMStream = builderThroughDOMStream;
    var BuilderTransform = class {
      constructor(options) {
        this._numChunks = 0;
        this._finished = false;
        this._bufferedSize = 0;
        const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = tslib_1.__rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
        this._controller = null;
        this._builder = (0, factories_js_1.makeBuilder)(builderOptions);
        this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
        const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
        const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
        this["readable"] = new ReadableStream({
          ["cancel"]: () => {
            this._builder.clear();
          },
          ["pull"]: (c) => {
            this._maybeFlush(this._builder, this._controller = c);
          },
          ["start"]: (c) => {
            this._maybeFlush(this._builder, this._controller = c);
          }
        }, {
          "highWaterMark": readableHighWaterMark,
          "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
        });
        this["writable"] = new WritableStream({
          ["abort"]: () => {
            this._builder.clear();
          },
          ["write"]: () => {
            this._maybeFlush(this._builder, this._controller);
          },
          ["close"]: () => {
            this._maybeFlush(this._builder.finish(), this._controller);
          }
        }, {
          "highWaterMark": writableHighWaterMark,
          "size": (value) => this._writeValueAndReturnChunkSize(value)
        });
      }
      _writeValueAndReturnChunkSize(value) {
        const bufferedSize = this._bufferedSize;
        this._bufferedSize = this._getSize(this._builder.append(value));
        return this._bufferedSize - bufferedSize;
      }
      _maybeFlush(builder, controller) {
        if (controller == null) {
          return;
        }
        if (this._bufferedSize >= controller.desiredSize) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (builder.finished) {
          if (builder.length > 0 || this._numChunks === 0) {
            ++this._numChunks && this._enqueue(controller, builder.toVector());
          }
          if (!this._finished && (this._finished = true)) {
            this._enqueue(controller, null);
          }
        }
      }
      _enqueue(controller, chunk) {
        this._bufferedSize = 0;
        this._controller = null;
        chunk == null ? controller.close() : controller.enqueue(chunk);
      }
    };
    exports2.BuilderTransform = BuilderTransform;
    var chunkLength = (chunk) => {
      var _a;
      return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a !== void 0 ? _a : 0;
    };
    var chunkByteLength = (chunk) => {
      var _a;
      return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a !== void 0 ? _a : 0;
    };
  }
});

// node_modules/apache-arrow/io/whatwg/reader.js
var require_reader3 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recordBatchReaderThroughDOMStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var stream_js_1 = require_stream();
    var reader_js_1 = require_reader();
    function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
      const queue = new stream_js_1.AsyncByteQueue();
      let reader = null;
      const readable = new ReadableStream({
        cancel() {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield queue.close();
          });
        },
        start(controller) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield next(controller, reader || (reader = yield open()));
          });
        },
        pull(controller) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            reader ? yield next(controller, reader) : controller.close();
          });
        }
      });
      return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
      function open() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return yield (yield reader_js_1.RecordBatchReader.from(queue)).open(readableStrategy);
        });
      }
      function next(controller, reader2) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let size = controller.desiredSize;
          let r = null;
          while (!(r = yield reader2.next()).done) {
            controller.enqueue(r.value);
            if (size != null && --size <= 0) {
              return;
            }
          }
          controller.close();
        });
      }
    }
    exports2.recordBatchReaderThroughDOMStream = recordBatchReaderThroughDOMStream;
  }
});

// node_modules/apache-arrow/io/whatwg/writer.js
var require_writer3 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/writer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recordBatchWriterThroughDOMStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var stream_js_1 = require_stream();
    function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
      const writer = new this(writableStrategy);
      const reader = new stream_js_1.AsyncByteStream(writer);
      const readable = new ReadableStream({
        // type: 'bytes',
        cancel() {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield reader.cancel();
          });
        },
        pull(controller) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield next(controller);
          });
        },
        start(controller) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield next(controller);
          });
        }
      }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
      return { writable: new WritableStream(writer, writableStrategy), readable };
      function next(controller) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let buf = null;
          let size = controller.desiredSize;
          while (buf = yield reader.read(size || null)) {
            controller.enqueue(buf);
            if (size != null && (size -= buf.byteLength) <= 0) {
              return;
            }
          }
          controller.close();
        });
      }
    }
    exports2.recordBatchWriterThroughDOMStream = recordBatchWriterThroughDOMStream;
  }
});

// node_modules/apache-arrow/ipc/serialization.js
var require_serialization = __commonJS({
  "node_modules/apache-arrow/ipc/serialization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tableToIPC = exports2.tableFromIPC = void 0;
    var table_js_1 = require_table();
    var compat_js_1 = require_compat();
    var reader_js_1 = require_reader();
    var writer_js_1 = require_writer();
    function tableFromIPC(input) {
      const reader = reader_js_1.RecordBatchReader.from(input);
      if ((0, compat_js_1.isPromise)(reader)) {
        return reader.then((reader2) => tableFromIPC(reader2));
      }
      if (reader.isAsync()) {
        return reader.readAll().then((xs) => new table_js_1.Table(xs));
      }
      return new table_js_1.Table(reader.readAll());
    }
    exports2.tableFromIPC = tableFromIPC;
    function tableToIPC(table, type = "stream") {
      return (type === "stream" ? writer_js_1.RecordBatchStreamWriter : writer_js_1.RecordBatchFileWriter).writeAll(table).toUint8Array(true);
    }
    exports2.tableToIPC = tableToIPC;
  }
});

// node_modules/apache-arrow/Arrow.js
var require_Arrow = __commonJS({
  "node_modules/apache-arrow/Arrow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DenseUnion = exports2.Union = exports2.Struct = exports2.List = exports2.Decimal = exports2.TimeNanosecond = exports2.TimeMicrosecond = exports2.TimeMillisecond = exports2.TimeSecond = exports2.Time = exports2.TimestampNanosecond = exports2.TimestampMicrosecond = exports2.TimestampMillisecond = exports2.TimestampSecond = exports2.Timestamp = exports2.DateMillisecond = exports2.DateDay = exports2.Date_ = exports2.FixedSizeBinary = exports2.LargeBinary = exports2.Binary = exports2.LargeUtf8 = exports2.Utf8 = exports2.Float64 = exports2.Float32 = exports2.Float16 = exports2.Float = exports2.Uint64 = exports2.Uint32 = exports2.Uint16 = exports2.Uint8 = exports2.Int64 = exports2.Int32 = exports2.Int16 = exports2.Int8 = exports2.Int = exports2.Bool = exports2.Null = exports2.DataType = exports2.makeData = exports2.Data = exports2.MetadataVersion = exports2.IntervalUnit = exports2.UnionMode = exports2.Precision = exports2.TimeUnit = exports2.DateUnit = exports2.BufferType = exports2.Type = exports2.MessageHeader = void 0;
    exports2.TimeBuilder = exports2.Uint64Builder = exports2.Uint32Builder = exports2.Uint16Builder = exports2.Uint8Builder = exports2.Int64Builder = exports2.Int32Builder = exports2.Int16Builder = exports2.Int8Builder = exports2.IntBuilder = exports2.Float64Builder = exports2.Float32Builder = exports2.Float16Builder = exports2.FloatBuilder = exports2.FixedSizeBinaryBuilder = exports2.DictionaryBuilder = exports2.DecimalBuilder = exports2.DateMillisecondBuilder = exports2.DateDayBuilder = exports2.DateBuilder = exports2.NullBuilder = exports2.BoolBuilder = exports2.builderThroughAsyncIterable = exports2.builderThroughIterable = exports2.tableFromJSON = exports2.vectorFromArray = exports2.makeBuilder = exports2.Builder = exports2.StructRow = exports2.MapRow = exports2.Field = exports2.Schema = exports2.Visitor = exports2.makeVector = exports2.Vector = exports2.tableFromArrays = exports2.makeTable = exports2.Table = exports2.Map_ = exports2.FixedSizeList = exports2.DurationNanosecond = exports2.DurationMicrosecond = exports2.DurationMillisecond = exports2.DurationSecond = exports2.Duration = exports2.IntervalYearMonth = exports2.IntervalDayTime = exports2.Interval = exports2.Dictionary = exports2.SparseUnion = void 0;
    exports2.util = exports2.RecordBatch = exports2.Message = exports2.JSONMessageReader = exports2.AsyncMessageReader = exports2.MessageReader = exports2.tableFromIPC = exports2.tableToIPC = exports2.RecordBatchJSONWriter = exports2.RecordBatchStreamWriter = exports2.RecordBatchFileWriter = exports2.RecordBatchWriter = exports2.AsyncRecordBatchStreamReader = exports2.AsyncRecordBatchFileReader = exports2.RecordBatchStreamReader = exports2.RecordBatchFileReader = exports2.RecordBatchReader = exports2.AsyncByteQueue = exports2.AsyncByteStream = exports2.ByteStream = exports2.DenseUnionBuilder = exports2.SparseUnionBuilder = exports2.UnionBuilder = exports2.StructBuilder = exports2.MapBuilder = exports2.FixedSizeListBuilder = exports2.ListBuilder = exports2.LargeBinaryBuilder = exports2.BinaryBuilder = exports2.LargeUtf8Builder = exports2.Utf8Builder = exports2.DurationNanosecondBuilder = exports2.DurationMicrosecondBuilder = exports2.DurationMillisecondBuilder = exports2.DurationSecondBuilder = exports2.DurationBuilder = exports2.IntervalYearMonthBuilder = exports2.IntervalDayTimeBuilder = exports2.IntervalBuilder = exports2.TimestampNanosecondBuilder = exports2.TimestampMicrosecondBuilder = exports2.TimestampMillisecondBuilder = exports2.TimestampSecondBuilder = exports2.TimestampBuilder = exports2.TimeNanosecondBuilder = exports2.TimeMicrosecondBuilder = exports2.TimeMillisecondBuilder = exports2.TimeSecondBuilder = void 0;
    var message_header_js_1 = require_message_header();
    Object.defineProperty(exports2, "MessageHeader", { enumerable: true, get: function() {
      return message_header_js_1.MessageHeader;
    } });
    var enum_js_1 = require_enum();
    Object.defineProperty(exports2, "Type", { enumerable: true, get: function() {
      return enum_js_1.Type;
    } });
    Object.defineProperty(exports2, "BufferType", { enumerable: true, get: function() {
      return enum_js_1.BufferType;
    } });
    Object.defineProperty(exports2, "DateUnit", { enumerable: true, get: function() {
      return enum_js_1.DateUnit;
    } });
    Object.defineProperty(exports2, "TimeUnit", { enumerable: true, get: function() {
      return enum_js_1.TimeUnit;
    } });
    Object.defineProperty(exports2, "Precision", { enumerable: true, get: function() {
      return enum_js_1.Precision;
    } });
    Object.defineProperty(exports2, "UnionMode", { enumerable: true, get: function() {
      return enum_js_1.UnionMode;
    } });
    Object.defineProperty(exports2, "IntervalUnit", { enumerable: true, get: function() {
      return enum_js_1.IntervalUnit;
    } });
    Object.defineProperty(exports2, "MetadataVersion", { enumerable: true, get: function() {
      return enum_js_1.MetadataVersion;
    } });
    var data_js_1 = require_data();
    Object.defineProperty(exports2, "Data", { enumerable: true, get: function() {
      return data_js_1.Data;
    } });
    Object.defineProperty(exports2, "makeData", { enumerable: true, get: function() {
      return data_js_1.makeData;
    } });
    var type_js_1 = require_type2();
    Object.defineProperty(exports2, "DataType", { enumerable: true, get: function() {
      return type_js_1.DataType;
    } });
    Object.defineProperty(exports2, "Null", { enumerable: true, get: function() {
      return type_js_1.Null;
    } });
    Object.defineProperty(exports2, "Bool", { enumerable: true, get: function() {
      return type_js_1.Bool;
    } });
    Object.defineProperty(exports2, "Int", { enumerable: true, get: function() {
      return type_js_1.Int;
    } });
    Object.defineProperty(exports2, "Int8", { enumerable: true, get: function() {
      return type_js_1.Int8;
    } });
    Object.defineProperty(exports2, "Int16", { enumerable: true, get: function() {
      return type_js_1.Int16;
    } });
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return type_js_1.Int32;
    } });
    Object.defineProperty(exports2, "Int64", { enumerable: true, get: function() {
      return type_js_1.Int64;
    } });
    Object.defineProperty(exports2, "Uint8", { enumerable: true, get: function() {
      return type_js_1.Uint8;
    } });
    Object.defineProperty(exports2, "Uint16", { enumerable: true, get: function() {
      return type_js_1.Uint16;
    } });
    Object.defineProperty(exports2, "Uint32", { enumerable: true, get: function() {
      return type_js_1.Uint32;
    } });
    Object.defineProperty(exports2, "Uint64", { enumerable: true, get: function() {
      return type_js_1.Uint64;
    } });
    Object.defineProperty(exports2, "Float", { enumerable: true, get: function() {
      return type_js_1.Float;
    } });
    Object.defineProperty(exports2, "Float16", { enumerable: true, get: function() {
      return type_js_1.Float16;
    } });
    Object.defineProperty(exports2, "Float32", { enumerable: true, get: function() {
      return type_js_1.Float32;
    } });
    Object.defineProperty(exports2, "Float64", { enumerable: true, get: function() {
      return type_js_1.Float64;
    } });
    Object.defineProperty(exports2, "Utf8", { enumerable: true, get: function() {
      return type_js_1.Utf8;
    } });
    Object.defineProperty(exports2, "LargeUtf8", { enumerable: true, get: function() {
      return type_js_1.LargeUtf8;
    } });
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return type_js_1.Binary;
    } });
    Object.defineProperty(exports2, "LargeBinary", { enumerable: true, get: function() {
      return type_js_1.LargeBinary;
    } });
    Object.defineProperty(exports2, "FixedSizeBinary", { enumerable: true, get: function() {
      return type_js_1.FixedSizeBinary;
    } });
    Object.defineProperty(exports2, "Date_", { enumerable: true, get: function() {
      return type_js_1.Date_;
    } });
    Object.defineProperty(exports2, "DateDay", { enumerable: true, get: function() {
      return type_js_1.DateDay;
    } });
    Object.defineProperty(exports2, "DateMillisecond", { enumerable: true, get: function() {
      return type_js_1.DateMillisecond;
    } });
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return type_js_1.Timestamp;
    } });
    Object.defineProperty(exports2, "TimestampSecond", { enumerable: true, get: function() {
      return type_js_1.TimestampSecond;
    } });
    Object.defineProperty(exports2, "TimestampMillisecond", { enumerable: true, get: function() {
      return type_js_1.TimestampMillisecond;
    } });
    Object.defineProperty(exports2, "TimestampMicrosecond", { enumerable: true, get: function() {
      return type_js_1.TimestampMicrosecond;
    } });
    Object.defineProperty(exports2, "TimestampNanosecond", { enumerable: true, get: function() {
      return type_js_1.TimestampNanosecond;
    } });
    Object.defineProperty(exports2, "Time", { enumerable: true, get: function() {
      return type_js_1.Time;
    } });
    Object.defineProperty(exports2, "TimeSecond", { enumerable: true, get: function() {
      return type_js_1.TimeSecond;
    } });
    Object.defineProperty(exports2, "TimeMillisecond", { enumerable: true, get: function() {
      return type_js_1.TimeMillisecond;
    } });
    Object.defineProperty(exports2, "TimeMicrosecond", { enumerable: true, get: function() {
      return type_js_1.TimeMicrosecond;
    } });
    Object.defineProperty(exports2, "TimeNanosecond", { enumerable: true, get: function() {
      return type_js_1.TimeNanosecond;
    } });
    Object.defineProperty(exports2, "Decimal", { enumerable: true, get: function() {
      return type_js_1.Decimal;
    } });
    Object.defineProperty(exports2, "List", { enumerable: true, get: function() {
      return type_js_1.List;
    } });
    Object.defineProperty(exports2, "Struct", { enumerable: true, get: function() {
      return type_js_1.Struct;
    } });
    Object.defineProperty(exports2, "Union", { enumerable: true, get: function() {
      return type_js_1.Union;
    } });
    Object.defineProperty(exports2, "DenseUnion", { enumerable: true, get: function() {
      return type_js_1.DenseUnion;
    } });
    Object.defineProperty(exports2, "SparseUnion", { enumerable: true, get: function() {
      return type_js_1.SparseUnion;
    } });
    Object.defineProperty(exports2, "Dictionary", { enumerable: true, get: function() {
      return type_js_1.Dictionary;
    } });
    Object.defineProperty(exports2, "Interval", { enumerable: true, get: function() {
      return type_js_1.Interval;
    } });
    Object.defineProperty(exports2, "IntervalDayTime", { enumerable: true, get: function() {
      return type_js_1.IntervalDayTime;
    } });
    Object.defineProperty(exports2, "IntervalYearMonth", { enumerable: true, get: function() {
      return type_js_1.IntervalYearMonth;
    } });
    Object.defineProperty(exports2, "Duration", { enumerable: true, get: function() {
      return type_js_1.Duration;
    } });
    Object.defineProperty(exports2, "DurationSecond", { enumerable: true, get: function() {
      return type_js_1.DurationSecond;
    } });
    Object.defineProperty(exports2, "DurationMillisecond", { enumerable: true, get: function() {
      return type_js_1.DurationMillisecond;
    } });
    Object.defineProperty(exports2, "DurationMicrosecond", { enumerable: true, get: function() {
      return type_js_1.DurationMicrosecond;
    } });
    Object.defineProperty(exports2, "DurationNanosecond", { enumerable: true, get: function() {
      return type_js_1.DurationNanosecond;
    } });
    Object.defineProperty(exports2, "FixedSizeList", { enumerable: true, get: function() {
      return type_js_1.FixedSizeList;
    } });
    Object.defineProperty(exports2, "Map_", { enumerable: true, get: function() {
      return type_js_1.Map_;
    } });
    var table_js_1 = require_table();
    Object.defineProperty(exports2, "Table", { enumerable: true, get: function() {
      return table_js_1.Table;
    } });
    Object.defineProperty(exports2, "makeTable", { enumerable: true, get: function() {
      return table_js_1.makeTable;
    } });
    Object.defineProperty(exports2, "tableFromArrays", { enumerable: true, get: function() {
      return table_js_1.tableFromArrays;
    } });
    var vector_js_1 = require_vector2();
    Object.defineProperty(exports2, "Vector", { enumerable: true, get: function() {
      return vector_js_1.Vector;
    } });
    Object.defineProperty(exports2, "makeVector", { enumerable: true, get: function() {
      return vector_js_1.makeVector;
    } });
    var visitor_js_1 = require_visitor();
    Object.defineProperty(exports2, "Visitor", { enumerable: true, get: function() {
      return visitor_js_1.Visitor;
    } });
    var schema_js_1 = require_schema2();
    Object.defineProperty(exports2, "Schema", { enumerable: true, get: function() {
      return schema_js_1.Schema;
    } });
    Object.defineProperty(exports2, "Field", { enumerable: true, get: function() {
      return schema_js_1.Field;
    } });
    var map_js_1 = require_map2();
    Object.defineProperty(exports2, "MapRow", { enumerable: true, get: function() {
      return map_js_1.MapRow;
    } });
    var struct_js_1 = require_struct2();
    Object.defineProperty(exports2, "StructRow", { enumerable: true, get: function() {
      return struct_js_1.StructRow;
    } });
    var builder_js_1 = require_builder2();
    Object.defineProperty(exports2, "Builder", { enumerable: true, get: function() {
      return builder_js_1.Builder;
    } });
    var factories_js_1 = require_factories();
    Object.defineProperty(exports2, "makeBuilder", { enumerable: true, get: function() {
      return factories_js_1.makeBuilder;
    } });
    Object.defineProperty(exports2, "vectorFromArray", { enumerable: true, get: function() {
      return factories_js_1.vectorFromArray;
    } });
    Object.defineProperty(exports2, "tableFromJSON", { enumerable: true, get: function() {
      return factories_js_1.tableFromJSON;
    } });
    Object.defineProperty(exports2, "builderThroughIterable", { enumerable: true, get: function() {
      return factories_js_1.builderThroughIterable;
    } });
    Object.defineProperty(exports2, "builderThroughAsyncIterable", { enumerable: true, get: function() {
      return factories_js_1.builderThroughAsyncIterable;
    } });
    var bool_js_1 = require_bool2();
    Object.defineProperty(exports2, "BoolBuilder", { enumerable: true, get: function() {
      return bool_js_1.BoolBuilder;
    } });
    var null_js_1 = require_null2();
    Object.defineProperty(exports2, "NullBuilder", { enumerable: true, get: function() {
      return null_js_1.NullBuilder;
    } });
    var date_js_1 = require_date3();
    Object.defineProperty(exports2, "DateBuilder", { enumerable: true, get: function() {
      return date_js_1.DateBuilder;
    } });
    Object.defineProperty(exports2, "DateDayBuilder", { enumerable: true, get: function() {
      return date_js_1.DateDayBuilder;
    } });
    Object.defineProperty(exports2, "DateMillisecondBuilder", { enumerable: true, get: function() {
      return date_js_1.DateMillisecondBuilder;
    } });
    var decimal_js_1 = require_decimal2();
    Object.defineProperty(exports2, "DecimalBuilder", { enumerable: true, get: function() {
      return decimal_js_1.DecimalBuilder;
    } });
    var dictionary_js_1 = require_dictionary();
    Object.defineProperty(exports2, "DictionaryBuilder", { enumerable: true, get: function() {
      return dictionary_js_1.DictionaryBuilder;
    } });
    var fixedsizebinary_js_1 = require_fixedsizebinary();
    Object.defineProperty(exports2, "FixedSizeBinaryBuilder", { enumerable: true, get: function() {
      return fixedsizebinary_js_1.FixedSizeBinaryBuilder;
    } });
    var float_js_1 = require_float();
    Object.defineProperty(exports2, "FloatBuilder", { enumerable: true, get: function() {
      return float_js_1.FloatBuilder;
    } });
    Object.defineProperty(exports2, "Float16Builder", { enumerable: true, get: function() {
      return float_js_1.Float16Builder;
    } });
    Object.defineProperty(exports2, "Float32Builder", { enumerable: true, get: function() {
      return float_js_1.Float32Builder;
    } });
    Object.defineProperty(exports2, "Float64Builder", { enumerable: true, get: function() {
      return float_js_1.Float64Builder;
    } });
    var int_js_1 = require_int3();
    Object.defineProperty(exports2, "IntBuilder", { enumerable: true, get: function() {
      return int_js_1.IntBuilder;
    } });
    Object.defineProperty(exports2, "Int8Builder", { enumerable: true, get: function() {
      return int_js_1.Int8Builder;
    } });
    Object.defineProperty(exports2, "Int16Builder", { enumerable: true, get: function() {
      return int_js_1.Int16Builder;
    } });
    Object.defineProperty(exports2, "Int32Builder", { enumerable: true, get: function() {
      return int_js_1.Int32Builder;
    } });
    Object.defineProperty(exports2, "Int64Builder", { enumerable: true, get: function() {
      return int_js_1.Int64Builder;
    } });
    Object.defineProperty(exports2, "Uint8Builder", { enumerable: true, get: function() {
      return int_js_1.Uint8Builder;
    } });
    Object.defineProperty(exports2, "Uint16Builder", { enumerable: true, get: function() {
      return int_js_1.Uint16Builder;
    } });
    Object.defineProperty(exports2, "Uint32Builder", { enumerable: true, get: function() {
      return int_js_1.Uint32Builder;
    } });
    Object.defineProperty(exports2, "Uint64Builder", { enumerable: true, get: function() {
      return int_js_1.Uint64Builder;
    } });
    var time_js_1 = require_time2();
    Object.defineProperty(exports2, "TimeBuilder", { enumerable: true, get: function() {
      return time_js_1.TimeBuilder;
    } });
    Object.defineProperty(exports2, "TimeSecondBuilder", { enumerable: true, get: function() {
      return time_js_1.TimeSecondBuilder;
    } });
    Object.defineProperty(exports2, "TimeMillisecondBuilder", { enumerable: true, get: function() {
      return time_js_1.TimeMillisecondBuilder;
    } });
    Object.defineProperty(exports2, "TimeMicrosecondBuilder", { enumerable: true, get: function() {
      return time_js_1.TimeMicrosecondBuilder;
    } });
    Object.defineProperty(exports2, "TimeNanosecondBuilder", { enumerable: true, get: function() {
      return time_js_1.TimeNanosecondBuilder;
    } });
    var timestamp_js_1 = require_timestamp2();
    Object.defineProperty(exports2, "TimestampBuilder", { enumerable: true, get: function() {
      return timestamp_js_1.TimestampBuilder;
    } });
    Object.defineProperty(exports2, "TimestampSecondBuilder", { enumerable: true, get: function() {
      return timestamp_js_1.TimestampSecondBuilder;
    } });
    Object.defineProperty(exports2, "TimestampMillisecondBuilder", { enumerable: true, get: function() {
      return timestamp_js_1.TimestampMillisecondBuilder;
    } });
    Object.defineProperty(exports2, "TimestampMicrosecondBuilder", { enumerable: true, get: function() {
      return timestamp_js_1.TimestampMicrosecondBuilder;
    } });
    Object.defineProperty(exports2, "TimestampNanosecondBuilder", { enumerable: true, get: function() {
      return timestamp_js_1.TimestampNanosecondBuilder;
    } });
    var interval_js_1 = require_interval2();
    Object.defineProperty(exports2, "IntervalBuilder", { enumerable: true, get: function() {
      return interval_js_1.IntervalBuilder;
    } });
    Object.defineProperty(exports2, "IntervalDayTimeBuilder", { enumerable: true, get: function() {
      return interval_js_1.IntervalDayTimeBuilder;
    } });
    Object.defineProperty(exports2, "IntervalYearMonthBuilder", { enumerable: true, get: function() {
      return interval_js_1.IntervalYearMonthBuilder;
    } });
    var duration_js_1 = require_duration2();
    Object.defineProperty(exports2, "DurationBuilder", { enumerable: true, get: function() {
      return duration_js_1.DurationBuilder;
    } });
    Object.defineProperty(exports2, "DurationSecondBuilder", { enumerable: true, get: function() {
      return duration_js_1.DurationSecondBuilder;
    } });
    Object.defineProperty(exports2, "DurationMillisecondBuilder", { enumerable: true, get: function() {
      return duration_js_1.DurationMillisecondBuilder;
    } });
    Object.defineProperty(exports2, "DurationMicrosecondBuilder", { enumerable: true, get: function() {
      return duration_js_1.DurationMicrosecondBuilder;
    } });
    Object.defineProperty(exports2, "DurationNanosecondBuilder", { enumerable: true, get: function() {
      return duration_js_1.DurationNanosecondBuilder;
    } });
    var utf8_js_1 = require_utf83();
    Object.defineProperty(exports2, "Utf8Builder", { enumerable: true, get: function() {
      return utf8_js_1.Utf8Builder;
    } });
    var largeutf8_js_1 = require_largeutf8();
    Object.defineProperty(exports2, "LargeUtf8Builder", { enumerable: true, get: function() {
      return largeutf8_js_1.LargeUtf8Builder;
    } });
    var binary_js_1 = require_binary2();
    Object.defineProperty(exports2, "BinaryBuilder", { enumerable: true, get: function() {
      return binary_js_1.BinaryBuilder;
    } });
    var largebinary_js_1 = require_largebinary();
    Object.defineProperty(exports2, "LargeBinaryBuilder", { enumerable: true, get: function() {
      return largebinary_js_1.LargeBinaryBuilder;
    } });
    var list_js_1 = require_list2();
    Object.defineProperty(exports2, "ListBuilder", { enumerable: true, get: function() {
      return list_js_1.ListBuilder;
    } });
    var fixedsizelist_js_1 = require_fixedsizelist();
    Object.defineProperty(exports2, "FixedSizeListBuilder", { enumerable: true, get: function() {
      return fixedsizelist_js_1.FixedSizeListBuilder;
    } });
    var map_js_2 = require_map3();
    Object.defineProperty(exports2, "MapBuilder", { enumerable: true, get: function() {
      return map_js_2.MapBuilder;
    } });
    var struct_js_2 = require_struct3();
    Object.defineProperty(exports2, "StructBuilder", { enumerable: true, get: function() {
      return struct_js_2.StructBuilder;
    } });
    var union_js_1 = require_union2();
    Object.defineProperty(exports2, "UnionBuilder", { enumerable: true, get: function() {
      return union_js_1.UnionBuilder;
    } });
    Object.defineProperty(exports2, "SparseUnionBuilder", { enumerable: true, get: function() {
      return union_js_1.SparseUnionBuilder;
    } });
    Object.defineProperty(exports2, "DenseUnionBuilder", { enumerable: true, get: function() {
      return union_js_1.DenseUnionBuilder;
    } });
    var stream_js_1 = require_stream();
    Object.defineProperty(exports2, "ByteStream", { enumerable: true, get: function() {
      return stream_js_1.ByteStream;
    } });
    Object.defineProperty(exports2, "AsyncByteStream", { enumerable: true, get: function() {
      return stream_js_1.AsyncByteStream;
    } });
    Object.defineProperty(exports2, "AsyncByteQueue", { enumerable: true, get: function() {
      return stream_js_1.AsyncByteQueue;
    } });
    var reader_js_1 = require_reader();
    Object.defineProperty(exports2, "RecordBatchReader", { enumerable: true, get: function() {
      return reader_js_1.RecordBatchReader;
    } });
    Object.defineProperty(exports2, "RecordBatchFileReader", { enumerable: true, get: function() {
      return reader_js_1.RecordBatchFileReader;
    } });
    Object.defineProperty(exports2, "RecordBatchStreamReader", { enumerable: true, get: function() {
      return reader_js_1.RecordBatchStreamReader;
    } });
    Object.defineProperty(exports2, "AsyncRecordBatchFileReader", { enumerable: true, get: function() {
      return reader_js_1.AsyncRecordBatchFileReader;
    } });
    Object.defineProperty(exports2, "AsyncRecordBatchStreamReader", { enumerable: true, get: function() {
      return reader_js_1.AsyncRecordBatchStreamReader;
    } });
    var writer_js_1 = require_writer();
    Object.defineProperty(exports2, "RecordBatchWriter", { enumerable: true, get: function() {
      return writer_js_1.RecordBatchWriter;
    } });
    Object.defineProperty(exports2, "RecordBatchFileWriter", { enumerable: true, get: function() {
      return writer_js_1.RecordBatchFileWriter;
    } });
    Object.defineProperty(exports2, "RecordBatchStreamWriter", { enumerable: true, get: function() {
      return writer_js_1.RecordBatchStreamWriter;
    } });
    Object.defineProperty(exports2, "RecordBatchJSONWriter", { enumerable: true, get: function() {
      return writer_js_1.RecordBatchJSONWriter;
    } });
    var serialization_js_1 = require_serialization();
    Object.defineProperty(exports2, "tableToIPC", { enumerable: true, get: function() {
      return serialization_js_1.tableToIPC;
    } });
    Object.defineProperty(exports2, "tableFromIPC", { enumerable: true, get: function() {
      return serialization_js_1.tableFromIPC;
    } });
    var message_js_1 = require_message3();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return message_js_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AsyncMessageReader", { enumerable: true, get: function() {
      return message_js_1.AsyncMessageReader;
    } });
    Object.defineProperty(exports2, "JSONMessageReader", { enumerable: true, get: function() {
      return message_js_1.JSONMessageReader;
    } });
    var message_js_2 = require_message2();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return message_js_2.Message;
    } });
    var recordbatch_js_1 = require_recordbatch2();
    Object.defineProperty(exports2, "RecordBatch", { enumerable: true, get: function() {
      return recordbatch_js_1.RecordBatch;
    } });
    var util_bn_ = require_bn();
    var util_int_ = require_int2();
    var util_bit_ = require_bit();
    var util_math_ = require_math();
    var util_buffer_ = require_buffer();
    var util_vector_ = require_vector();
    var util_pretty_ = require_pretty();
    var typecomparator_js_1 = require_typecomparator();
    exports2.util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, util_bn_), util_int_), util_bit_), util_math_), util_buffer_), util_vector_), util_pretty_), {
      compareSchemas: typecomparator_js_1.compareSchemas,
      compareFields: typecomparator_js_1.compareFields,
      compareTypes: typecomparator_js_1.compareTypes
    });
  }
});

// node_modules/apache-arrow/Arrow.dom.js
var require_Arrow_dom = __commonJS({
  "node_modules/apache-arrow/Arrow.dom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Union = exports2.StructRow = exports2.Struct = exports2.List = exports2.Decimal = exports2.TimeNanosecond = exports2.TimeMicrosecond = exports2.TimeMillisecond = exports2.TimeSecond = exports2.Time = exports2.TimestampNanosecond = exports2.TimestampMicrosecond = exports2.TimestampMillisecond = exports2.TimestampSecond = exports2.Timestamp = exports2.DateMillisecond = exports2.DateDay = exports2.Date_ = exports2.FixedSizeBinary = exports2.LargeBinary = exports2.Binary = exports2.LargeUtf8 = exports2.Utf8 = exports2.Float64 = exports2.Float32 = exports2.Float16 = exports2.Float = exports2.Uint64 = exports2.Uint32 = exports2.Uint16 = exports2.Uint8 = exports2.Int64 = exports2.Int32 = exports2.Int16 = exports2.Int8 = exports2.Int = exports2.Bool = exports2.Null = exports2.DataType = exports2.makeData = exports2.Data = exports2.BufferType = exports2.UnionMode = exports2.Type = exports2.TimeUnit = exports2.Precision = exports2.MetadataVersion = exports2.MessageHeader = exports2.IntervalUnit = exports2.DateUnit = void 0;
    exports2.LargeBinaryBuilder = exports2.BinaryBuilder = exports2.builderThroughAsyncIterable = exports2.builderThroughIterable = exports2.makeBuilder = exports2.Builder = exports2.util = exports2.RecordBatch = exports2.Message = exports2.JSONMessageReader = exports2.AsyncMessageReader = exports2.MessageReader = exports2.tableToIPC = exports2.tableFromIPC = exports2.RecordBatchJSONWriter = exports2.RecordBatchStreamWriter = exports2.RecordBatchFileWriter = exports2.RecordBatchWriter = exports2.AsyncRecordBatchStreamReader = exports2.AsyncRecordBatchFileReader = exports2.RecordBatchStreamReader = exports2.RecordBatchFileReader = exports2.RecordBatchReader = exports2.AsyncByteQueue = exports2.AsyncByteStream = exports2.ByteStream = exports2.tableFromJSON = exports2.vectorFromArray = exports2.makeVector = exports2.Vector = exports2.Visitor = exports2.Field = exports2.Schema = exports2.tableFromArrays = exports2.makeTable = exports2.Table = exports2.MapRow = exports2.Map_ = exports2.FixedSizeList = exports2.DurationNanosecond = exports2.DurationMicrosecond = exports2.DurationMillisecond = exports2.DurationSecond = exports2.Duration = exports2.IntervalYearMonth = exports2.IntervalDayTime = exports2.Interval = exports2.Dictionary = exports2.SparseUnion = exports2.DenseUnion = void 0;
    exports2.LargeUtf8Builder = exports2.Utf8Builder = exports2.SparseUnionBuilder = exports2.DenseUnionBuilder = exports2.UnionBuilder = exports2.TimeNanosecondBuilder = exports2.TimeMicrosecondBuilder = exports2.TimeMillisecondBuilder = exports2.TimeSecondBuilder = exports2.TimeBuilder = exports2.TimestampNanosecondBuilder = exports2.TimestampMicrosecondBuilder = exports2.TimestampMillisecondBuilder = exports2.TimestampSecondBuilder = exports2.TimestampBuilder = exports2.StructBuilder = exports2.NullBuilder = exports2.MapBuilder = exports2.ListBuilder = exports2.Uint64Builder = exports2.Uint32Builder = exports2.Uint16Builder = exports2.Uint8Builder = exports2.Int64Builder = exports2.Int32Builder = exports2.Int16Builder = exports2.Int8Builder = exports2.IntBuilder = exports2.DurationNanosecondBuilder = exports2.DurationMicrosecondBuilder = exports2.DurationMillisecondBuilder = exports2.DurationSecondBuilder = exports2.DurationBuilder = exports2.IntervalYearMonthBuilder = exports2.IntervalDayTimeBuilder = exports2.IntervalBuilder = exports2.Float64Builder = exports2.Float32Builder = exports2.Float16Builder = exports2.FloatBuilder = exports2.FixedSizeListBuilder = exports2.FixedSizeBinaryBuilder = exports2.DictionaryBuilder = exports2.DecimalBuilder = exports2.DateMillisecondBuilder = exports2.DateDayBuilder = exports2.DateBuilder = exports2.BoolBuilder = void 0;
    var adapters_js_1 = require_adapters();
    var builder_js_1 = require_builder2();
    var reader_js_1 = require_reader();
    var writer_js_1 = require_writer();
    var iterable_js_1 = require_iterable2();
    var builder_js_2 = require_builder4();
    var reader_js_2 = require_reader3();
    var writer_js_2 = require_writer3();
    adapters_js_1.default.toDOMStream = iterable_js_1.toDOMStream;
    builder_js_1.Builder["throughDOM"] = builder_js_2.builderThroughDOMStream;
    reader_js_1.RecordBatchReader["throughDOM"] = reader_js_2.recordBatchReaderThroughDOMStream;
    reader_js_1.RecordBatchFileReader["throughDOM"] = reader_js_2.recordBatchReaderThroughDOMStream;
    reader_js_1.RecordBatchStreamReader["throughDOM"] = reader_js_2.recordBatchReaderThroughDOMStream;
    writer_js_1.RecordBatchWriter["throughDOM"] = writer_js_2.recordBatchWriterThroughDOMStream;
    writer_js_1.RecordBatchFileWriter["throughDOM"] = writer_js_2.recordBatchWriterThroughDOMStream;
    writer_js_1.RecordBatchStreamWriter["throughDOM"] = writer_js_2.recordBatchWriterThroughDOMStream;
    var Arrow_js_1 = require_Arrow();
    Object.defineProperty(exports2, "DateUnit", { enumerable: true, get: function() {
      return Arrow_js_1.DateUnit;
    } });
    Object.defineProperty(exports2, "IntervalUnit", { enumerable: true, get: function() {
      return Arrow_js_1.IntervalUnit;
    } });
    Object.defineProperty(exports2, "MessageHeader", { enumerable: true, get: function() {
      return Arrow_js_1.MessageHeader;
    } });
    Object.defineProperty(exports2, "MetadataVersion", { enumerable: true, get: function() {
      return Arrow_js_1.MetadataVersion;
    } });
    Object.defineProperty(exports2, "Precision", { enumerable: true, get: function() {
      return Arrow_js_1.Precision;
    } });
    Object.defineProperty(exports2, "TimeUnit", { enumerable: true, get: function() {
      return Arrow_js_1.TimeUnit;
    } });
    Object.defineProperty(exports2, "Type", { enumerable: true, get: function() {
      return Arrow_js_1.Type;
    } });
    Object.defineProperty(exports2, "UnionMode", { enumerable: true, get: function() {
      return Arrow_js_1.UnionMode;
    } });
    Object.defineProperty(exports2, "BufferType", { enumerable: true, get: function() {
      return Arrow_js_1.BufferType;
    } });
    Object.defineProperty(exports2, "Data", { enumerable: true, get: function() {
      return Arrow_js_1.Data;
    } });
    Object.defineProperty(exports2, "makeData", { enumerable: true, get: function() {
      return Arrow_js_1.makeData;
    } });
    Object.defineProperty(exports2, "DataType", { enumerable: true, get: function() {
      return Arrow_js_1.DataType;
    } });
    Object.defineProperty(exports2, "Null", { enumerable: true, get: function() {
      return Arrow_js_1.Null;
    } });
    Object.defineProperty(exports2, "Bool", { enumerable: true, get: function() {
      return Arrow_js_1.Bool;
    } });
    Object.defineProperty(exports2, "Int", { enumerable: true, get: function() {
      return Arrow_js_1.Int;
    } });
    Object.defineProperty(exports2, "Int8", { enumerable: true, get: function() {
      return Arrow_js_1.Int8;
    } });
    Object.defineProperty(exports2, "Int16", { enumerable: true, get: function() {
      return Arrow_js_1.Int16;
    } });
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return Arrow_js_1.Int32;
    } });
    Object.defineProperty(exports2, "Int64", { enumerable: true, get: function() {
      return Arrow_js_1.Int64;
    } });
    Object.defineProperty(exports2, "Uint8", { enumerable: true, get: function() {
      return Arrow_js_1.Uint8;
    } });
    Object.defineProperty(exports2, "Uint16", { enumerable: true, get: function() {
      return Arrow_js_1.Uint16;
    } });
    Object.defineProperty(exports2, "Uint32", { enumerable: true, get: function() {
      return Arrow_js_1.Uint32;
    } });
    Object.defineProperty(exports2, "Uint64", { enumerable: true, get: function() {
      return Arrow_js_1.Uint64;
    } });
    Object.defineProperty(exports2, "Float", { enumerable: true, get: function() {
      return Arrow_js_1.Float;
    } });
    Object.defineProperty(exports2, "Float16", { enumerable: true, get: function() {
      return Arrow_js_1.Float16;
    } });
    Object.defineProperty(exports2, "Float32", { enumerable: true, get: function() {
      return Arrow_js_1.Float32;
    } });
    Object.defineProperty(exports2, "Float64", { enumerable: true, get: function() {
      return Arrow_js_1.Float64;
    } });
    Object.defineProperty(exports2, "Utf8", { enumerable: true, get: function() {
      return Arrow_js_1.Utf8;
    } });
    Object.defineProperty(exports2, "LargeUtf8", { enumerable: true, get: function() {
      return Arrow_js_1.LargeUtf8;
    } });
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return Arrow_js_1.Binary;
    } });
    Object.defineProperty(exports2, "LargeBinary", { enumerable: true, get: function() {
      return Arrow_js_1.LargeBinary;
    } });
    Object.defineProperty(exports2, "FixedSizeBinary", { enumerable: true, get: function() {
      return Arrow_js_1.FixedSizeBinary;
    } });
    Object.defineProperty(exports2, "Date_", { enumerable: true, get: function() {
      return Arrow_js_1.Date_;
    } });
    Object.defineProperty(exports2, "DateDay", { enumerable: true, get: function() {
      return Arrow_js_1.DateDay;
    } });
    Object.defineProperty(exports2, "DateMillisecond", { enumerable: true, get: function() {
      return Arrow_js_1.DateMillisecond;
    } });
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return Arrow_js_1.Timestamp;
    } });
    Object.defineProperty(exports2, "TimestampSecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimestampSecond;
    } });
    Object.defineProperty(exports2, "TimestampMillisecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimestampMillisecond;
    } });
    Object.defineProperty(exports2, "TimestampMicrosecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimestampMicrosecond;
    } });
    Object.defineProperty(exports2, "TimestampNanosecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimestampNanosecond;
    } });
    Object.defineProperty(exports2, "Time", { enumerable: true, get: function() {
      return Arrow_js_1.Time;
    } });
    Object.defineProperty(exports2, "TimeSecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimeSecond;
    } });
    Object.defineProperty(exports2, "TimeMillisecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimeMillisecond;
    } });
    Object.defineProperty(exports2, "TimeMicrosecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimeMicrosecond;
    } });
    Object.defineProperty(exports2, "TimeNanosecond", { enumerable: true, get: function() {
      return Arrow_js_1.TimeNanosecond;
    } });
    Object.defineProperty(exports2, "Decimal", { enumerable: true, get: function() {
      return Arrow_js_1.Decimal;
    } });
    Object.defineProperty(exports2, "List", { enumerable: true, get: function() {
      return Arrow_js_1.List;
    } });
    Object.defineProperty(exports2, "Struct", { enumerable: true, get: function() {
      return Arrow_js_1.Struct;
    } });
    Object.defineProperty(exports2, "StructRow", { enumerable: true, get: function() {
      return Arrow_js_1.StructRow;
    } });
    Object.defineProperty(exports2, "Union", { enumerable: true, get: function() {
      return Arrow_js_1.Union;
    } });
    Object.defineProperty(exports2, "DenseUnion", { enumerable: true, get: function() {
      return Arrow_js_1.DenseUnion;
    } });
    Object.defineProperty(exports2, "SparseUnion", { enumerable: true, get: function() {
      return Arrow_js_1.SparseUnion;
    } });
    Object.defineProperty(exports2, "Dictionary", { enumerable: true, get: function() {
      return Arrow_js_1.Dictionary;
    } });
    Object.defineProperty(exports2, "Interval", { enumerable: true, get: function() {
      return Arrow_js_1.Interval;
    } });
    Object.defineProperty(exports2, "IntervalDayTime", { enumerable: true, get: function() {
      return Arrow_js_1.IntervalDayTime;
    } });
    Object.defineProperty(exports2, "IntervalYearMonth", { enumerable: true, get: function() {
      return Arrow_js_1.IntervalYearMonth;
    } });
    Object.defineProperty(exports2, "Duration", { enumerable: true, get: function() {
      return Arrow_js_1.Duration;
    } });
    Object.defineProperty(exports2, "DurationSecond", { enumerable: true, get: function() {
      return Arrow_js_1.DurationSecond;
    } });
    Object.defineProperty(exports2, "DurationMillisecond", { enumerable: true, get: function() {
      return Arrow_js_1.DurationMillisecond;
    } });
    Object.defineProperty(exports2, "DurationMicrosecond", { enumerable: true, get: function() {
      return Arrow_js_1.DurationMicrosecond;
    } });
    Object.defineProperty(exports2, "DurationNanosecond", { enumerable: true, get: function() {
      return Arrow_js_1.DurationNanosecond;
    } });
    Object.defineProperty(exports2, "FixedSizeList", { enumerable: true, get: function() {
      return Arrow_js_1.FixedSizeList;
    } });
    Object.defineProperty(exports2, "Map_", { enumerable: true, get: function() {
      return Arrow_js_1.Map_;
    } });
    Object.defineProperty(exports2, "MapRow", { enumerable: true, get: function() {
      return Arrow_js_1.MapRow;
    } });
    Object.defineProperty(exports2, "Table", { enumerable: true, get: function() {
      return Arrow_js_1.Table;
    } });
    Object.defineProperty(exports2, "makeTable", { enumerable: true, get: function() {
      return Arrow_js_1.makeTable;
    } });
    Object.defineProperty(exports2, "tableFromArrays", { enumerable: true, get: function() {
      return Arrow_js_1.tableFromArrays;
    } });
    Object.defineProperty(exports2, "Schema", { enumerable: true, get: function() {
      return Arrow_js_1.Schema;
    } });
    Object.defineProperty(exports2, "Field", { enumerable: true, get: function() {
      return Arrow_js_1.Field;
    } });
    Object.defineProperty(exports2, "Visitor", { enumerable: true, get: function() {
      return Arrow_js_1.Visitor;
    } });
    Object.defineProperty(exports2, "Vector", { enumerable: true, get: function() {
      return Arrow_js_1.Vector;
    } });
    Object.defineProperty(exports2, "makeVector", { enumerable: true, get: function() {
      return Arrow_js_1.makeVector;
    } });
    Object.defineProperty(exports2, "vectorFromArray", { enumerable: true, get: function() {
      return Arrow_js_1.vectorFromArray;
    } });
    Object.defineProperty(exports2, "tableFromJSON", { enumerable: true, get: function() {
      return Arrow_js_1.tableFromJSON;
    } });
    Object.defineProperty(exports2, "ByteStream", { enumerable: true, get: function() {
      return Arrow_js_1.ByteStream;
    } });
    Object.defineProperty(exports2, "AsyncByteStream", { enumerable: true, get: function() {
      return Arrow_js_1.AsyncByteStream;
    } });
    Object.defineProperty(exports2, "AsyncByteQueue", { enumerable: true, get: function() {
      return Arrow_js_1.AsyncByteQueue;
    } });
    Object.defineProperty(exports2, "RecordBatchReader", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatchReader;
    } });
    Object.defineProperty(exports2, "RecordBatchFileReader", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatchFileReader;
    } });
    Object.defineProperty(exports2, "RecordBatchStreamReader", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatchStreamReader;
    } });
    Object.defineProperty(exports2, "AsyncRecordBatchFileReader", { enumerable: true, get: function() {
      return Arrow_js_1.AsyncRecordBatchFileReader;
    } });
    Object.defineProperty(exports2, "AsyncRecordBatchStreamReader", { enumerable: true, get: function() {
      return Arrow_js_1.AsyncRecordBatchStreamReader;
    } });
    Object.defineProperty(exports2, "RecordBatchWriter", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatchWriter;
    } });
    Object.defineProperty(exports2, "RecordBatchFileWriter", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatchFileWriter;
    } });
    Object.defineProperty(exports2, "RecordBatchStreamWriter", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatchStreamWriter;
    } });
    Object.defineProperty(exports2, "RecordBatchJSONWriter", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatchJSONWriter;
    } });
    Object.defineProperty(exports2, "tableFromIPC", { enumerable: true, get: function() {
      return Arrow_js_1.tableFromIPC;
    } });
    Object.defineProperty(exports2, "tableToIPC", { enumerable: true, get: function() {
      return Arrow_js_1.tableToIPC;
    } });
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return Arrow_js_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AsyncMessageReader", { enumerable: true, get: function() {
      return Arrow_js_1.AsyncMessageReader;
    } });
    Object.defineProperty(exports2, "JSONMessageReader", { enumerable: true, get: function() {
      return Arrow_js_1.JSONMessageReader;
    } });
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return Arrow_js_1.Message;
    } });
    Object.defineProperty(exports2, "RecordBatch", { enumerable: true, get: function() {
      return Arrow_js_1.RecordBatch;
    } });
    Object.defineProperty(exports2, "util", { enumerable: true, get: function() {
      return Arrow_js_1.util;
    } });
    Object.defineProperty(exports2, "Builder", { enumerable: true, get: function() {
      return Arrow_js_1.Builder;
    } });
    Object.defineProperty(exports2, "makeBuilder", { enumerable: true, get: function() {
      return Arrow_js_1.makeBuilder;
    } });
    Object.defineProperty(exports2, "builderThroughIterable", { enumerable: true, get: function() {
      return Arrow_js_1.builderThroughIterable;
    } });
    Object.defineProperty(exports2, "builderThroughAsyncIterable", { enumerable: true, get: function() {
      return Arrow_js_1.builderThroughAsyncIterable;
    } });
    var Arrow_js_2 = require_Arrow();
    Object.defineProperty(exports2, "BinaryBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.BinaryBuilder;
    } });
    Object.defineProperty(exports2, "LargeBinaryBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.LargeBinaryBuilder;
    } });
    Object.defineProperty(exports2, "BoolBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.BoolBuilder;
    } });
    Object.defineProperty(exports2, "DateBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DateBuilder;
    } });
    Object.defineProperty(exports2, "DateDayBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DateDayBuilder;
    } });
    Object.defineProperty(exports2, "DateMillisecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DateMillisecondBuilder;
    } });
    Object.defineProperty(exports2, "DecimalBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DecimalBuilder;
    } });
    Object.defineProperty(exports2, "DictionaryBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DictionaryBuilder;
    } });
    Object.defineProperty(exports2, "FixedSizeBinaryBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.FixedSizeBinaryBuilder;
    } });
    Object.defineProperty(exports2, "FixedSizeListBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.FixedSizeListBuilder;
    } });
    Object.defineProperty(exports2, "FloatBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.FloatBuilder;
    } });
    Object.defineProperty(exports2, "Float16Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Float16Builder;
    } });
    Object.defineProperty(exports2, "Float32Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Float32Builder;
    } });
    Object.defineProperty(exports2, "Float64Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Float64Builder;
    } });
    Object.defineProperty(exports2, "IntervalBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.IntervalBuilder;
    } });
    Object.defineProperty(exports2, "IntervalDayTimeBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.IntervalDayTimeBuilder;
    } });
    Object.defineProperty(exports2, "IntervalYearMonthBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.IntervalYearMonthBuilder;
    } });
    Object.defineProperty(exports2, "DurationBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DurationBuilder;
    } });
    Object.defineProperty(exports2, "DurationSecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DurationSecondBuilder;
    } });
    Object.defineProperty(exports2, "DurationMillisecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DurationMillisecondBuilder;
    } });
    Object.defineProperty(exports2, "DurationMicrosecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DurationMicrosecondBuilder;
    } });
    Object.defineProperty(exports2, "DurationNanosecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DurationNanosecondBuilder;
    } });
    Object.defineProperty(exports2, "IntBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.IntBuilder;
    } });
    Object.defineProperty(exports2, "Int8Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Int8Builder;
    } });
    Object.defineProperty(exports2, "Int16Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Int16Builder;
    } });
    Object.defineProperty(exports2, "Int32Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Int32Builder;
    } });
    Object.defineProperty(exports2, "Int64Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Int64Builder;
    } });
    Object.defineProperty(exports2, "Uint8Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Uint8Builder;
    } });
    Object.defineProperty(exports2, "Uint16Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Uint16Builder;
    } });
    Object.defineProperty(exports2, "Uint32Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Uint32Builder;
    } });
    Object.defineProperty(exports2, "Uint64Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Uint64Builder;
    } });
    Object.defineProperty(exports2, "ListBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.ListBuilder;
    } });
    Object.defineProperty(exports2, "MapBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.MapBuilder;
    } });
    Object.defineProperty(exports2, "NullBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.NullBuilder;
    } });
    Object.defineProperty(exports2, "StructBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.StructBuilder;
    } });
    Object.defineProperty(exports2, "TimestampBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimestampBuilder;
    } });
    Object.defineProperty(exports2, "TimestampSecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimestampSecondBuilder;
    } });
    Object.defineProperty(exports2, "TimestampMillisecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimestampMillisecondBuilder;
    } });
    Object.defineProperty(exports2, "TimestampMicrosecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimestampMicrosecondBuilder;
    } });
    Object.defineProperty(exports2, "TimestampNanosecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimestampNanosecondBuilder;
    } });
    Object.defineProperty(exports2, "TimeBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimeBuilder;
    } });
    Object.defineProperty(exports2, "TimeSecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimeSecondBuilder;
    } });
    Object.defineProperty(exports2, "TimeMillisecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimeMillisecondBuilder;
    } });
    Object.defineProperty(exports2, "TimeMicrosecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimeMicrosecondBuilder;
    } });
    Object.defineProperty(exports2, "TimeNanosecondBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.TimeNanosecondBuilder;
    } });
    Object.defineProperty(exports2, "UnionBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.UnionBuilder;
    } });
    Object.defineProperty(exports2, "DenseUnionBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.DenseUnionBuilder;
    } });
    Object.defineProperty(exports2, "SparseUnionBuilder", { enumerable: true, get: function() {
      return Arrow_js_2.SparseUnionBuilder;
    } });
    Object.defineProperty(exports2, "Utf8Builder", { enumerable: true, get: function() {
      return Arrow_js_2.Utf8Builder;
    } });
    Object.defineProperty(exports2, "LargeUtf8Builder", { enumerable: true, get: function() {
      return Arrow_js_2.LargeUtf8Builder;
    } });
  }
});

// node_modules/apache-arrow/Arrow.node.js
var require_Arrow_node = __commonJS({
  "node_modules/apache-arrow/Arrow.node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var adapters_js_1 = require_adapters();
    var builder_js_1 = require_builder2();
    var reader_js_1 = require_reader();
    var writer_js_1 = require_writer();
    var iterable_js_1 = require_iterable();
    var builder_js_2 = require_builder3();
    var reader_js_2 = require_reader2();
    var writer_js_2 = require_writer2();
    adapters_js_1.default.toNodeStream = iterable_js_1.toNodeStream;
    builder_js_1.Builder["throughNode"] = builder_js_2.builderThroughNodeStream;
    reader_js_1.RecordBatchReader["throughNode"] = reader_js_2.recordBatchReaderThroughNodeStream;
    writer_js_1.RecordBatchWriter["throughNode"] = writer_js_2.recordBatchWriterThroughNodeStream;
    tslib_1.__exportStar(require_Arrow_dom(), exports2);
  }
});

// node_modules/@elastic/elasticsearch/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/helpers.js"(exports2) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_assert_1 = tslib_1.__importDefault(require("node:assert"));
    var timersPromises = tslib_1.__importStar(require("node:timers/promises"));
    var node_stream_1 = require("node:stream");
    var transport_1 = require_transport();
    var Arrow_node_1 = require_Arrow_node();
    var { ResponseError, ConfigurationError } = transport_1.errors;
    var sleep = timersPromises.setTimeout;
    var pImmediate = timersPromises.setImmediate;
    var noop = () => {
    };
    var kClient = Symbol("elasticsearch-client");
    var kMetaHeader = Symbol("meta header");
    var kMaxRetries = Symbol("max retries");
    var Helpers = class {
      constructor(opts) {
        Object.defineProperty(this, _a, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _b, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _c, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this[kClient] = opts.client;
        this[kMetaHeader] = opts.metaHeader;
        this[kMaxRetries] = opts.maxRetries;
      }
      /**
       * Runs a search operation. The only difference between client.search and this utility,
       * is that we are only returning the hits to the user and not the full ES response.
       * This helper automatically adds `filter_path=hits.hits._source` to the querystring,
       * as it will only need the documents source.
       * @param {object} params - The Elasticsearch's search parameters.
       * @param {object} options - The client optional configuration for this request.
       * @return {array} The documents that matched the request.
       */
      async search(params, options = {}) {
        var _d;
        appendFilterPath("hits.hits._id,hits.hits._source", params, true);
        options.meta = true;
        const { body: result } = await this[kClient].search(params, options);
        if (((_d = result.hits) === null || _d === void 0 ? void 0 : _d.hits) != null) {
          return result.hits.hits.map((d) => ({
            // Starting with version 8.14.0, _id is optional, but in our case it's always present.
            // See @es_quirk documentation in elasticsearch-specification/specification/_global/search/_types/hits.ts
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _id: d._id,
            ...d._source
          }));
        }
        return [];
      }
      /**
       * Runs a scroll search operation. This function returns an async iterator, allowing
       * the user to use a for await loop to get all the results of a given search.
       * ```js
       * for await (const result of client.helpers.scrollSearch({ params })) {
       *   console.log(result)
       * }
       * ```
       * Each result represents the entire body of a single scroll search request,
       * if you just need to scroll the results, use scrollDocuments.
       * This function handles automatically retries on 429 status code.
       * @param {object} params - The Elasticsearch's search parameters.
       * @param {object} options - The client optional configuration for this request.
       * @return {iterator} the async iterator
       */
      async *scrollSearch(params, options = {}) {
        var _d, _e, _f, _g;
        options.meta = true;
        if (this[kMetaHeader] !== null) {
          options.headers = (_d = options.headers) !== null && _d !== void 0 ? _d : {};
          options.headers["x-elastic-client-meta"] = `${this[kMetaHeader]},h=s`;
        }
        const wait = (_e = options.wait) !== null && _e !== void 0 ? _e : 5e3;
        const maxRetries = (_f = options.maxRetries) !== null && _f !== void 0 ? _f : this[kMaxRetries];
        if (Array.isArray(options.ignore)) {
          options.ignore.push(429);
        } else {
          options.ignore = [429];
        }
        params.scroll = (_g = params.scroll) !== null && _g !== void 0 ? _g : "1m";
        appendFilterPath("_scroll_id", params, false);
        let response;
        for (let i = 0; i <= maxRetries; i++) {
          response = await this[kClient].search(params, options);
          if (response.statusCode !== 429)
            break;
          await sleep(wait);
        }
        (0, node_assert_1.default)(response !== void 0, "The response is undefined, please file a bug report");
        const { redaction = { type: "replace" } } = options;
        const errorOptions = { redaction };
        if (response.statusCode === 429) {
          throw new ResponseError(response, errorOptions);
        }
        let scroll_id = response.body._scroll_id;
        let stop = false;
        const clear = async () => {
          stop = true;
          await this[kClient].clearScroll({ scroll_id }, { ignore: [400], ...options });
        };
        while (response.body.hits != null && response.body.hits.hits.length > 0) {
          scroll_id = response.body._scroll_id;
          response.clear = clear;
          addDocumentsGetter(response);
          yield response;
          if (stop) {
            break;
          }
          for (let i = 0; i <= maxRetries; i++) {
            const r = await this[kClient].scroll({
              scroll: params.scroll,
              rest_total_hits_as_int: params.rest_total_hits_as_int,
              scroll_id
            }, options);
            response = r;
            (0, node_assert_1.default)(response !== void 0, "The response is undefined, please file a bug report");
            if (response.statusCode !== 429)
              break;
            await sleep(wait);
          }
          if (response.statusCode === 429) {
            throw new ResponseError(response, errorOptions);
          }
        }
        if (!stop) {
          await clear();
        }
      }
      /**
       * Runs a scroll search operation. This function returns an async iterator, allowing
       * the user to use a for await loop to get all the documents of a given search.
       * ```js
       * for await (const document of client.helpers.scrollSearch({ params })) {
       *   console.log(document)
       * }
       * ```
       * Each document is what you will find by running a scrollSearch and iterating on the hits array.
       * This helper automatically adds `filter_path=hits.hits._source` to the querystring,
       * as it will only need the documents source.
       * @param {object} params - The Elasticsearch's search parameters.
       * @param {object} options - The client optional configuration for this request.
       * @return {iterator} the async iterator
       */
      async *scrollDocuments(params, options = {}) {
        appendFilterPath("hits.hits._source", params, true);
        for await (const { documents } of this.scrollSearch(params, options)) {
          for (const document2 of documents) {
            yield document2;
          }
        }
      }
      /**
       * Creates a msearch helper instance. Once you configure it, you can use the provided
       * `search` method to add new searches in the queue.
       * @param {object} options - The configuration of the msearch operations.
       * @param {object} reqOptions - The client optional configuration for this request.
       * @return {object} The possible operations to run.
       */
      msearch(options = {}, reqOptions = {}) {
        const client = this[kClient];
        const { operations = 5, concurrency = 5, flushInterval = 500, retries = this[kMaxRetries], wait = 5e3, ...msearchOptions } = options;
        reqOptions.meta = true;
        const { redaction = { type: "replace" } } = reqOptions;
        const errorOptions = { redaction };
        let stopReading = false;
        let stopError = null;
        let timeoutRef = null;
        const operationsStream = new node_stream_1.Readable({
          objectMode: true,
          read(size) {
          }
        });
        const p = iterate();
        const helper = {
          [Symbol.toStringTag]: "Promise",
          then(onFulfilled, onRejected) {
            return p.then(onFulfilled, onRejected);
          },
          catch(onRejected) {
            return p.catch(onRejected);
          },
          finally(onFinally) {
            return p.finally(onFinally);
          },
          stop(error = null) {
            if (stopReading)
              return;
            stopReading = true;
            stopError = error;
            operationsStream.push(null);
          },
          // TODO: support abort a single search?
          // NOTE: the validation checks are synchronous and the callback/promise will
          //       be resolved in the same tick. We might want to fix this in the future.
          search(header, body) {
            if (stopReading) {
              const error = stopError === null ? new ConfigurationError("The msearch processor has been stopped") : stopError;
              return Promise.reject(error);
            }
            if (!(typeof header === "object" && header !== null && !Array.isArray(header))) {
              return Promise.reject(new ConfigurationError("The header should be an object"));
            }
            if (!(typeof body === "object" && body !== null && !Array.isArray(body))) {
              return Promise.reject(new ConfigurationError("The body should be an object"));
            }
            let onFulfilled = null;
            let onRejected = null;
            const promise = new Promise((resolve, reject) => {
              onFulfilled = resolve;
              onRejected = reject;
            });
            const callback = function callback2(err, result) {
              err !== null ? onRejected(err) : onFulfilled(result);
            };
            operationsStream.push([header, body, callback]);
            return promise;
          }
        };
        return helper;
        async function iterate() {
          const { semaphore, finish } = buildSemaphore();
          const msearchBody = [];
          const callbacks = [];
          let loadedOperations = 0;
          timeoutRef = setTimeout(onFlushTimeout, flushInterval);
          try {
            for await (const operation of operationsStream) {
              timeoutRef.refresh();
              loadedOperations += 1;
              msearchBody.push(operation[0], operation[1]);
              callbacks.push(operation[2]);
              if (loadedOperations >= operations) {
                const send = await semaphore();
                send(msearchBody.slice(), callbacks.slice());
                msearchBody.length = 0;
                callbacks.length = 0;
                loadedOperations = 0;
              }
            }
          } finally {
            clearTimeout(timeoutRef);
          }
          if (loadedOperations > 0) {
            const send = await semaphore();
            send(msearchBody, callbacks);
          }
          await finish();
          if (stopError !== null) {
            throw stopError;
          }
          async function onFlushTimeout() {
            if (loadedOperations === 0)
              return;
            const msearchBodyCopy = msearchBody.slice();
            const callbacksCopy = callbacks.slice();
            msearchBody.length = 0;
            callbacks.length = 0;
            loadedOperations = 0;
            try {
              const send = await semaphore();
              send(msearchBodyCopy, callbacksCopy);
            } catch (err) {
              helper.stop(err);
            }
          }
        }
        function buildSemaphore() {
          let resolveSemaphore = null;
          let resolveFinish = null;
          let running = 0;
          return { semaphore, finish };
          function finish() {
            return new Promise((resolve, reject) => {
              if (running === 0) {
                resolve();
              } else {
                resolveFinish = resolve;
              }
            });
          }
          function semaphore() {
            if (running < concurrency) {
              running += 1;
              return pImmediate(send);
            } else {
              return new Promise((resolve, reject) => {
                resolveSemaphore = resolve;
              });
            }
          }
          function send(msearchBody, callbacks) {
            if (running > concurrency) {
              throw new Error("Max concurrency reached");
            }
            msearchOperation(msearchBody, callbacks, () => {
              running -= 1;
              if (resolveSemaphore !== null) {
                running += 1;
                resolveSemaphore(send);
                resolveSemaphore = null;
              } else if (resolveFinish != null && running === 0) {
                resolveFinish();
              }
            });
          }
        }
        function msearchOperation(msearchBody, callbacks, done) {
          let retryCount = retries;
          tryMsearch(msearchBody, callbacks, retrySearch);
          function retrySearch(msearchBody2, callbacks2) {
            if (msearchBody2.length > 0 && retryCount > 0) {
              retryCount -= 1;
              setTimeout(tryMsearch, wait, msearchBody2, callbacks2, retrySearch);
              return;
            }
            done();
          }
          function tryMsearch(msearchBody2, callbacks2, done2) {
            client.msearch(Object.assign({}, msearchOptions, { body: msearchBody2 }), reqOptions).then((results) => {
              const retryBody = [];
              const retryCallbacks = [];
              const { responses } = results.body;
              for (let i = 0, len = responses.length; i < len; i++) {
                const response = responses[i];
                if (response.status === 429 && retryCount > 0) {
                  retryBody.push(msearchBody2[i * 2]);
                  retryBody.push(msearchBody2[i * 2 + 1]);
                  retryCallbacks.push(callbacks2[i]);
                  continue;
                }
                const result = { ...results, body: response };
                addDocumentsGetter(result);
                if (response.status != null && response.status >= 400) {
                  callbacks2[i](new ResponseError(result, errorOptions), result);
                } else {
                  callbacks2[i](null, result);
                }
              }
              done2(retryBody, retryCallbacks);
            }).catch((err) => {
              for (const callback of callbacks2) {
                callback(err, null);
              }
              return done2([], []);
            });
          }
        }
      }
      /**
       * Creates a bulk helper instance. Once you configure it, you can pick which operation
       * to execute with the given dataset, index, create, update, and delete.
       * @param {object} options - The configuration of the bulk operation.
       * @param {object} reqOptions - The client optional configuration for this request.
       * @return {object} The possible operations to run with the datasource.
       */
      bulk(options, reqOptions = {}) {
        var _d, _e;
        (0, node_assert_1.default)(!((_d = reqOptions.asStream) !== null && _d !== void 0 ? _d : false), "bulk helper: the asStream request option is not supported");
        const client = this[kClient];
        const { serializer } = client;
        if (this[kMetaHeader] !== null) {
          reqOptions.headers = (_e = reqOptions.headers) !== null && _e !== void 0 ? _e : {};
          reqOptions.headers["x-elastic-client-meta"] = `${this[kMetaHeader]},h=bp`;
        }
        reqOptions.meta = true;
        const {
          datasource,
          onDocument,
          flushBytes = 5e6,
          flushInterval = 3e4,
          concurrency = 5,
          retries = this[kMaxRetries],
          wait = 5e3,
          onDrop = noop,
          // onSuccess does not default to noop, to avoid the performance hit
          // of deserializing every document in the bulk request
          onSuccess,
          refreshOnCompletion = false,
          ...bulkOptions
        } = options;
        if (datasource === void 0) {
          return Promise.reject(new ConfigurationError("bulk helper: the datasource is required"));
        }
        if (!(Array.isArray(datasource) || Buffer.isBuffer(datasource) || isReadableStream(datasource) || isAsyncIterator(datasource))) {
          return Promise.reject(new ConfigurationError("bulk helper: the datasource must be an array or a buffer or a readable stream or an async generator"));
        }
        if (onDocument === void 0) {
          return Promise.reject(new ConfigurationError("bulk helper: the onDocument callback is required"));
        }
        let shouldAbort = false;
        let timeoutRef = null;
        const stats = {
          total: 0,
          failed: 0,
          retry: 0,
          successful: 0,
          noop: 0,
          time: 0,
          bytes: 0,
          aborted: false
        };
        const p = iterate();
        const helper = {
          [Symbol.toStringTag]: "Promise",
          then(onFulfilled, onRejected) {
            return p.then(onFulfilled, onRejected);
          },
          catch(onRejected) {
            return p.catch(onRejected);
          },
          finally(onFinally) {
            return p.finally(onFinally);
          },
          get stats() {
            return stats;
          },
          abort() {
            clearTimeout(timeoutRef);
            shouldAbort = true;
            stats.aborted = true;
            return this;
          }
        };
        return helper;
        async function iterate() {
          const { semaphore, finish } = buildSemaphore();
          const startTime = Date.now();
          const bulkBody = [];
          let actionBody = "";
          let payloadBody = "";
          let chunkBytes = 0;
          timeoutRef = setTimeout(onFlushTimeout, flushInterval);
          for await (const chunk of datasource) {
            if (shouldAbort)
              break;
            timeoutRef.refresh();
            const result = onDocument(chunk);
            const [action, payload] = Array.isArray(result) ? result : [result, chunk];
            const operation = Object.keys(action)[0];
            if (operation === "index" || operation === "create") {
              actionBody = serializer.serialize(action);
              payloadBody = typeof payload === "string" ? payload : serializer.serialize(payload);
              chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);
              bulkBody.push(actionBody, payloadBody);
            } else if (operation === "update") {
              actionBody = serializer.serialize(action);
              payloadBody = typeof chunk === "string" ? `{"doc":${chunk}}` : serializer.serialize({ doc: chunk, ...payload });
              chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);
              bulkBody.push(actionBody, payloadBody);
            } else if (operation === "delete") {
              actionBody = serializer.serialize(action);
              chunkBytes += Buffer.byteLength(actionBody);
              bulkBody.push(actionBody);
            } else {
              clearTimeout(timeoutRef);
              throw new ConfigurationError(`Bulk helper invalid action: '${operation}'`);
            }
            if (chunkBytes >= flushBytes) {
              stats.bytes += chunkBytes;
              const bulkBodyCopy = bulkBody.slice();
              bulkBody.length = 0;
              chunkBytes = 0;
              const send = await semaphore();
              send(bulkBodyCopy);
            }
          }
          clearTimeout(timeoutRef);
          if (!shouldAbort && chunkBytes > 0) {
            const send = await semaphore();
            stats.bytes += chunkBytes;
            send(bulkBody);
          }
          await finish();
          if (refreshOnCompletion !== false) {
            await client.indices.refresh({
              index: typeof refreshOnCompletion === "string" ? refreshOnCompletion : "_all"
            }, reqOptions);
          }
          stats.time = Date.now() - startTime;
          stats.total = stats.successful + stats.failed;
          return stats;
          async function onFlushTimeout() {
            if (chunkBytes === 0)
              return;
            stats.bytes += chunkBytes;
            const bulkBodyCopy = bulkBody.slice();
            bulkBody.length = 0;
            chunkBytes = 0;
            try {
              const send = await semaphore();
              send(bulkBodyCopy);
            } catch (err) {
              helper.abort();
            }
          }
        }
        function buildSemaphore() {
          let resolveSemaphore = null;
          let resolveFinish = null;
          let rejectFinish = null;
          let error = null;
          let running = 0;
          return { semaphore, finish };
          function finish() {
            return new Promise((resolve, reject) => {
              if (running === 0) {
                if (error !== null) {
                  reject(error);
                } else {
                  resolve();
                }
              } else {
                resolveFinish = resolve;
                rejectFinish = reject;
              }
            });
          }
          function semaphore() {
            if (running < concurrency) {
              running += 1;
              return pImmediate(send);
            } else {
              return new Promise((resolve, reject) => {
                resolveSemaphore = resolve;
              });
            }
          }
          function send(bulkBody) {
            if (running > concurrency) {
              throw new Error("Max concurrency reached");
            }
            bulkOperation(bulkBody, (err) => {
              running -= 1;
              if (err != null) {
                shouldAbort = true;
                error = err;
              }
              if (resolveSemaphore !== null) {
                running += 1;
                resolveSemaphore(send);
                resolveSemaphore = null;
              } else if (resolveFinish != null && rejectFinish != null && running === 0) {
                if (error != null) {
                  rejectFinish(error);
                } else {
                  resolveFinish();
                }
              }
            });
          }
        }
        function bulkOperation(bulkBody, callback) {
          let retryCount = retries;
          let isRetrying = false;
          tryBulk(bulkBody, retryDocuments);
          function retryDocuments(err, bulkBody2) {
            if (err != null)
              return callback(err);
            if (shouldAbort)
              return callback();
            if (bulkBody2.length > 0) {
              if (retryCount > 0) {
                isRetrying = true;
                retryCount -= 1;
                stats.retry += bulkBody2.length;
                setTimeout(tryBulk, wait, bulkBody2, retryDocuments);
                return;
              }
              for (let i = 0, len = bulkBody2.length; i < len; i = i + 2) {
                const operation = Object.keys(serializer.deserialize(bulkBody2[i]))[0];
                onDrop({
                  status: 429,
                  error: null,
                  operation: serializer.deserialize(bulkBody2[i]),
                  // @ts-expect-error
                  document: operation !== "delete" ? serializer.deserialize(bulkBody2[i + 1]) : null,
                  retried: isRetrying
                });
                stats.failed += 1;
              }
            }
            callback();
          }
          function zipBulkResults(responseItems, bulkBody2) {
            const zipped = [];
            let indexSlice = 0;
            for (let i = 0, len = responseItems.length; i < len; i++) {
              const result = responseItems[i];
              const operation = Object.keys(result)[0];
              let zipResult;
              if (operation === "delete") {
                zipResult = {
                  result,
                  raw: { action: bulkBody2[indexSlice] }
                };
                indexSlice += 1;
              } else {
                const document2 = bulkBody2[indexSlice + 1];
                zipResult = {
                  result,
                  raw: { action: bulkBody2[indexSlice], document: document2 },
                  // this is a function so that deserialization is only done when needed
                  // to avoid a performance hit
                  document: () => serializer.deserialize(document2)
                };
                indexSlice += 2;
              }
              zipped.push(zipResult);
            }
            return zipped;
          }
          function tryBulk(bulkBody2, callback2) {
            if (shouldAbort)
              return callback2(null, []);
            client.bulk(Object.assign({}, bulkOptions, { operations: bulkBody2 }), reqOptions).then((response) => {
              var _d2, _e2, _f;
              const result = response.body;
              const results = zipBulkResults(result.items, bulkBody2);
              if (!result.errors) {
                stats.successful += result.items.length;
                for (const item of results) {
                  const { result: result2, document: document2 = noop } = item;
                  if (((_d2 = result2.update) === null || _d2 === void 0 ? void 0 : _d2.result) === "noop") {
                    stats.noop++;
                  }
                  if (onSuccess != null)
                    onSuccess({ result: result2, document: document2() });
                }
                return callback2(null, []);
              }
              const retry = [];
              for (const item of results) {
                const { result: result2, raw, document: document2 = noop } = item;
                const operation = Object.keys(result2)[0];
                const responseItem = result2[operation];
                (0, node_assert_1.default)(responseItem !== void 0, "The responseItem is undefined, please file a bug report");
                if (responseItem.status >= 400) {
                  if (responseItem.status === 429) {
                    retry.push(raw.action);
                    if (operation !== "delete") {
                      retry.push((_e2 = raw.document) !== null && _e2 !== void 0 ? _e2 : "");
                    }
                  } else {
                    onDrop({
                      status: responseItem.status,
                      error: (_f = responseItem.error) !== null && _f !== void 0 ? _f : null,
                      operation: serializer.deserialize(raw.action),
                      // @ts-expect-error
                      document: document2(),
                      retried: isRetrying
                    });
                    stats.failed += 1;
                  }
                } else {
                  stats.successful += 1;
                  if (onSuccess != null)
                    onSuccess({ result: result2, document: document2() });
                }
              }
              callback2(null, retry);
            }).catch((err) => {
              callback2(err, []);
            });
          }
        }
      }
      /**
       * Creates an ES|QL helper instance, to help transform the data returned by an ES|QL query into easy-to-use formats.
       * @param {object} params - Request parameters sent to esql.query()
       * @returns {object} EsqlHelper instance
       */
      esql(params, reqOptions = {}) {
        const client = this[kClient];
        function toRecords(response) {
          const { columns, values } = response;
          return values.map((row) => {
            const doc = {};
            row.forEach((cell, index) => {
              const { name } = columns[index];
              doc[name] = cell;
            });
            return doc;
          });
        }
        const metaHeader = this[kMetaHeader];
        const helper = {
          /**
           * Pivots ES|QL query results into an array of row objects, rather than the default format where each row is an array of values.
           */
          async toRecords() {
            var _d;
            if (metaHeader !== null) {
              reqOptions.headers = (_d = reqOptions.headers) !== null && _d !== void 0 ? _d : {};
              reqOptions.headers["x-elastic-client-meta"] = `${metaHeader},h=qo`;
            }
            params.format = "json";
            params.columnar = false;
            const response = await client.esql.query(params, reqOptions);
            const records = toRecords(response);
            const { columns } = response;
            return { records, columns };
          },
          async toArrowTable() {
            var _d;
            if (metaHeader !== null) {
              reqOptions.headers = (_d = reqOptions.headers) !== null && _d !== void 0 ? _d : {};
              reqOptions.headers["x-elastic-client-meta"] = `${metaHeader},h=qa`;
            }
            params.format = "arrow";
            const response = await client.esql.query(params, reqOptions);
            return (0, Arrow_node_1.tableFromIPC)(response);
          },
          async toArrowReader() {
            var _d;
            if (metaHeader !== null) {
              reqOptions.headers = (_d = reqOptions.headers) !== null && _d !== void 0 ? _d : {};
              reqOptions.headers["x-elastic-client-meta"] = `${metaHeader},h=qa`;
              reqOptions.asStream = true;
            }
            params.format = "arrow";
            const response = await client.esql.query(params, reqOptions);
            return await Arrow_node_1.AsyncRecordBatchStreamReader.from(node_stream_1.Readable.from(response));
          }
        };
        return helper;
      }
    };
    _a = kClient, _b = kMetaHeader, _c = kMaxRetries;
    exports2.default = Helpers;
    function addDocumentsGetter(result) {
      Object.defineProperty(result, "documents", {
        get() {
          var _d;
          if (((_d = this.body.hits) === null || _d === void 0 ? void 0 : _d.hits) != null) {
            return this.body.hits.hits.map((d) => d._source);
          }
          return [];
        }
      });
    }
    function appendFilterPath(filter, params, force) {
      if (params.filter_path !== void 0) {
        params.filter_path += "," + filter;
      } else if (force) {
        params.filter_path = filter;
      }
    }
    function isReadableStream(obj) {
      return obj != null && typeof obj.pipe === "function";
    }
    function isAsyncIterator(obj) {
      return (obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]) != null;
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/async_search.js
var require_async_search = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/async_search.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var AsyncSearch = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "async_search.delete": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "async_search.get": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "keep_alive",
              "typed_keys",
              "wait_for_completion_timeout"
            ]
          },
          "async_search.status": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "keep_alive"
            ]
          },
          "async_search.submit": {
            path: [
              "index"
            ],
            body: [
              "aggregations",
              "aggs",
              "collapse",
              "explain",
              "ext",
              "from",
              "highlight",
              "track_total_hits",
              "indices_boost",
              "docvalue_fields",
              "knn",
              "min_score",
              "post_filter",
              "profile",
              "query",
              "rescore",
              "script_fields",
              "search_after",
              "size",
              "slice",
              "sort",
              "_source",
              "fields",
              "suggest",
              "terminate_after",
              "timeout",
              "track_scores",
              "version",
              "seq_no_primary_term",
              "stored_fields",
              "pit",
              "runtime_mappings",
              "stats"
            ],
            query: [
              "wait_for_completion_timeout",
              "keep_alive",
              "keep_on_completion",
              "allow_no_indices",
              "allow_partial_search_results",
              "analyzer",
              "analyze_wildcard",
              "batched_reduce_size",
              "ccs_minimize_roundtrips",
              "default_operator",
              "df",
              "docvalue_fields",
              "expand_wildcards",
              "explain",
              "ignore_throttled",
              "ignore_unavailable",
              "lenient",
              "max_concurrent_shard_requests",
              "preference",
              "request_cache",
              "routing",
              "search_type",
              "stats",
              "stored_fields",
              "suggest_field",
              "suggest_mode",
              "suggest_size",
              "suggest_text",
              "terminate_after",
              "timeout",
              "track_total_hits",
              "track_scores",
              "typed_keys",
              "rest_total_hits_as_int",
              "version",
              "_source",
              "_source_excludes",
              "_source_includes",
              "seq_no_primary_term",
              "q",
              "size",
              "from",
              "sort"
            ]
          }
        };
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["async_search.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "async_search.delete",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["async_search.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "async_search.get",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async status(params, options) {
        const { path: acceptedPath } = this.acceptedParams["async_search.status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_async_search/status/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "async_search.status",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async submit(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["async_search.submit"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            if (key === "sort" && typeof params[key] === "string" && params[key].includes(":")) {
              querystring[key] = params[key];
            } else {
              body[key] = params[key];
            }
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "POST";
          path = `/${encodeURIComponent(params.index.toString())}/_async_search`;
        } else {
          method = "POST";
          path = "/_async_search";
        }
        const meta = {
          name: "async_search.submit",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = AsyncSearch;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js
var require_autoscaling = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Autoscaling = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "autoscaling.delete_autoscaling_policy": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "autoscaling.get_autoscaling_capacity": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "autoscaling.get_autoscaling_policy": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "autoscaling.put_autoscaling_policy": {
            path: [
              "name"
            ],
            body: [
              "policy"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          }
        };
      }
      async deleteAutoscalingPolicy(params, options) {
        const { path: acceptedPath } = this.acceptedParams["autoscaling.delete_autoscaling_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "autoscaling.delete_autoscaling_policy",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getAutoscalingCapacity(params, options) {
        const { path: acceptedPath } = this.acceptedParams["autoscaling.get_autoscaling_capacity"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_autoscaling/capacity";
        const meta = {
          name: "autoscaling.get_autoscaling_capacity"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getAutoscalingPolicy(params, options) {
        const { path: acceptedPath } = this.acceptedParams["autoscaling.get_autoscaling_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "autoscaling.get_autoscaling_policy",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAutoscalingPolicy(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["autoscaling.put_autoscaling_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "autoscaling.put_autoscaling_policy",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Autoscaling;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/bulk.js
var require_bulk = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/bulk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = BulkApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      bulk: {
        path: [
          "index"
        ],
        body: [
          "operations"
        ],
        query: [
          "include_source_on_error",
          "list_executed_pipelines",
          "pipeline",
          "refresh",
          "routing",
          "_source",
          "_source_excludes",
          "_source_includes",
          "timeout",
          "wait_for_active_shards",
          "require_alias",
          "require_data_stream"
        ]
      }
    };
    async function BulkApi(params, options) {
      var _a;
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.bulk;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = "POST";
        path = `/${encodeURIComponent(params.index.toString())}/_bulk`;
      } else {
        method = "POST";
        path = "/_bulk";
      }
      const meta = {
        name: "bulk",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/capabilities.js
var require_capabilities = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/capabilities.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = CapabilitiesApi;
    var acceptedParams = {
      capabilities: {
        path: [],
        body: [],
        query: []
      }
    };
    async function CapabilitiesApi(params, options) {
      const { path: acceptedPath } = acceptedParams.capabilities;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "GET";
      const path = "/_capabilities";
      const meta = {
        name: "capabilities"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/cat.js
var require_cat = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/cat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Cat = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "cat.aliases": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "h",
              "s",
              "expand_wildcards",
              "master_timeout"
            ]
          },
          "cat.allocation": {
            path: [
              "node_id"
            ],
            body: [],
            query: [
              "bytes",
              "h",
              "s",
              "local",
              "master_timeout"
            ]
          },
          "cat.component_templates": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "h",
              "s",
              "local",
              "master_timeout"
            ]
          },
          "cat.count": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "h",
              "s"
            ]
          },
          "cat.fielddata": {
            path: [
              "fields"
            ],
            body: [],
            query: [
              "bytes",
              "fields",
              "h",
              "s"
            ]
          },
          "cat.health": {
            path: [],
            body: [],
            query: [
              "time",
              "ts",
              "h",
              "s"
            ]
          },
          "cat.help": {
            path: [],
            body: [],
            query: []
          },
          "cat.indices": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "bytes",
              "expand_wildcards",
              "health",
              "include_unloaded_segments",
              "pri",
              "time",
              "master_timeout",
              "h",
              "s"
            ]
          },
          "cat.master": {
            path: [],
            body: [],
            query: [
              "h",
              "s",
              "local",
              "master_timeout"
            ]
          },
          "cat.ml_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "bytes",
              "h",
              "s",
              "time"
            ]
          },
          "cat.ml_datafeeds": {
            path: [
              "datafeed_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "h",
              "s",
              "time"
            ]
          },
          "cat.ml_jobs": {
            path: [
              "job_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "bytes",
              "h",
              "s",
              "time"
            ]
          },
          "cat.ml_trained_models": {
            path: [
              "model_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "bytes",
              "h",
              "s",
              "from",
              "size",
              "time"
            ]
          },
          "cat.nodeattrs": {
            path: [],
            body: [],
            query: [
              "h",
              "s",
              "local",
              "master_timeout"
            ]
          },
          "cat.nodes": {
            path: [],
            body: [],
            query: [
              "bytes",
              "full_id",
              "include_unloaded_segments",
              "h",
              "s",
              "master_timeout",
              "time"
            ]
          },
          "cat.pending_tasks": {
            path: [],
            body: [],
            query: [
              "h",
              "s",
              "local",
              "master_timeout",
              "time"
            ]
          },
          "cat.plugins": {
            path: [],
            body: [],
            query: [
              "h",
              "s",
              "include_bootstrap",
              "local",
              "master_timeout"
            ]
          },
          "cat.recovery": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "active_only",
              "bytes",
              "detailed",
              "index",
              "h",
              "s",
              "time"
            ]
          },
          "cat.repositories": {
            path: [],
            body: [],
            query: [
              "h",
              "s",
              "local",
              "master_timeout"
            ]
          },
          "cat.segments": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "bytes",
              "h",
              "s",
              "local",
              "master_timeout"
            ]
          },
          "cat.shards": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "bytes",
              "h",
              "s",
              "master_timeout",
              "time"
            ]
          },
          "cat.snapshots": {
            path: [
              "repository"
            ],
            body: [],
            query: [
              "ignore_unavailable",
              "h",
              "s",
              "master_timeout",
              "time"
            ]
          },
          "cat.tasks": {
            path: [],
            body: [],
            query: [
              "actions",
              "detailed",
              "nodes",
              "parent_task_id",
              "h",
              "s",
              "time",
              "timeout",
              "wait_for_completion"
            ]
          },
          "cat.templates": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "h",
              "s",
              "local",
              "master_timeout"
            ]
          },
          "cat.thread_pool": {
            path: [
              "thread_pool_patterns"
            ],
            body: [],
            query: [
              "h",
              "s",
              "time",
              "local",
              "master_timeout"
            ]
          },
          "cat.transforms": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "from",
              "h",
              "s",
              "time",
              "size"
            ]
          }
        };
      }
      async aliases(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.aliases"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_cat/aliases/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/aliases";
        }
        const meta = {
          name: "cat.aliases",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async allocation(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.allocation"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null) {
          method = "GET";
          path = `/_cat/allocation/${encodeURIComponent(params.node_id.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/allocation";
        }
        const meta = {
          name: "cat.allocation",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async componentTemplates(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.component_templates"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_cat/component_templates/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/component_templates";
        }
        const meta = {
          name: "cat.component_templates",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async count(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.count"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/_cat/count/${encodeURIComponent(params.index.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/count";
        }
        const meta = {
          name: "cat.count",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async fielddata(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.fielddata"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.fields != null) {
          method = "GET";
          path = `/_cat/fielddata/${encodeURIComponent(params.fields.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/fielddata";
        }
        const meta = {
          name: "cat.fielddata",
          pathParts: {
            fields: params.fields
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async health(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.health"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/health";
        const meta = {
          name: "cat.health"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async help(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.help"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat";
        const meta = {
          name: "cat.help"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async indices(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.indices"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/_cat/indices/${encodeURIComponent(params.index.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/indices";
        }
        const meta = {
          name: "cat.indices",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async master(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.master"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/master";
        const meta = {
          name: "cat.master"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async mlDataFrameAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.ml_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_cat/ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/ml/data_frame/analytics";
        }
        const meta = {
          name: "cat.ml_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async mlDatafeeds(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.ml_datafeeds"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.datafeed_id != null) {
          method = "GET";
          path = `/_cat/ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/ml/datafeeds";
        }
        const meta = {
          name: "cat.ml_datafeeds",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async mlJobs(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.ml_jobs"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null) {
          method = "GET";
          path = `/_cat/ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/ml/anomaly_detectors";
        }
        const meta = {
          name: "cat.ml_jobs",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async mlTrainedModels(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.ml_trained_models"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.model_id != null) {
          method = "GET";
          path = `/_cat/ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/ml/trained_models";
        }
        const meta = {
          name: "cat.ml_trained_models",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async nodeattrs(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.nodeattrs"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/nodeattrs";
        const meta = {
          name: "cat.nodeattrs"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async nodes(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.nodes"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/nodes";
        const meta = {
          name: "cat.nodes"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async pendingTasks(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.pending_tasks"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/pending_tasks";
        const meta = {
          name: "cat.pending_tasks"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async plugins(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.plugins"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/plugins";
        const meta = {
          name: "cat.plugins"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async recovery(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.recovery"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/_cat/recovery/${encodeURIComponent(params.index.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/recovery";
        }
        const meta = {
          name: "cat.recovery",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async repositories(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.repositories"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/repositories";
        const meta = {
          name: "cat.repositories"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async segments(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.segments"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/_cat/segments/${encodeURIComponent(params.index.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/segments";
        }
        const meta = {
          name: "cat.segments",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async shards(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.shards"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/_cat/shards/${encodeURIComponent(params.index.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/shards";
        }
        const meta = {
          name: "cat.shards",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async snapshots(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.snapshots"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.repository != null) {
          method = "GET";
          path = `/_cat/snapshots/${encodeURIComponent(params.repository.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/snapshots";
        }
        const meta = {
          name: "cat.snapshots",
          pathParts: {
            repository: params.repository
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async tasks(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.tasks"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cat/tasks";
        const meta = {
          name: "cat.tasks"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async templates(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.templates"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_cat/templates/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/templates";
        }
        const meta = {
          name: "cat.templates",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async threadPool(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.thread_pool"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.thread_pool_patterns != null) {
          method = "GET";
          path = `/_cat/thread_pool/${encodeURIComponent(params.thread_pool_patterns.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/thread_pool";
        }
        const meta = {
          name: "cat.thread_pool",
          pathParts: {
            thread_pool_patterns: params.thread_pool_patterns
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async transforms(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cat.transforms"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.transform_id != null) {
          method = "GET";
          path = `/_cat/transforms/${encodeURIComponent(params.transform_id.toString())}`;
        } else {
          method = "GET";
          path = "/_cat/transforms";
        }
        const meta = {
          name: "cat.transforms",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Cat;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/ccr.js
var require_ccr = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/ccr.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Ccr = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "ccr.delete_auto_follow_pattern": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "ccr.follow": {
            path: [
              "index"
            ],
            body: [
              "data_stream_name",
              "leader_index",
              "max_outstanding_read_requests",
              "max_outstanding_write_requests",
              "max_read_request_operation_count",
              "max_read_request_size",
              "max_retry_delay",
              "max_write_buffer_count",
              "max_write_buffer_size",
              "max_write_request_operation_count",
              "max_write_request_size",
              "read_poll_timeout",
              "remote_cluster",
              "settings"
            ],
            query: [
              "master_timeout",
              "wait_for_active_shards"
            ]
          },
          "ccr.follow_info": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "ccr.follow_stats": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "timeout"
            ]
          },
          "ccr.forget_follower": {
            path: [
              "index"
            ],
            body: [
              "follower_cluster",
              "follower_index",
              "follower_index_uuid",
              "leader_remote_cluster"
            ],
            query: [
              "timeout"
            ]
          },
          "ccr.get_auto_follow_pattern": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "ccr.pause_auto_follow_pattern": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "ccr.pause_follow": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "ccr.put_auto_follow_pattern": {
            path: [
              "name"
            ],
            body: [
              "remote_cluster",
              "follow_index_pattern",
              "leader_index_patterns",
              "leader_index_exclusion_patterns",
              "max_outstanding_read_requests",
              "settings",
              "max_outstanding_write_requests",
              "read_poll_timeout",
              "max_read_request_operation_count",
              "max_read_request_size",
              "max_retry_delay",
              "max_write_buffer_count",
              "max_write_buffer_size",
              "max_write_request_operation_count",
              "max_write_request_size"
            ],
            query: [
              "master_timeout"
            ]
          },
          "ccr.resume_auto_follow_pattern": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "ccr.resume_follow": {
            path: [
              "index"
            ],
            body: [
              "max_outstanding_read_requests",
              "max_outstanding_write_requests",
              "max_read_request_operation_count",
              "max_read_request_size",
              "max_retry_delay",
              "max_write_buffer_count",
              "max_write_buffer_size",
              "max_write_request_operation_count",
              "max_write_request_size",
              "read_poll_timeout"
            ],
            query: [
              "master_timeout"
            ]
          },
          "ccr.stats": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ccr.unfollow": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          }
        };
      }
      async deleteAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.delete_auto_follow_pattern"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "ccr.delete_auto_follow_pattern",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async follow(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ccr.follow"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/follow`;
        const meta = {
          name: "ccr.follow",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async followInfo(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.follow_info"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/info`;
        const meta = {
          name: "ccr.follow_info",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async followStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.follow_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/stats`;
        const meta = {
          name: "ccr.follow_stats",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async forgetFollower(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ccr.forget_follower"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/forget_follower`;
        const meta = {
          name: "ccr.forget_follower",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.get_auto_follow_pattern"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_ccr/auto_follow";
        }
        const meta = {
          name: "ccr.get_auto_follow_pattern",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async pauseAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.pause_auto_follow_pattern"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/pause`;
        const meta = {
          name: "ccr.pause_auto_follow_pattern",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async pauseFollow(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.pause_follow"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/pause_follow`;
        const meta = {
          name: "ccr.pause_follow",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAutoFollowPattern(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ccr.put_auto_follow_pattern"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "ccr.put_auto_follow_pattern",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async resumeAutoFollowPattern(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.resume_auto_follow_pattern"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/resume`;
        const meta = {
          name: "ccr.resume_auto_follow_pattern",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async resumeFollow(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ccr.resume_follow"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/resume_follow`;
        const meta = {
          name: "ccr.resume_follow",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_ccr/stats";
        const meta = {
          name: "ccr.stats"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async unfollow(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ccr.unfollow"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/unfollow`;
        const meta = {
          name: "ccr.unfollow",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Ccr;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js
var require_clear_scroll = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ClearScrollApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      clear_scroll: {
        path: [],
        body: [
          "scroll_id"
        ],
        query: []
      }
    };
    async function ClearScrollApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.clear_scroll;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "DELETE";
      const path = "/_search/scroll";
      const meta = {
        name: "clear_scroll",
        pathParts: {
          scroll_id: params.scroll_id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js
var require_close_point_in_time = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ClosePointInTimeApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      close_point_in_time: {
        path: [],
        body: [
          "id"
        ],
        query: []
      }
    };
    async function ClosePointInTimeApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.close_point_in_time;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "DELETE";
      const path = "/_pit";
      const meta = {
        name: "close_point_in_time"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/cluster.js
var require_cluster = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/cluster.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Cluster = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "cluster.allocation_explain": {
            path: [],
            body: [
              "current_node",
              "index",
              "primary",
              "shard"
            ],
            query: [
              "include_disk_info",
              "include_yes_decisions",
              "master_timeout"
            ]
          },
          "cluster.delete_component_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "cluster.delete_voting_config_exclusions": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "wait_for_removal"
            ]
          },
          "cluster.exists_component_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "local"
            ]
          },
          "cluster.get_component_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "flat_settings",
              "include_defaults",
              "local",
              "master_timeout"
            ]
          },
          "cluster.get_settings": {
            path: [],
            body: [],
            query: [
              "flat_settings",
              "include_defaults",
              "master_timeout",
              "timeout"
            ]
          },
          "cluster.health": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "expand_wildcards",
              "level",
              "local",
              "master_timeout",
              "timeout",
              "wait_for_active_shards",
              "wait_for_events",
              "wait_for_nodes",
              "wait_for_no_initializing_shards",
              "wait_for_no_relocating_shards",
              "wait_for_status"
            ]
          },
          "cluster.info": {
            path: [
              "target"
            ],
            body: [],
            query: []
          },
          "cluster.pending_tasks": {
            path: [],
            body: [],
            query: [
              "local",
              "master_timeout"
            ]
          },
          "cluster.post_voting_config_exclusions": {
            path: [],
            body: [],
            query: [
              "node_names",
              "node_ids",
              "master_timeout",
              "timeout"
            ]
          },
          "cluster.put_component_template": {
            path: [
              "name"
            ],
            body: [
              "template",
              "version",
              "_meta",
              "deprecated"
            ],
            query: [
              "create",
              "master_timeout"
            ]
          },
          "cluster.put_settings": {
            path: [],
            body: [
              "persistent",
              "transient"
            ],
            query: [
              "flat_settings",
              "master_timeout",
              "timeout"
            ]
          },
          "cluster.remote_info": {
            path: [],
            body: [],
            query: []
          },
          "cluster.reroute": {
            path: [],
            body: [
              "commands"
            ],
            query: [
              "dry_run",
              "explain",
              "metric",
              "retry_failed",
              "master_timeout",
              "timeout"
            ]
          },
          "cluster.state": {
            path: [
              "metric",
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "flat_settings",
              "ignore_unavailable",
              "local",
              "master_timeout",
              "wait_for_metadata_version",
              "wait_for_timeout"
            ]
          },
          "cluster.stats": {
            path: [
              "node_id"
            ],
            body: [],
            query: [
              "include_remotes",
              "timeout"
            ]
          }
        };
      }
      async allocationExplain(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["cluster.allocation_explain"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_cluster/allocation/explain";
        const meta = {
          name: "cluster.allocation_explain"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteComponentTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.delete_component_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "cluster.delete_component_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteVotingConfigExclusions(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.delete_voting_config_exclusions"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = "/_cluster/voting_config_exclusions";
        const meta = {
          name: "cluster.delete_voting_config_exclusions"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async existsComponentTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.exists_component_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "HEAD";
        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "cluster.exists_component_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getComponentTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.get_component_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_component_template";
        }
        const meta = {
          name: "cluster.get_component_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSettings(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.get_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cluster/settings";
        const meta = {
          name: "cluster.get_settings"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async health(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.health"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/_cluster/health/${encodeURIComponent(params.index.toString())}`;
        } else {
          method = "GET";
          path = "/_cluster/health";
        }
        const meta = {
          name: "cluster.health",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async info(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.info"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_info/${encodeURIComponent(params.target.toString())}`;
        const meta = {
          name: "cluster.info",
          pathParts: {
            target: params.target
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async pendingTasks(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.pending_tasks"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_cluster/pending_tasks";
        const meta = {
          name: "cluster.pending_tasks"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async postVotingConfigExclusions(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.post_voting_config_exclusions"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_cluster/voting_config_exclusions";
        const meta = {
          name: "cluster.post_voting_config_exclusions"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putComponentTemplate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["cluster.put_component_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "cluster.put_component_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putSettings(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["cluster.put_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = "/_cluster/settings";
        const meta = {
          name: "cluster.put_settings"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async remoteInfo(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.remote_info"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_remote/info";
        const meta = {
          name: "cluster.remote_info"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async reroute(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["cluster.reroute"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_cluster/reroute";
        const meta = {
          name: "cluster.reroute"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async state(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.state"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.metric != null && params.index != null) {
          method = "GET";
          path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index.toString())}`;
        } else if (params.metric != null) {
          method = "GET";
          path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}`;
        } else {
          method = "GET";
          path = "/_cluster/state";
        }
        const meta = {
          name: "cluster.state",
          pathParts: {
            metric: params.metric,
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["cluster.stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null) {
          method = "GET";
          path = `/_cluster/stats/nodes/${encodeURIComponent(params.node_id.toString())}`;
        } else {
          method = "GET";
          path = "/_cluster/stats";
        }
        const meta = {
          name: "cluster.stats",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Cluster;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/connector.js
var require_connector = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/connector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Connector = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "connector.check_in": {
            path: [
              "connector_id"
            ],
            body: [],
            query: []
          },
          "connector.delete": {
            path: [
              "connector_id"
            ],
            body: [],
            query: [
              "delete_sync_jobs",
              "hard"
            ]
          },
          "connector.get": {
            path: [
              "connector_id"
            ],
            body: [],
            query: [
              "include_deleted"
            ]
          },
          "connector.last_sync": {
            path: [
              "connector_id"
            ],
            body: [
              "last_access_control_sync_error",
              "last_access_control_sync_scheduled_at",
              "last_access_control_sync_status",
              "last_deleted_document_count",
              "last_incremental_sync_scheduled_at",
              "last_indexed_document_count",
              "last_seen",
              "last_sync_error",
              "last_sync_scheduled_at",
              "last_sync_status",
              "last_synced",
              "sync_cursor"
            ],
            query: []
          },
          "connector.list": {
            path: [],
            body: [],
            query: [
              "from",
              "size",
              "index_name",
              "connector_name",
              "service_type",
              "include_deleted",
              "query"
            ]
          },
          "connector.post": {
            path: [],
            body: [
              "description",
              "index_name",
              "is_native",
              "language",
              "name",
              "service_type"
            ],
            query: []
          },
          "connector.put": {
            path: [
              "connector_id"
            ],
            body: [
              "description",
              "index_name",
              "is_native",
              "language",
              "name",
              "service_type"
            ],
            query: []
          },
          "connector.secret_delete": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "connector.secret_get": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "connector.secret_post": {
            path: [],
            body: [],
            query: []
          },
          "connector.secret_put": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "connector.sync_job_cancel": {
            path: [
              "connector_sync_job_id"
            ],
            body: [],
            query: []
          },
          "connector.sync_job_check_in": {
            path: [
              "connector_sync_job_id"
            ],
            body: [],
            query: []
          },
          "connector.sync_job_claim": {
            path: [
              "connector_sync_job_id"
            ],
            body: [
              "sync_cursor",
              "worker_hostname"
            ],
            query: []
          },
          "connector.sync_job_delete": {
            path: [
              "connector_sync_job_id"
            ],
            body: [],
            query: []
          },
          "connector.sync_job_error": {
            path: [
              "connector_sync_job_id"
            ],
            body: [
              "error"
            ],
            query: []
          },
          "connector.sync_job_get": {
            path: [
              "connector_sync_job_id"
            ],
            body: [],
            query: []
          },
          "connector.sync_job_list": {
            path: [],
            body: [],
            query: [
              "from",
              "size",
              "status",
              "connector_id",
              "job_type"
            ]
          },
          "connector.sync_job_post": {
            path: [],
            body: [
              "id",
              "job_type",
              "trigger_method"
            ],
            query: []
          },
          "connector.sync_job_update_stats": {
            path: [
              "connector_sync_job_id"
            ],
            body: [
              "deleted_document_count",
              "indexed_document_count",
              "indexed_document_volume",
              "last_seen",
              "metadata",
              "total_document_count"
            ],
            query: []
          },
          "connector.update_active_filtering": {
            path: [
              "connector_id"
            ],
            body: [],
            query: []
          },
          "connector.update_api_key_id": {
            path: [
              "connector_id"
            ],
            body: [
              "api_key_id",
              "api_key_secret_id"
            ],
            query: []
          },
          "connector.update_configuration": {
            path: [
              "connector_id"
            ],
            body: [
              "configuration",
              "values"
            ],
            query: []
          },
          "connector.update_error": {
            path: [
              "connector_id"
            ],
            body: [
              "error"
            ],
            query: []
          },
          "connector.update_features": {
            path: [
              "connector_id"
            ],
            body: [
              "features"
            ],
            query: []
          },
          "connector.update_filtering": {
            path: [
              "connector_id"
            ],
            body: [
              "filtering",
              "rules",
              "advanced_snippet"
            ],
            query: []
          },
          "connector.update_filtering_validation": {
            path: [
              "connector_id"
            ],
            body: [
              "validation"
            ],
            query: []
          },
          "connector.update_index_name": {
            path: [
              "connector_id"
            ],
            body: [
              "index_name"
            ],
            query: []
          },
          "connector.update_name": {
            path: [
              "connector_id"
            ],
            body: [
              "name",
              "description"
            ],
            query: []
          },
          "connector.update_native": {
            path: [
              "connector_id"
            ],
            body: [
              "is_native"
            ],
            query: []
          },
          "connector.update_pipeline": {
            path: [
              "connector_id"
            ],
            body: [
              "pipeline"
            ],
            query: []
          },
          "connector.update_scheduling": {
            path: [
              "connector_id"
            ],
            body: [
              "scheduling"
            ],
            query: []
          },
          "connector.update_service_type": {
            path: [
              "connector_id"
            ],
            body: [
              "service_type"
            ],
            query: []
          },
          "connector.update_status": {
            path: [
              "connector_id"
            ],
            body: [
              "status"
            ],
            query: []
          }
        };
      }
      async checkIn(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.check_in"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_check_in`;
        const meta = {
          name: "connector.check_in",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;
        const meta = {
          name: "connector.delete",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;
        const meta = {
          name: "connector.get",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async lastSync(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.last_sync"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_last_sync`;
        const meta = {
          name: "connector.last_sync",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async list(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.list"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_connector";
        const meta = {
          name: "connector.list"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async post(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.post"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_connector";
        const meta = {
          name: "connector.post"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async put(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.put"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.connector_id != null) {
          method = "PUT";
          path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;
        } else {
          method = "PUT";
          path = "/_connector";
        }
        const meta = {
          name: "connector.put",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async secretDelete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.secret_delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "connector.secret_delete",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async secretGet(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.secret_get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "connector.secret_get",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async secretPost(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.secret_post"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_connector/_secret";
        const meta = {
          name: "connector.secret_post"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async secretPut(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.secret_put"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "connector.secret_put",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobCancel(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.sync_job_cancel"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_cancel`;
        const meta = {
          name: "connector.sync_job_cancel",
          pathParts: {
            connector_sync_job_id: params.connector_sync_job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobCheckIn(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.sync_job_check_in"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_check_in`;
        const meta = {
          name: "connector.sync_job_check_in",
          pathParts: {
            connector_sync_job_id: params.connector_sync_job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobClaim(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.sync_job_claim"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_claim`;
        const meta = {
          name: "connector.sync_job_claim",
          pathParts: {
            connector_sync_job_id: params.connector_sync_job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobDelete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.sync_job_delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}`;
        const meta = {
          name: "connector.sync_job_delete",
          pathParts: {
            connector_sync_job_id: params.connector_sync_job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobError(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.sync_job_error"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_error`;
        const meta = {
          name: "connector.sync_job_error",
          pathParts: {
            connector_sync_job_id: params.connector_sync_job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobGet(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.sync_job_get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}`;
        const meta = {
          name: "connector.sync_job_get",
          pathParts: {
            connector_sync_job_id: params.connector_sync_job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobList(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.sync_job_list"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_connector/_sync_job";
        const meta = {
          name: "connector.sync_job_list"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobPost(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.sync_job_post"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_connector/_sync_job";
        const meta = {
          name: "connector.sync_job_post"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async syncJobUpdateStats(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.sync_job_update_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_stats`;
        const meta = {
          name: "connector.sync_job_update_stats",
          pathParts: {
            connector_sync_job_id: params.connector_sync_job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateActiveFiltering(params, options) {
        const { path: acceptedPath } = this.acceptedParams["connector.update_active_filtering"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering/_activate`;
        const meta = {
          name: "connector.update_active_filtering",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateApiKeyId(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_api_key_id"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_api_key_id`;
        const meta = {
          name: "connector.update_api_key_id",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateConfiguration(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_configuration"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_configuration`;
        const meta = {
          name: "connector.update_configuration",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateError(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_error"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_error`;
        const meta = {
          name: "connector.update_error",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateFeatures(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_features"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_features`;
        const meta = {
          name: "connector.update_features",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateFiltering(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_filtering"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering`;
        const meta = {
          name: "connector.update_filtering",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateFilteringValidation(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_filtering_validation"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering/_validation`;
        const meta = {
          name: "connector.update_filtering_validation",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateIndexName(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_index_name"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_index_name`;
        const meta = {
          name: "connector.update_index_name",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateName(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_name"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_name`;
        const meta = {
          name: "connector.update_name",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateNative(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_native"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_native`;
        const meta = {
          name: "connector.update_native",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updatePipeline(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_pipeline"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_pipeline`;
        const meta = {
          name: "connector.update_pipeline",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateScheduling(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_scheduling"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_scheduling`;
        const meta = {
          name: "connector.update_scheduling",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateServiceType(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_service_type"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_service_type`;
        const meta = {
          name: "connector.update_service_type",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateStatus(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["connector.update_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_status`;
        const meta = {
          name: "connector.update_status",
          pathParts: {
            connector_id: params.connector_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Connector;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/count.js
var require_count = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = CountApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      count: {
        path: [
          "index"
        ],
        body: [
          "query"
        ],
        query: [
          "allow_no_indices",
          "analyzer",
          "analyze_wildcard",
          "default_operator",
          "df",
          "expand_wildcards",
          "ignore_throttled",
          "ignore_unavailable",
          "lenient",
          "min_score",
          "preference",
          "routing",
          "terminate_after",
          "q"
        ]
      }
    };
    async function CountApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.count;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_count`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_count";
      }
      const meta = {
        name: "count",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/create.js
var require_create = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/create.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = CreateApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      create: {
        path: [
          "id",
          "index"
        ],
        body: [
          "document"
        ],
        query: [
          "if_primary_term",
          "if_seq_no",
          "include_source_on_error",
          "op_type",
          "pipeline",
          "refresh",
          "require_alias",
          "require_data_stream",
          "routing",
          "timeout",
          "version",
          "version_type",
          "wait_for_active_shards"
        ]
      }
    };
    async function CreateApi(params, options) {
      var _a;
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.create;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "PUT";
      const path = `/${encodeURIComponent(params.index.toString())}/_create/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "create",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js
var require_dangling_indices = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DanglingIndices = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "dangling_indices.delete_dangling_index": {
            path: [
              "index_uuid"
            ],
            body: [],
            query: [
              "accept_data_loss",
              "master_timeout",
              "timeout"
            ]
          },
          "dangling_indices.import_dangling_index": {
            path: [
              "index_uuid"
            ],
            body: [],
            query: [
              "accept_data_loss",
              "master_timeout",
              "timeout"
            ]
          },
          "dangling_indices.list_dangling_indices": {
            path: [],
            body: [],
            query: []
          }
        };
      }
      async deleteDanglingIndex(params, options) {
        const { path: acceptedPath } = this.acceptedParams["dangling_indices.delete_dangling_index"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;
        const meta = {
          name: "dangling_indices.delete_dangling_index",
          pathParts: {
            index_uuid: params.index_uuid
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async importDanglingIndex(params, options) {
        const { path: acceptedPath } = this.acceptedParams["dangling_indices.import_dangling_index"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;
        const meta = {
          name: "dangling_indices.import_dangling_index",
          pathParts: {
            index_uuid: params.index_uuid
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async listDanglingIndices(params, options) {
        const { path: acceptedPath } = this.acceptedParams["dangling_indices.list_dangling_indices"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_dangling";
        const meta = {
          name: "dangling_indices.list_dangling_indices"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = DanglingIndices;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/delete.js
var require_delete = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/delete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = DeleteApi;
    var acceptedParams = {
      delete: {
        path: [
          "id",
          "index"
        ],
        body: [],
        query: [
          "if_primary_term",
          "if_seq_no",
          "refresh",
          "routing",
          "timeout",
          "version",
          "version_type",
          "wait_for_active_shards"
        ]
      }
    };
    async function DeleteApi(params, options) {
      const { path: acceptedPath } = acceptedParams.delete;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "DELETE";
      const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "delete",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js
var require_delete_by_query = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = DeleteByQueryApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      delete_by_query: {
        path: [
          "index"
        ],
        body: [
          "max_docs",
          "query",
          "slice"
        ],
        query: [
          "allow_no_indices",
          "analyzer",
          "analyze_wildcard",
          "conflicts",
          "default_operator",
          "df",
          "expand_wildcards",
          "from",
          "ignore_unavailable",
          "lenient",
          "max_docs",
          "preference",
          "refresh",
          "request_cache",
          "requests_per_second",
          "routing",
          "q",
          "scroll",
          "scroll_size",
          "search_timeout",
          "search_type",
          "slices",
          "sort",
          "stats",
          "terminate_after",
          "timeout",
          "version",
          "wait_for_active_shards",
          "wait_for_completion"
        ]
      }
    };
    async function DeleteByQueryApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.delete_by_query;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "POST";
      const path = `/${encodeURIComponent(params.index.toString())}/_delete_by_query`;
      const meta = {
        name: "delete_by_query",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js
var require_delete_by_query_rethrottle = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = DeleteByQueryRethrottleApi;
    var acceptedParams = {
      delete_by_query_rethrottle: {
        path: [
          "task_id"
        ],
        body: [],
        query: [
          "requests_per_second"
        ]
      }
    };
    async function DeleteByQueryRethrottleApi(params, options) {
      const { path: acceptedPath } = acceptedParams.delete_by_query_rethrottle;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "POST";
      const path = `/_delete_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;
      const meta = {
        name: "delete_by_query_rethrottle",
        pathParts: {
          task_id: params.task_id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js
var require_delete_script = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = DeleteScriptApi;
    var acceptedParams = {
      delete_script: {
        path: [
          "id"
        ],
        body: [],
        query: [
          "master_timeout",
          "timeout"
        ]
      }
    };
    async function DeleteScriptApi(params, options) {
      const { path: acceptedPath } = acceptedParams.delete_script;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "DELETE";
      const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "delete_script",
        pathParts: {
          id: params.id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/enrich.js
var require_enrich = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/enrich.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Enrich = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "enrich.delete_policy": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "enrich.execute_policy": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "wait_for_completion"
            ]
          },
          "enrich.get_policy": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "enrich.put_policy": {
            path: [
              "name"
            ],
            body: [
              "geo_match",
              "match",
              "range"
            ],
            query: [
              "master_timeout"
            ]
          },
          "enrich.stats": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          }
        };
      }
      async deletePolicy(params, options) {
        const { path: acceptedPath } = this.acceptedParams["enrich.delete_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "enrich.delete_policy",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async executePolicy(params, options) {
        const { path: acceptedPath } = this.acceptedParams["enrich.execute_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}/_execute`;
        const meta = {
          name: "enrich.execute_policy",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getPolicy(params, options) {
        const { path: acceptedPath } = this.acceptedParams["enrich.get_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_enrich/policy";
        }
        const meta = {
          name: "enrich.get_policy",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putPolicy(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["enrich.put_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "enrich.put_policy",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["enrich.stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_enrich/_stats";
        const meta = {
          name: "enrich.stats"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Enrich;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/eql.js
var require_eql = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/eql.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Eql = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "eql.delete": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "eql.get": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "keep_alive",
              "wait_for_completion_timeout"
            ]
          },
          "eql.get_status": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "eql.search": {
            path: [
              "index"
            ],
            body: [
              "query",
              "case_sensitive",
              "event_category_field",
              "tiebreaker_field",
              "timestamp_field",
              "fetch_size",
              "filter",
              "keep_alive",
              "keep_on_completion",
              "wait_for_completion_timeout",
              "allow_partial_search_results",
              "allow_partial_sequence_results",
              "size",
              "fields",
              "result_position",
              "runtime_mappings",
              "max_samples_per_key"
            ],
            query: [
              "allow_no_indices",
              "allow_partial_search_results",
              "allow_partial_sequence_results",
              "expand_wildcards",
              "ignore_unavailable",
              "keep_alive",
              "keep_on_completion",
              "wait_for_completion_timeout"
            ]
          }
        };
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["eql.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "eql.delete",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["eql.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "eql.get",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["eql.get_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_eql/search/status/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "eql.get_status",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async search(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["eql.search"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_eql/search`;
        const meta = {
          name: "eql.search",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Eql;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/esql.js
var require_esql = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/esql.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Esql = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "esql.async_query": {
            path: [],
            body: [
              "columnar",
              "filter",
              "locale",
              "params",
              "profile",
              "query",
              "tables",
              "include_ccs_metadata",
              "wait_for_completion_timeout"
            ],
            query: [
              "delimiter",
              "drop_null_columns",
              "format",
              "keep_alive",
              "keep_on_completion",
              "wait_for_completion_timeout"
            ]
          },
          "esql.async_query_delete": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "esql.async_query_get": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "drop_null_columns",
              "keep_alive",
              "wait_for_completion_timeout"
            ]
          },
          "esql.async_query_stop": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "drop_null_columns"
            ]
          },
          "esql.query": {
            path: [],
            body: [
              "columnar",
              "filter",
              "locale",
              "params",
              "profile",
              "query",
              "tables",
              "include_ccs_metadata"
            ],
            query: [
              "format",
              "delimiter",
              "drop_null_columns"
            ]
          }
        };
      }
      async asyncQuery(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["esql.async_query"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_query/async";
        const meta = {
          name: "esql.async_query"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async asyncQueryDelete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["esql.async_query_delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_query/async/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "esql.async_query_delete",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async asyncQueryGet(params, options) {
        const { path: acceptedPath } = this.acceptedParams["esql.async_query_get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_query/async/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "esql.async_query_get",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async asyncQueryStop(params, options) {
        const { path: acceptedPath } = this.acceptedParams["esql.async_query_stop"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_query/async/${encodeURIComponent(params.id.toString())}/stop`;
        const meta = {
          name: "esql.async_query_stop",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async query(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["esql.query"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_query";
        const meta = {
          name: "esql.query"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Esql;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/exists.js
var require_exists = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/exists.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ExistsApi;
    var acceptedParams = {
      exists: {
        path: [
          "id",
          "index"
        ],
        body: [],
        query: [
          "preference",
          "realtime",
          "refresh",
          "routing",
          "_source",
          "_source_excludes",
          "_source_includes",
          "stored_fields",
          "version",
          "version_type"
        ]
      }
    };
    async function ExistsApi(params, options) {
      const { path: acceptedPath } = acceptedParams.exists;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "HEAD";
      const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "exists",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js
var require_exists_source = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ExistsSourceApi;
    var acceptedParams = {
      exists_source: {
        path: [
          "id",
          "index"
        ],
        body: [],
        query: [
          "preference",
          "realtime",
          "refresh",
          "routing",
          "_source",
          "_source_excludes",
          "_source_includes",
          "version",
          "version_type"
        ]
      }
    };
    async function ExistsSourceApi(params, options) {
      const { path: acceptedPath } = acceptedParams.exists_source;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "HEAD";
      const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "exists_source",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/explain.js
var require_explain = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/explain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ExplainApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      explain: {
        path: [
          "id",
          "index"
        ],
        body: [
          "query"
        ],
        query: [
          "analyzer",
          "analyze_wildcard",
          "default_operator",
          "df",
          "lenient",
          "preference",
          "routing",
          "_source",
          "_source_excludes",
          "_source_includes",
          "stored_fields",
          "q"
        ]
      }
    };
    async function ExplainApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.explain;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = body != null ? "POST" : "GET";
      const path = `/${encodeURIComponent(params.index.toString())}/_explain/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "explain",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/features.js
var require_features = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/features.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Features = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "features.get_features": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "features.reset_features": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          }
        };
      }
      async getFeatures(params, options) {
        const { path: acceptedPath } = this.acceptedParams["features.get_features"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_features";
        const meta = {
          name: "features.get_features"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async resetFeatures(params, options) {
        const { path: acceptedPath } = this.acceptedParams["features.reset_features"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_features/_reset";
        const meta = {
          name: "features.reset_features"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Features;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js
var require_field_caps = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = FieldCapsApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      field_caps: {
        path: [
          "index"
        ],
        body: [
          "fields",
          "index_filter",
          "runtime_mappings"
        ],
        query: [
          "allow_no_indices",
          "expand_wildcards",
          "fields",
          "ignore_unavailable",
          "include_unmapped",
          "filters",
          "types",
          "include_empty_fields"
        ]
      }
    };
    async function FieldCapsApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.field_caps;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_field_caps`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_field_caps";
      }
      const meta = {
        name: "field_caps",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/fleet.js
var require_fleet = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/fleet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Fleet = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "fleet.delete_secret": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "fleet.get_secret": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "fleet.global_checkpoints": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "wait_for_advance",
              "wait_for_index",
              "checkpoints",
              "timeout"
            ]
          },
          "fleet.msearch": {
            path: [
              "index"
            ],
            body: [
              "searches"
            ],
            query: [
              "allow_no_indices",
              "ccs_minimize_roundtrips",
              "expand_wildcards",
              "ignore_throttled",
              "ignore_unavailable",
              "max_concurrent_searches",
              "max_concurrent_shard_requests",
              "pre_filter_shard_size",
              "search_type",
              "rest_total_hits_as_int",
              "typed_keys",
              "wait_for_checkpoints",
              "allow_partial_search_results"
            ]
          },
          "fleet.post_secret": {
            path: [],
            body: [],
            query: []
          },
          "fleet.search": {
            path: [
              "index"
            ],
            body: [
              "aggregations",
              "aggs",
              "collapse",
              "explain",
              "ext",
              "from",
              "highlight",
              "track_total_hits",
              "indices_boost",
              "docvalue_fields",
              "min_score",
              "post_filter",
              "profile",
              "query",
              "rescore",
              "script_fields",
              "search_after",
              "size",
              "slice",
              "sort",
              "_source",
              "fields",
              "suggest",
              "terminate_after",
              "timeout",
              "track_scores",
              "version",
              "seq_no_primary_term",
              "stored_fields",
              "pit",
              "runtime_mappings",
              "stats"
            ],
            query: [
              "allow_no_indices",
              "analyzer",
              "analyze_wildcard",
              "batched_reduce_size",
              "ccs_minimize_roundtrips",
              "default_operator",
              "df",
              "docvalue_fields",
              "expand_wildcards",
              "explain",
              "ignore_throttled",
              "ignore_unavailable",
              "lenient",
              "max_concurrent_shard_requests",
              "preference",
              "pre_filter_shard_size",
              "request_cache",
              "routing",
              "scroll",
              "search_type",
              "stats",
              "stored_fields",
              "suggest_field",
              "suggest_mode",
              "suggest_size",
              "suggest_text",
              "terminate_after",
              "timeout",
              "track_total_hits",
              "track_scores",
              "typed_keys",
              "rest_total_hits_as_int",
              "version",
              "_source",
              "_source_excludes",
              "_source_includes",
              "seq_no_primary_term",
              "q",
              "size",
              "from",
              "sort",
              "wait_for_checkpoints",
              "allow_partial_search_results"
            ]
          }
        };
      }
      async deleteSecret(params, options) {
        const { path: acceptedPath } = this.acceptedParams["fleet.delete_secret"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_fleet/secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "fleet.delete_secret",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSecret(params, options) {
        const { path: acceptedPath } = this.acceptedParams["fleet.get_secret"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_fleet/secret/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "fleet.get_secret",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async globalCheckpoints(params, options) {
        const { path: acceptedPath } = this.acceptedParams["fleet.global_checkpoints"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/global_checkpoints`;
        const meta = {
          name: "fleet.global_checkpoints",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async msearch(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["fleet.msearch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = body != null ? "POST" : "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_msearch`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_fleet/_fleet_msearch";
        }
        const meta = {
          name: "fleet.msearch",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);
      }
      async postSecret(params, options) {
        const { path: acceptedPath } = this.acceptedParams["fleet.post_secret"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_fleet/secret";
        const meta = {
          name: "fleet.post_secret"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async search(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["fleet.search"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_search`;
        const meta = {
          name: "fleet.search",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Fleet;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/get.js
var require_get2 = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/get.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = GetApi;
    var acceptedParams = {
      get: {
        path: [
          "id",
          "index"
        ],
        body: [],
        query: [
          "force_synthetic_source",
          "preference",
          "realtime",
          "refresh",
          "routing",
          "_source",
          "_source_excludes",
          "_source_includes",
          "stored_fields",
          "version",
          "version_type"
        ]
      }
    };
    async function GetApi(params, options) {
      const { path: acceptedPath } = acceptedParams.get;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "GET";
      const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "get",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/get_script.js
var require_get_script = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/get_script.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = GetScriptApi;
    var acceptedParams = {
      get_script: {
        path: [
          "id"
        ],
        body: [],
        query: [
          "master_timeout"
        ]
      }
    };
    async function GetScriptApi(params, options) {
      const { path: acceptedPath } = acceptedParams.get_script;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "GET";
      const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "get_script",
        pathParts: {
          id: params.id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js
var require_get_script_context = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = GetScriptContextApi;
    var acceptedParams = {
      get_script_context: {
        path: [],
        body: [],
        query: []
      }
    };
    async function GetScriptContextApi(params, options) {
      const { path: acceptedPath } = acceptedParams.get_script_context;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "GET";
      const path = "/_script_context";
      const meta = {
        name: "get_script_context"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js
var require_get_script_languages = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = GetScriptLanguagesApi;
    var acceptedParams = {
      get_script_languages: {
        path: [],
        body: [],
        query: []
      }
    };
    async function GetScriptLanguagesApi(params, options) {
      const { path: acceptedPath } = acceptedParams.get_script_languages;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "GET";
      const path = "/_script_language";
      const meta = {
        name: "get_script_languages"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/get_source.js
var require_get_source = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/get_source.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = GetSourceApi;
    var acceptedParams = {
      get_source: {
        path: [
          "id",
          "index"
        ],
        body: [],
        query: [
          "preference",
          "realtime",
          "refresh",
          "routing",
          "_source",
          "_source_excludes",
          "_source_includes",
          "stored_fields",
          "version",
          "version_type"
        ]
      }
    };
    async function GetSourceApi(params, options) {
      const { path: acceptedPath } = acceptedParams.get_source;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "GET";
      const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "get_source",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/graph.js
var require_graph = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/graph.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Graph = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "graph.explore": {
            path: [
              "index"
            ],
            body: [
              "connections",
              "controls",
              "query",
              "vertices"
            ],
            query: [
              "routing",
              "timeout"
            ]
          }
        };
      }
      async explore(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["graph.explore"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_graph/explore`;
        const meta = {
          name: "graph.explore",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Graph;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/health_report.js
var require_health_report = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/health_report.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = HealthReportApi;
    var acceptedParams = {
      health_report: {
        path: [
          "feature"
        ],
        body: [],
        query: [
          "timeout",
          "verbose",
          "size"
        ]
      }
    };
    async function HealthReportApi(params, options) {
      const { path: acceptedPath } = acceptedParams.health_report;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      let method = "";
      let path = "";
      if (params.feature != null) {
        method = "GET";
        path = `/_health_report/${encodeURIComponent(params.feature.toString())}`;
      } else {
        method = "GET";
        path = "/_health_report";
      }
      const meta = {
        name: "health_report",
        pathParts: {
          feature: params.feature
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/ilm.js
var require_ilm = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/ilm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Ilm = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "ilm.delete_lifecycle": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ilm.explain_lifecycle": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "only_errors",
              "only_managed",
              "master_timeout"
            ]
          },
          "ilm.get_lifecycle": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ilm.get_status": {
            path: [],
            body: [],
            query: []
          },
          "ilm.migrate_to_data_tiers": {
            path: [],
            body: [
              "legacy_template_to_delete",
              "node_attribute"
            ],
            query: [
              "dry_run",
              "master_timeout"
            ]
          },
          "ilm.move_to_step": {
            path: [
              "index"
            ],
            body: [
              "current_step",
              "next_step"
            ],
            query: []
          },
          "ilm.put_lifecycle": {
            path: [
              "name"
            ],
            body: [
              "policy"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ilm.remove_policy": {
            path: [
              "index"
            ],
            body: [],
            query: []
          },
          "ilm.retry": {
            path: [
              "index"
            ],
            body: [],
            query: []
          },
          "ilm.start": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ilm.stop": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          }
        };
      }
      async deleteLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.delete_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "ilm.delete_lifecycle",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async explainLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.explain_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/explain`;
        const meta = {
          name: "ilm.explain_lifecycle",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.get_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_ilm/policy";
        }
        const meta = {
          name: "ilm.get_lifecycle",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.get_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_ilm/status";
        const meta = {
          name: "ilm.get_status"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async migrateToDataTiers(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ilm.migrate_to_data_tiers"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_ilm/migrate_to_data_tiers";
        const meta = {
          name: "ilm.migrate_to_data_tiers"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async moveToStep(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ilm.move_to_step"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ilm/move/${encodeURIComponent(params.index.toString())}`;
        const meta = {
          name: "ilm.move_to_step",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putLifecycle(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ilm.put_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "ilm.put_lifecycle",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async removePolicy(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.remove_policy"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/remove`;
        const meta = {
          name: "ilm.remove_policy",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async retry(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.retry"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/retry`;
        const meta = {
          name: "ilm.retry",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async start(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.start"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_ilm/start";
        const meta = {
          name: "ilm.start"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stop(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ilm.stop"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_ilm/stop";
        const meta = {
          name: "ilm.stop"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Ilm;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/index.js
var require_api2 = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = IndexApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      index: {
        path: [
          "id",
          "index"
        ],
        body: [
          "document"
        ],
        query: [
          "if_primary_term",
          "if_seq_no",
          "include_source_on_error",
          "op_type",
          "pipeline",
          "refresh",
          "routing",
          "timeout",
          "version",
          "version_type",
          "wait_for_active_shards",
          "require_alias"
        ]
      }
    };
    async function IndexApi(params, options) {
      var _a;
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.index;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null && params.id != null) {
        method = "PUT";
        path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;
      } else {
        method = "POST";
        path = `/${encodeURIComponent(params.index.toString())}/_doc`;
      }
      const meta = {
        name: "index",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/indices.js
var require_indices = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/indices.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Indices = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "indices.add_block": {
            path: [
              "index",
              "block"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "master_timeout",
              "timeout"
            ]
          },
          "indices.analyze": {
            path: [
              "index"
            ],
            body: [
              "analyzer",
              "attributes",
              "char_filter",
              "explain",
              "field",
              "filter",
              "normalizer",
              "text",
              "tokenizer"
            ],
            query: [
              "index"
            ]
          },
          "indices.cancel_migrate_reindex": {
            path: [
              "index"
            ],
            body: [],
            query: []
          },
          "indices.clear_cache": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "index",
              "allow_no_indices",
              "expand_wildcards",
              "fielddata",
              "fields",
              "ignore_unavailable",
              "query",
              "request"
            ]
          },
          "indices.clone": {
            path: [
              "index",
              "target"
            ],
            body: [
              "aliases",
              "settings"
            ],
            query: [
              "master_timeout",
              "timeout",
              "wait_for_active_shards"
            ]
          },
          "indices.close": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "master_timeout",
              "timeout",
              "wait_for_active_shards"
            ]
          },
          "indices.create": {
            path: [
              "index"
            ],
            body: [
              "aliases",
              "mappings",
              "settings"
            ],
            query: [
              "master_timeout",
              "timeout",
              "wait_for_active_shards"
            ]
          },
          "indices.create_data_stream": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "indices.create_from": {
            path: [
              "source",
              "dest"
            ],
            body: [
              "create_from"
            ],
            query: []
          },
          "indices.data_streams_stats": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "expand_wildcards"
            ]
          },
          "indices.delete": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "master_timeout",
              "timeout"
            ]
          },
          "indices.delete_alias": {
            path: [
              "index",
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "indices.delete_data_lifecycle": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "expand_wildcards",
              "master_timeout",
              "timeout"
            ]
          },
          "indices.delete_data_stream": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "expand_wildcards"
            ]
          },
          "indices.delete_index_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "indices.delete_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "indices.disk_usage": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "flush",
              "ignore_unavailable",
              "run_expensive_tasks"
            ]
          },
          "indices.downsample": {
            path: [
              "index",
              "target_index"
            ],
            body: [
              "config"
            ],
            query: []
          },
          "indices.exists": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "flat_settings",
              "ignore_unavailable",
              "include_defaults",
              "local"
            ]
          },
          "indices.exists_alias": {
            path: [
              "name",
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "master_timeout"
            ]
          },
          "indices.exists_index_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "local",
              "flat_settings",
              "master_timeout"
            ]
          },
          "indices.exists_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "flat_settings",
              "local",
              "master_timeout"
            ]
          },
          "indices.explain_data_lifecycle": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "include_defaults",
              "master_timeout"
            ]
          },
          "indices.field_usage_stats": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "fields"
            ]
          },
          "indices.flush": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "force",
              "ignore_unavailable",
              "wait_if_ongoing"
            ]
          },
          "indices.forcemerge": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "flush",
              "ignore_unavailable",
              "max_num_segments",
              "only_expunge_deletes",
              "wait_for_completion"
            ]
          },
          "indices.get": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "flat_settings",
              "ignore_unavailable",
              "include_defaults",
              "local",
              "master_timeout",
              "features"
            ]
          },
          "indices.get_alias": {
            path: [
              "name",
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "master_timeout"
            ]
          },
          "indices.get_data_lifecycle": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "expand_wildcards",
              "include_defaults",
              "master_timeout"
            ]
          },
          "indices.get_data_lifecycle_stats": {
            path: [],
            body: [],
            query: []
          },
          "indices.get_data_stream": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "expand_wildcards",
              "include_defaults",
              "master_timeout",
              "verbose"
            ]
          },
          "indices.get_field_mapping": {
            path: [
              "fields",
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "include_defaults",
              "local"
            ]
          },
          "indices.get_index_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "local",
              "flat_settings",
              "master_timeout",
              "include_defaults"
            ]
          },
          "indices.get_mapping": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "local",
              "master_timeout"
            ]
          },
          "indices.get_migrate_reindex_status": {
            path: [
              "index"
            ],
            body: [],
            query: []
          },
          "indices.get_settings": {
            path: [
              "index",
              "name"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "flat_settings",
              "ignore_unavailable",
              "include_defaults",
              "local",
              "master_timeout"
            ]
          },
          "indices.get_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "flat_settings",
              "local",
              "master_timeout"
            ]
          },
          "indices.migrate_reindex": {
            path: [],
            body: [
              "reindex"
            ],
            query: []
          },
          "indices.migrate_to_data_stream": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "indices.modify_data_stream": {
            path: [],
            body: [
              "actions"
            ],
            query: []
          },
          "indices.open": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "master_timeout",
              "timeout",
              "wait_for_active_shards"
            ]
          },
          "indices.promote_data_stream": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "indices.put_alias": {
            path: [
              "index",
              "name"
            ],
            body: [
              "filter",
              "index_routing",
              "is_write_index",
              "routing",
              "search_routing"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "indices.put_data_lifecycle": {
            path: [
              "name"
            ],
            body: [
              "data_retention",
              "downsampling",
              "enabled"
            ],
            query: [
              "expand_wildcards",
              "master_timeout",
              "timeout"
            ]
          },
          "indices.put_index_template": {
            path: [
              "name"
            ],
            body: [
              "index_patterns",
              "composed_of",
              "template",
              "data_stream",
              "priority",
              "version",
              "_meta",
              "allow_auto_create",
              "ignore_missing_component_templates",
              "deprecated"
            ],
            query: [
              "create",
              "master_timeout",
              "cause"
            ]
          },
          "indices.put_mapping": {
            path: [
              "index"
            ],
            body: [
              "date_detection",
              "dynamic",
              "dynamic_date_formats",
              "dynamic_templates",
              "_field_names",
              "_meta",
              "numeric_detection",
              "properties",
              "_routing",
              "_source",
              "runtime"
            ],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "master_timeout",
              "timeout",
              "write_index_only"
            ]
          },
          "indices.put_settings": {
            path: [
              "index"
            ],
            body: [
              "settings"
            ],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "flat_settings",
              "ignore_unavailable",
              "master_timeout",
              "preserve_existing",
              "reopen",
              "timeout"
            ]
          },
          "indices.put_template": {
            path: [
              "name"
            ],
            body: [
              "aliases",
              "index_patterns",
              "mappings",
              "order",
              "settings",
              "version"
            ],
            query: [
              "create",
              "master_timeout",
              "order",
              "cause"
            ]
          },
          "indices.recovery": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "active_only",
              "detailed"
            ]
          },
          "indices.refresh": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable"
            ]
          },
          "indices.reload_search_analyzers": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "resource"
            ]
          },
          "indices.resolve_cluster": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_throttled",
              "ignore_unavailable",
              "timeout"
            ]
          },
          "indices.resolve_index": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "expand_wildcards",
              "ignore_unavailable",
              "allow_no_indices"
            ]
          },
          "indices.rollover": {
            path: [
              "alias",
              "new_index"
            ],
            body: [
              "aliases",
              "conditions",
              "mappings",
              "settings"
            ],
            query: [
              "dry_run",
              "master_timeout",
              "timeout",
              "wait_for_active_shards",
              "lazy"
            ]
          },
          "indices.segments": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable"
            ]
          },
          "indices.shard_stores": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_unavailable",
              "status"
            ]
          },
          "indices.shrink": {
            path: [
              "index",
              "target"
            ],
            body: [
              "aliases",
              "settings"
            ],
            query: [
              "master_timeout",
              "timeout",
              "wait_for_active_shards"
            ]
          },
          "indices.simulate_index_template": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "create",
              "cause",
              "master_timeout",
              "include_defaults"
            ]
          },
          "indices.simulate_template": {
            path: [
              "name"
            ],
            body: [
              "allow_auto_create",
              "index_patterns",
              "composed_of",
              "template",
              "data_stream",
              "priority",
              "version",
              "_meta",
              "ignore_missing_component_templates",
              "deprecated"
            ],
            query: [
              "create",
              "cause",
              "master_timeout",
              "include_defaults"
            ]
          },
          "indices.split": {
            path: [
              "index",
              "target"
            ],
            body: [
              "aliases",
              "settings"
            ],
            query: [
              "master_timeout",
              "timeout",
              "wait_for_active_shards"
            ]
          },
          "indices.stats": {
            path: [
              "metric",
              "index"
            ],
            body: [],
            query: [
              "completion_fields",
              "expand_wildcards",
              "fielddata_fields",
              "fields",
              "forbid_closed_indices",
              "groups",
              "include_segment_file_sizes",
              "include_unloaded_segments",
              "level"
            ]
          },
          "indices.update_aliases": {
            path: [],
            body: [
              "actions"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "indices.validate_query": {
            path: [
              "index"
            ],
            body: [
              "query"
            ],
            query: [
              "allow_no_indices",
              "all_shards",
              "analyzer",
              "analyze_wildcard",
              "default_operator",
              "df",
              "expand_wildcards",
              "explain",
              "ignore_unavailable",
              "lenient",
              "rewrite",
              "q"
            ]
          }
        };
      }
      async addBlock(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.add_block"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/${encodeURIComponent(params.index.toString())}/_block/${encodeURIComponent(params.block.toString())}`;
        const meta = {
          name: "indices.add_block",
          pathParts: {
            index: params.index,
            block: params.block
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async analyze(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.analyze"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = body != null ? "POST" : "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_analyze`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_analyze";
        }
        const meta = {
          name: "indices.analyze",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async cancelMigrateReindex(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.cancel_migrate_reindex"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_migration/reindex/${encodeURIComponent(params.index.toString())}/_cancel`;
        const meta = {
          name: "indices.cancel_migrate_reindex",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clearCache(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.clear_cache"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "POST";
          path = `/${encodeURIComponent(params.index.toString())}/_cache/clear`;
        } else {
          method = "POST";
          path = "/_cache/clear";
        }
        const meta = {
          name: "indices.clear_cache",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clone(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.clone"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/${encodeURIComponent(params.index.toString())}/_clone/${encodeURIComponent(params.target.toString())}`;
        const meta = {
          name: "indices.clone",
          pathParts: {
            index: params.index,
            target: params.target
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async close(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.close"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_close`;
        const meta = {
          name: "indices.close",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async create(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.create"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/${encodeURIComponent(params.index.toString())}`;
        const meta = {
          name: "indices.create",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async createDataStream(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.create_data_stream"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.create_data_stream",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async createFrom(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.create_from"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_create_from/${encodeURIComponent(params.source.toString())}/${encodeURIComponent(params.dest.toString())}`;
        const meta = {
          name: "indices.create_from",
          pathParts: {
            source: params.source,
            dest: params.dest
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async dataStreamsStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.data_streams_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_stats`;
        } else {
          method = "GET";
          path = "/_data_stream/_stats";
        }
        const meta = {
          name: "indices.data_streams_stats",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/${encodeURIComponent(params.index.toString())}`;
        const meta = {
          name: "indices.delete",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteAlias(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.delete_alias"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null && params.name != null) {
          method = "DELETE";
          path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "DELETE";
          path = `/${encodeURIComponent(params.index.toString())}/_aliases/${encodeURIComponent(params.name.toString())}`;
        }
        const meta = {
          name: "indices.delete_alias",
          pathParts: {
            index: params.index,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteDataLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.delete_data_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_lifecycle`;
        const meta = {
          name: "indices.delete_data_lifecycle",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteDataStream(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.delete_data_stream"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.delete_data_stream",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteIndexTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.delete_index_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.delete_index_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.delete_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.delete_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async diskUsage(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.disk_usage"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_disk_usage`;
        const meta = {
          name: "indices.disk_usage",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async downsample(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.downsample"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_downsample/${encodeURIComponent(params.target_index.toString())}`;
        const meta = {
          name: "indices.downsample",
          pathParts: {
            index: params.index,
            target_index: params.target_index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async exists(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.exists"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "HEAD";
        const path = `/${encodeURIComponent(params.index.toString())}`;
        const meta = {
          name: "indices.exists",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async existsAlias(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.exists_alias"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null && params.name != null) {
          method = "HEAD";
          path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "HEAD";
          path = `/_alias/${encodeURIComponent(params.name.toString())}`;
        }
        const meta = {
          name: "indices.exists_alias",
          pathParts: {
            name: params.name,
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async existsIndexTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.exists_index_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "HEAD";
        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.exists_index_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async existsTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.exists_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "HEAD";
        const path = `/_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.exists_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async explainDataLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.explain_data_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_lifecycle/explain`;
        const meta = {
          name: "indices.explain_data_lifecycle",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async fieldUsageStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.field_usage_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_field_usage_stats`;
        const meta = {
          name: "indices.field_usage_stats",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async flush(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.flush"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = body != null ? "POST" : "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_flush`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_flush";
        }
        const meta = {
          name: "indices.flush",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async forcemerge(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.forcemerge"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "POST";
          path = `/${encodeURIComponent(params.index.toString())}/_forcemerge`;
        } else {
          method = "POST";
          path = "/_forcemerge";
        }
        const meta = {
          name: "indices.forcemerge",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}`;
        const meta = {
          name: "indices.get",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getAlias(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_alias"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null && params.name != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;
        } else if (params.name != null) {
          method = "GET";
          path = `/_alias/${encodeURIComponent(params.name.toString())}`;
        } else if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_alias`;
        } else {
          method = "GET";
          path = "/_alias";
        }
        const meta = {
          name: "indices.get_alias",
          pathParts: {
            name: params.name,
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getDataLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_data_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_lifecycle`;
        const meta = {
          name: "indices.get_data_lifecycle",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getDataLifecycleStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_data_lifecycle_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_lifecycle/stats";
        const meta = {
          name: "indices.get_data_lifecycle_stats"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getDataStream(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_data_stream"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_data_stream";
        }
        const meta = {
          name: "indices.get_data_stream",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getFieldMapping(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_field_mapping"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null && params.fields != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_mapping/field/${encodeURIComponent(params.fields.toString())}`;
        } else {
          method = "GET";
          path = `/_mapping/field/${encodeURIComponent(params.fields.toString())}`;
        }
        const meta = {
          name: "indices.get_field_mapping",
          pathParts: {
            fields: params.fields,
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getIndexTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_index_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_index_template/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_index_template";
        }
        const meta = {
          name: "indices.get_index_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getMapping(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_mapping"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_mapping`;
        } else {
          method = "GET";
          path = "/_mapping";
        }
        const meta = {
          name: "indices.get_mapping",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getMigrateReindexStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_migrate_reindex_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_migration/reindex/${encodeURIComponent(params.index.toString())}/_status`;
        const meta = {
          name: "indices.get_migrate_reindex_status",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSettings(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null && params.name != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_settings/${encodeURIComponent(params.name.toString())}`;
        } else if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_settings`;
        } else if (params.name != null) {
          method = "GET";
          path = `/_settings/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_settings";
        }
        const meta = {
          name: "indices.get_settings",
          pathParts: {
            index: params.index,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.get_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_template/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_template";
        }
        const meta = {
          name: "indices.get_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async migrateReindex(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.migrate_reindex"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_migration/reindex";
        const meta = {
          name: "indices.migrate_reindex"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async migrateToDataStream(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.migrate_to_data_stream"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_data_stream/_migrate/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.migrate_to_data_stream",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async modifyDataStream(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.modify_data_stream"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_data_stream/_modify";
        const meta = {
          name: "indices.modify_data_stream"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async open(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.open"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/${encodeURIComponent(params.index.toString())}/_open`;
        const meta = {
          name: "indices.open",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async promoteDataStream(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.promote_data_stream"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_data_stream/_promote/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.promote_data_stream",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAlias(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.put_alias"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.index != null && params.name != null) {
          method = "PUT";
          path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "PUT";
          path = `/${encodeURIComponent(params.index.toString())}/_aliases/${encodeURIComponent(params.name.toString())}`;
        }
        const meta = {
          name: "indices.put_alias",
          pathParts: {
            index: params.index,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putDataLifecycle(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.put_data_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_lifecycle`;
        const meta = {
          name: "indices.put_data_lifecycle",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putIndexTemplate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.put_index_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.put_index_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putMapping(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.put_mapping"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/${encodeURIComponent(params.index.toString())}/_mapping`;
        const meta = {
          name: "indices.put_mapping",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putSettings(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.put_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "PUT";
          path = `/${encodeURIComponent(params.index.toString())}/_settings`;
        } else {
          method = "PUT";
          path = "/_settings";
        }
        const meta = {
          name: "indices.put_settings",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putTemplate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.put_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_template/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.put_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async recovery(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.recovery"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_recovery`;
        } else {
          method = "GET";
          path = "/_recovery";
        }
        const meta = {
          name: "indices.recovery",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async refresh(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.refresh"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = body != null ? "POST" : "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_refresh`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_refresh";
        }
        const meta = {
          name: "indices.refresh",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async reloadSearchAnalyzers(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.reload_search_analyzers"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_reload_search_analyzers`;
        const meta = {
          name: "indices.reload_search_analyzers",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async resolveCluster(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.resolve_cluster"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_resolve/cluster/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_resolve/cluster";
        }
        const meta = {
          name: "indices.resolve_cluster",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async resolveIndex(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.resolve_index"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_resolve/index/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.resolve_index",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async rollover(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.rollover"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.alias != null && params.new_index != null) {
          method = "POST";
          path = `/${encodeURIComponent(params.alias.toString())}/_rollover/${encodeURIComponent(params.new_index.toString())}`;
        } else {
          method = "POST";
          path = `/${encodeURIComponent(params.alias.toString())}/_rollover`;
        }
        const meta = {
          name: "indices.rollover",
          pathParts: {
            alias: params.alias,
            new_index: params.new_index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async segments(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.segments"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_segments`;
        } else {
          method = "GET";
          path = "/_segments";
        }
        const meta = {
          name: "indices.segments",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async shardStores(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.shard_stores"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_shard_stores`;
        } else {
          method = "GET";
          path = "/_shard_stores";
        }
        const meta = {
          name: "indices.shard_stores",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async shrink(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.shrink"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/${encodeURIComponent(params.index.toString())}/_shrink/${encodeURIComponent(params.target.toString())}`;
        const meta = {
          name: "indices.shrink",
          pathParts: {
            index: params.index,
            target: params.target
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async simulateIndexTemplate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.simulate_index_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_index_template/_simulate_index/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "indices.simulate_index_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async simulateTemplate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.simulate_template"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "POST";
          path = `/_index_template/_simulate/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "POST";
          path = "/_index_template/_simulate";
        }
        const meta = {
          name: "indices.simulate_template",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async split(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.split"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/${encodeURIComponent(params.index.toString())}/_split/${encodeURIComponent(params.target.toString())}`;
        const meta = {
          name: "indices.split",
          pathParts: {
            index: params.index,
            target: params.target
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["indices.stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null && params.metric != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_stats/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.metric != null) {
          method = "GET";
          path = `/_stats/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_stats`;
        } else {
          method = "GET";
          path = "/_stats";
        }
        const meta = {
          name: "indices.stats",
          pathParts: {
            metric: params.metric,
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateAliases(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.update_aliases"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_aliases";
        const meta = {
          name: "indices.update_aliases"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async validateQuery(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["indices.validate_query"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = body != null ? "POST" : "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_validate/query`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_validate/query";
        }
        const meta = {
          name: "indices.validate_query",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Indices;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/inference.js
var require_inference = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/inference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Inference = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "inference.chat_completion_unified": {
            path: [
              "inference_id"
            ],
            body: [
              "chat_completion_request"
            ],
            query: [
              "timeout"
            ]
          },
          "inference.completion": {
            path: [
              "inference_id"
            ],
            body: [
              "input",
              "task_settings"
            ],
            query: [
              "timeout"
            ]
          },
          "inference.delete": {
            path: [
              "task_type",
              "inference_id"
            ],
            body: [],
            query: [
              "dry_run",
              "force"
            ]
          },
          "inference.get": {
            path: [
              "task_type",
              "inference_id"
            ],
            body: [],
            query: []
          },
          "inference.inference": {
            path: [
              "task_type",
              "inference_id"
            ],
            body: [
              "query",
              "input",
              "task_settings"
            ],
            query: [
              "timeout"
            ]
          },
          "inference.put": {
            path: [
              "task_type",
              "inference_id"
            ],
            body: [
              "inference_config"
            ],
            query: []
          },
          "inference.put_alibabacloud": {
            path: [
              "task_type",
              "alibabacloud_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_amazonbedrock": {
            path: [
              "task_type",
              "amazonbedrock_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_anthropic": {
            path: [
              "task_type",
              "anthropic_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_azureaistudio": {
            path: [
              "task_type",
              "azureaistudio_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_azureopenai": {
            path: [
              "task_type",
              "azureopenai_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_cohere": {
            path: [
              "task_type",
              "cohere_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_elasticsearch": {
            path: [
              "task_type",
              "elasticsearch_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_elser": {
            path: [
              "task_type",
              "elser_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings"
            ],
            query: []
          },
          "inference.put_googleaistudio": {
            path: [
              "task_type",
              "googleaistudio_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings"
            ],
            query: []
          },
          "inference.put_googlevertexai": {
            path: [
              "task_type",
              "googlevertexai_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_hugging_face": {
            path: [
              "task_type",
              "huggingface_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings"
            ],
            query: []
          },
          "inference.put_jinaai": {
            path: [
              "task_type",
              "jinaai_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_mistral": {
            path: [
              "task_type",
              "mistral_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings"
            ],
            query: []
          },
          "inference.put_openai": {
            path: [
              "task_type",
              "openai_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_voyageai": {
            path: [
              "task_type",
              "voyageai_inference_id"
            ],
            body: [
              "chunking_settings",
              "service",
              "service_settings",
              "task_settings"
            ],
            query: []
          },
          "inference.put_watsonx": {
            path: [
              "task_type",
              "watsonx_inference_id"
            ],
            body: [
              "service",
              "service_settings"
            ],
            query: []
          },
          "inference.rerank": {
            path: [
              "inference_id"
            ],
            body: [
              "query",
              "input",
              "task_settings"
            ],
            query: [
              "timeout"
            ]
          },
          "inference.sparse_embedding": {
            path: [
              "inference_id"
            ],
            body: [
              "input",
              "task_settings"
            ],
            query: [
              "timeout"
            ]
          },
          "inference.stream_completion": {
            path: [
              "inference_id"
            ],
            body: [
              "input",
              "task_settings"
            ],
            query: []
          },
          "inference.text_embedding": {
            path: [
              "inference_id"
            ],
            body: [
              "input",
              "task_settings"
            ],
            query: [
              "timeout"
            ]
          },
          "inference.update": {
            path: [
              "inference_id",
              "task_type"
            ],
            body: [
              "inference_config"
            ],
            query: []
          }
        };
      }
      async chatCompletionUnified(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.chat_completion_unified"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_inference/chat_completion/${encodeURIComponent(params.inference_id.toString())}/_stream`;
        const meta = {
          name: "inference.chat_completion_unified",
          pathParts: {
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async completion(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.completion"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_inference/completion/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
          name: "inference.completion",
          pathParts: {
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["inference.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.task_type != null && params.inference_id != null) {
          method = "DELETE";
          path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
          method = "DELETE";
          path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        }
        const meta = {
          name: "inference.delete",
          pathParts: {
            task_type: params.task_type,
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["inference.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.task_type != null && params.inference_id != null) {
          method = "GET";
          path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else if (params.inference_id != null) {
          method = "GET";
          path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
          method = "GET";
          path = "/_inference";
        }
        const meta = {
          name: "inference.get",
          pathParts: {
            task_type: params.task_type,
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async inference(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.inference"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.task_type != null && params.inference_id != null) {
          method = "POST";
          path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
          method = "POST";
          path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        }
        const meta = {
          name: "inference.inference",
          pathParts: {
            task_type: params.task_type,
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async put(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.task_type != null && params.inference_id != null) {
          method = "PUT";
          path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;
        } else {
          method = "PUT";
          path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;
        }
        const meta = {
          name: "inference.put",
          pathParts: {
            task_type: params.task_type,
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAlibabacloud(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_alibabacloud"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.alibabacloud_inference_id.toString())}`;
        const meta = {
          name: "inference.put_alibabacloud",
          pathParts: {
            task_type: params.task_type,
            alibabacloud_inference_id: params.alibabacloud_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAmazonbedrock(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_amazonbedrock"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.amazonbedrock_inference_id.toString())}`;
        const meta = {
          name: "inference.put_amazonbedrock",
          pathParts: {
            task_type: params.task_type,
            amazonbedrock_inference_id: params.amazonbedrock_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAnthropic(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_anthropic"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.anthropic_inference_id.toString())}`;
        const meta = {
          name: "inference.put_anthropic",
          pathParts: {
            task_type: params.task_type,
            anthropic_inference_id: params.anthropic_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAzureaistudio(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_azureaistudio"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.azureaistudio_inference_id.toString())}`;
        const meta = {
          name: "inference.put_azureaistudio",
          pathParts: {
            task_type: params.task_type,
            azureaistudio_inference_id: params.azureaistudio_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putAzureopenai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_azureopenai"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.azureopenai_inference_id.toString())}`;
        const meta = {
          name: "inference.put_azureopenai",
          pathParts: {
            task_type: params.task_type,
            azureopenai_inference_id: params.azureopenai_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putCohere(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_cohere"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.cohere_inference_id.toString())}`;
        const meta = {
          name: "inference.put_cohere",
          pathParts: {
            task_type: params.task_type,
            cohere_inference_id: params.cohere_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putElasticsearch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_elasticsearch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.elasticsearch_inference_id.toString())}`;
        const meta = {
          name: "inference.put_elasticsearch",
          pathParts: {
            task_type: params.task_type,
            elasticsearch_inference_id: params.elasticsearch_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putElser(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_elser"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.elser_inference_id.toString())}`;
        const meta = {
          name: "inference.put_elser",
          pathParts: {
            task_type: params.task_type,
            elser_inference_id: params.elser_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putGoogleaistudio(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_googleaistudio"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.googleaistudio_inference_id.toString())}`;
        const meta = {
          name: "inference.put_googleaistudio",
          pathParts: {
            task_type: params.task_type,
            googleaistudio_inference_id: params.googleaistudio_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putGooglevertexai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_googlevertexai"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.googlevertexai_inference_id.toString())}`;
        const meta = {
          name: "inference.put_googlevertexai",
          pathParts: {
            task_type: params.task_type,
            googlevertexai_inference_id: params.googlevertexai_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putHuggingFace(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_hugging_face"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.huggingface_inference_id.toString())}`;
        const meta = {
          name: "inference.put_hugging_face",
          pathParts: {
            task_type: params.task_type,
            huggingface_inference_id: params.huggingface_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putJinaai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_jinaai"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.jinaai_inference_id.toString())}`;
        const meta = {
          name: "inference.put_jinaai",
          pathParts: {
            task_type: params.task_type,
            jinaai_inference_id: params.jinaai_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putMistral(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_mistral"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.mistral_inference_id.toString())}`;
        const meta = {
          name: "inference.put_mistral",
          pathParts: {
            task_type: params.task_type,
            mistral_inference_id: params.mistral_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putOpenai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_openai"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.openai_inference_id.toString())}`;
        const meta = {
          name: "inference.put_openai",
          pathParts: {
            task_type: params.task_type,
            openai_inference_id: params.openai_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putVoyageai(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_voyageai"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.voyageai_inference_id.toString())}`;
        const meta = {
          name: "inference.put_voyageai",
          pathParts: {
            task_type: params.task_type,
            voyageai_inference_id: params.voyageai_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putWatsonx(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.put_watsonx"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.watsonx_inference_id.toString())}`;
        const meta = {
          name: "inference.put_watsonx",
          pathParts: {
            task_type: params.task_type,
            watsonx_inference_id: params.watsonx_inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async rerank(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.rerank"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_inference/rerank/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
          name: "inference.rerank",
          pathParts: {
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async sparseEmbedding(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.sparse_embedding"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_inference/sparse_embedding/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
          name: "inference.sparse_embedding",
          pathParts: {
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async streamCompletion(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.stream_completion"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_inference/completion/${encodeURIComponent(params.inference_id.toString())}/_stream`;
        const meta = {
          name: "inference.stream_completion",
          pathParts: {
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async textEmbedding(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.text_embedding"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_inference/text_embedding/${encodeURIComponent(params.inference_id.toString())}`;
        const meta = {
          name: "inference.text_embedding",
          pathParts: {
            inference_id: params.inference_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async update(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["inference.update"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.task_type != null && params.inference_id != null) {
          method = "PUT";
          path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}/_update`;
        } else {
          method = "PUT";
          path = `/_inference/${encodeURIComponent(params.inference_id.toString())}/_update`;
        }
        const meta = {
          name: "inference.update",
          pathParts: {
            inference_id: params.inference_id,
            task_type: params.task_type
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Inference;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/info.js
var require_info = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/info.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = InfoApi;
    var acceptedParams = {
      info: {
        path: [],
        body: [],
        query: []
      }
    };
    async function InfoApi(params, options) {
      const { path: acceptedPath } = acceptedParams.info;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "GET";
      const path = "/";
      const meta = {
        name: "info"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/ingest.js
var require_ingest = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/ingest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Ingest = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "ingest.delete_geoip_database": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ingest.delete_ip_location_database": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ingest.delete_pipeline": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ingest.geo_ip_stats": {
            path: [],
            body: [],
            query: []
          },
          "ingest.get_geoip_database": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "ingest.get_ip_location_database": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "ingest.get_pipeline": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "master_timeout",
              "summary"
            ]
          },
          "ingest.processor_grok": {
            path: [],
            body: [],
            query: []
          },
          "ingest.put_geoip_database": {
            path: [
              "id"
            ],
            body: [
              "name",
              "maxmind"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ingest.put_ip_location_database": {
            path: [
              "id"
            ],
            body: [
              "configuration"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ingest.put_pipeline": {
            path: [
              "id"
            ],
            body: [
              "_meta",
              "description",
              "on_failure",
              "processors",
              "version",
              "deprecated"
            ],
            query: [
              "master_timeout",
              "timeout",
              "if_version"
            ]
          },
          "ingest.simulate": {
            path: [
              "id"
            ],
            body: [
              "docs",
              "pipeline"
            ],
            query: [
              "verbose"
            ]
          }
        };
      }
      async deleteGeoipDatabase(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.delete_geoip_database"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ingest.delete_geoip_database",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteIpLocationDatabase(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.delete_ip_location_database"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ingest.delete_ip_location_database",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deletePipeline(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.delete_pipeline"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ingest.delete_pipeline",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async geoIpStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.geo_ip_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_ingest/geoip/stats";
        const meta = {
          name: "ingest.geo_ip_stats"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getGeoipDatabase(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.get_geoip_database"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_ingest/geoip/database";
        }
        const meta = {
          name: "ingest.get_geoip_database",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getIpLocationDatabase(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.get_ip_location_database"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_ingest/ip_location/database";
        }
        const meta = {
          name: "ingest.get_ip_location_database",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getPipeline(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.get_pipeline"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_ingest/pipeline";
        }
        const meta = {
          name: "ingest.get_pipeline",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async processorGrok(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ingest.processor_grok"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_ingest/processor/grok";
        const meta = {
          name: "ingest.processor_grok"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putGeoipDatabase(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ingest.put_geoip_database"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ingest.put_geoip_database",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putIpLocationDatabase(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ingest.put_ip_location_database"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ingest.put_ip_location_database",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putPipeline(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ingest.put_pipeline"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ingest.put_pipeline",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async simulate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ingest.simulate"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}/_simulate`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_ingest/pipeline/_simulate";
        }
        const meta = {
          name: "ingest.simulate",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Ingest;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js
var require_knn_search = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = KnnSearchApi;
    var acceptedParams = {
      knn_search: {
        path: [
          "index"
        ],
        body: [],
        query: []
      }
    };
    async function KnnSearchApi(params, options) {
      const { path: acceptedPath } = acceptedParams.knn_search;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = body != null ? "POST" : "GET";
      const path = `/${encodeURIComponent(params.index.toString())}/_knn_search`;
      const meta = {
        name: "knn_search",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/license.js
var require_license = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/license.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var License = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "license.delete": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "license.get": {
            path: [],
            body: [],
            query: [
              "accept_enterprise",
              "local"
            ]
          },
          "license.get_basic_status": {
            path: [],
            body: [],
            query: []
          },
          "license.get_trial_status": {
            path: [],
            body: [],
            query: []
          },
          "license.post": {
            path: [],
            body: [
              "license",
              "licenses"
            ],
            query: [
              "acknowledge",
              "master_timeout",
              "timeout"
            ]
          },
          "license.post_start_basic": {
            path: [],
            body: [],
            query: [
              "acknowledge",
              "master_timeout",
              "timeout"
            ]
          },
          "license.post_start_trial": {
            path: [],
            body: [],
            query: [
              "acknowledge",
              "type_query_string",
              "master_timeout"
            ]
          }
        };
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["license.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = "/_license";
        const meta = {
          name: "license.delete"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["license.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_license";
        const meta = {
          name: "license.get"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getBasicStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["license.get_basic_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_license/basic_status";
        const meta = {
          name: "license.get_basic_status"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getTrialStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["license.get_trial_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_license/trial_status";
        const meta = {
          name: "license.get_trial_status"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async post(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["license.post"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = "/_license";
        const meta = {
          name: "license.post"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async postStartBasic(params, options) {
        const { path: acceptedPath } = this.acceptedParams["license.post_start_basic"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_license/start_basic";
        const meta = {
          name: "license.post_start_basic"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async postStartTrial(params, options) {
        const { path: acceptedPath } = this.acceptedParams["license.post_start_trial"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_license/start_trial";
        const meta = {
          name: "license.post_start_trial"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = License;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/logstash.js
var require_logstash = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/logstash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Logstash = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "logstash.delete_pipeline": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "logstash.get_pipeline": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "logstash.put_pipeline": {
            path: [
              "id"
            ],
            body: [
              "pipeline"
            ],
            query: []
          }
        };
      }
      async deletePipeline(params, options) {
        const { path: acceptedPath } = this.acceptedParams["logstash.delete_pipeline"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "logstash.delete_pipeline",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getPipeline(params, options) {
        const { path: acceptedPath } = this.acceptedParams["logstash.get_pipeline"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_logstash/pipeline";
        }
        const meta = {
          name: "logstash.get_pipeline",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putPipeline(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["logstash.put_pipeline"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "logstash.put_pipeline",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Logstash;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/mget.js
var require_mget = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/mget.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = MgetApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      mget: {
        path: [
          "index"
        ],
        body: [
          "docs",
          "ids"
        ],
        query: [
          "force_synthetic_source",
          "preference",
          "realtime",
          "refresh",
          "routing",
          "_source",
          "_source_excludes",
          "_source_includes",
          "stored_fields"
        ]
      }
    };
    async function MgetApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.mget;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_mget`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_mget";
      }
      const meta = {
        name: "mget",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/migration.js
var require_migration = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/migration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Migration = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "migration.deprecations": {
            path: [
              "index"
            ],
            body: [],
            query: []
          },
          "migration.get_feature_upgrade_status": {
            path: [],
            body: [],
            query: []
          },
          "migration.post_feature_upgrade": {
            path: [],
            body: [],
            query: []
          }
        };
      }
      async deprecations(params, options) {
        const { path: acceptedPath } = this.acceptedParams["migration.deprecations"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_migration/deprecations`;
        } else {
          method = "GET";
          path = "/_migration/deprecations";
        }
        const meta = {
          name: "migration.deprecations",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getFeatureUpgradeStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["migration.get_feature_upgrade_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_migration/system_features";
        const meta = {
          name: "migration.get_feature_upgrade_status"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async postFeatureUpgrade(params, options) {
        const { path: acceptedPath } = this.acceptedParams["migration.post_feature_upgrade"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_migration/system_features";
        const meta = {
          name: "migration.post_feature_upgrade"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Migration;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/ml.js
var require_ml = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/ml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Ml = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "ml.clear_trained_model_deployment_cache": {
            path: [
              "model_id"
            ],
            body: [],
            query: []
          },
          "ml.close_job": {
            path: [
              "job_id"
            ],
            body: [
              "allow_no_match",
              "force",
              "timeout"
            ],
            query: [
              "allow_no_match",
              "force",
              "timeout"
            ]
          },
          "ml.delete_calendar": {
            path: [
              "calendar_id"
            ],
            body: [],
            query: []
          },
          "ml.delete_calendar_event": {
            path: [
              "calendar_id",
              "event_id"
            ],
            body: [],
            query: []
          },
          "ml.delete_calendar_job": {
            path: [
              "calendar_id",
              "job_id"
            ],
            body: [],
            query: []
          },
          "ml.delete_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "force",
              "timeout"
            ]
          },
          "ml.delete_datafeed": {
            path: [
              "datafeed_id"
            ],
            body: [],
            query: [
              "force"
            ]
          },
          "ml.delete_expired_data": {
            path: [
              "job_id"
            ],
            body: [
              "requests_per_second",
              "timeout"
            ],
            query: [
              "requests_per_second",
              "timeout"
            ]
          },
          "ml.delete_filter": {
            path: [
              "filter_id"
            ],
            body: [],
            query: []
          },
          "ml.delete_forecast": {
            path: [
              "job_id",
              "forecast_id"
            ],
            body: [],
            query: [
              "allow_no_forecasts",
              "timeout"
            ]
          },
          "ml.delete_job": {
            path: [
              "job_id"
            ],
            body: [],
            query: [
              "force",
              "delete_user_annotations",
              "wait_for_completion"
            ]
          },
          "ml.delete_model_snapshot": {
            path: [
              "job_id",
              "snapshot_id"
            ],
            body: [],
            query: []
          },
          "ml.delete_trained_model": {
            path: [
              "model_id"
            ],
            body: [],
            query: [
              "force",
              "timeout"
            ]
          },
          "ml.delete_trained_model_alias": {
            path: [
              "model_alias",
              "model_id"
            ],
            body: [],
            query: []
          },
          "ml.estimate_model_memory": {
            path: [],
            body: [
              "analysis_config",
              "max_bucket_cardinality",
              "overall_cardinality"
            ],
            query: []
          },
          "ml.evaluate_data_frame": {
            path: [],
            body: [
              "evaluation",
              "index",
              "query"
            ],
            query: []
          },
          "ml.explain_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [
              "source",
              "dest",
              "analysis",
              "description",
              "model_memory_limit",
              "max_num_threads",
              "analyzed_fields",
              "allow_lazy_start"
            ],
            query: []
          },
          "ml.flush_job": {
            path: [
              "job_id"
            ],
            body: [
              "advance_time",
              "calc_interim",
              "end",
              "skip_time",
              "start"
            ],
            query: [
              "advance_time",
              "calc_interim",
              "end",
              "skip_time",
              "start"
            ]
          },
          "ml.forecast": {
            path: [
              "job_id"
            ],
            body: [
              "duration",
              "expires_in",
              "max_model_memory"
            ],
            query: [
              "duration",
              "expires_in",
              "max_model_memory"
            ]
          },
          "ml.get_buckets": {
            path: [
              "job_id",
              "timestamp"
            ],
            body: [
              "anomaly_score",
              "desc",
              "end",
              "exclude_interim",
              "expand",
              "page",
              "sort",
              "start"
            ],
            query: [
              "anomaly_score",
              "desc",
              "end",
              "exclude_interim",
              "expand",
              "from",
              "size",
              "sort",
              "start"
            ]
          },
          "ml.get_calendar_events": {
            path: [
              "calendar_id"
            ],
            body: [],
            query: [
              "end",
              "from",
              "job_id",
              "size",
              "start"
            ]
          },
          "ml.get_calendars": {
            path: [
              "calendar_id"
            ],
            body: [
              "page"
            ],
            query: [
              "from",
              "size"
            ]
          },
          "ml.get_categories": {
            path: [
              "job_id",
              "category_id"
            ],
            body: [
              "page"
            ],
            query: [
              "from",
              "partition_field_value",
              "size"
            ]
          },
          "ml.get_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "from",
              "size",
              "exclude_generated"
            ]
          },
          "ml.get_data_frame_analytics_stats": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "from",
              "size",
              "verbose"
            ]
          },
          "ml.get_datafeed_stats": {
            path: [
              "datafeed_id"
            ],
            body: [],
            query: [
              "allow_no_match"
            ]
          },
          "ml.get_datafeeds": {
            path: [
              "datafeed_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "exclude_generated"
            ]
          },
          "ml.get_filters": {
            path: [
              "filter_id"
            ],
            body: [],
            query: [
              "from",
              "size"
            ]
          },
          "ml.get_influencers": {
            path: [
              "job_id"
            ],
            body: [
              "page"
            ],
            query: [
              "desc",
              "end",
              "exclude_interim",
              "influencer_score",
              "from",
              "size",
              "sort",
              "start"
            ]
          },
          "ml.get_job_stats": {
            path: [
              "job_id"
            ],
            body: [],
            query: [
              "allow_no_match"
            ]
          },
          "ml.get_jobs": {
            path: [
              "job_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "exclude_generated"
            ]
          },
          "ml.get_memory_stats": {
            path: [
              "node_id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "ml.get_model_snapshot_upgrade_stats": {
            path: [
              "job_id",
              "snapshot_id"
            ],
            body: [],
            query: [
              "allow_no_match"
            ]
          },
          "ml.get_model_snapshots": {
            path: [
              "job_id",
              "snapshot_id"
            ],
            body: [
              "desc",
              "end",
              "page",
              "sort",
              "start"
            ],
            query: [
              "desc",
              "end",
              "from",
              "size",
              "sort",
              "start"
            ]
          },
          "ml.get_overall_buckets": {
            path: [
              "job_id"
            ],
            body: [
              "allow_no_match",
              "bucket_span",
              "end",
              "exclude_interim",
              "overall_score",
              "start",
              "top_n"
            ],
            query: [
              "allow_no_match",
              "bucket_span",
              "end",
              "exclude_interim",
              "overall_score",
              "start",
              "top_n"
            ]
          },
          "ml.get_records": {
            path: [
              "job_id"
            ],
            body: [
              "desc",
              "end",
              "exclude_interim",
              "page",
              "record_score",
              "sort",
              "start"
            ],
            query: [
              "desc",
              "end",
              "exclude_interim",
              "from",
              "record_score",
              "size",
              "sort",
              "start"
            ]
          },
          "ml.get_trained_models": {
            path: [
              "model_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "decompress_definition",
              "exclude_generated",
              "from",
              "include",
              "size",
              "tags"
            ]
          },
          "ml.get_trained_models_stats": {
            path: [
              "model_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "from",
              "size"
            ]
          },
          "ml.infer_trained_model": {
            path: [
              "model_id"
            ],
            body: [
              "docs",
              "inference_config"
            ],
            query: [
              "timeout"
            ]
          },
          "ml.info": {
            path: [],
            body: [],
            query: []
          },
          "ml.open_job": {
            path: [
              "job_id"
            ],
            body: [
              "timeout"
            ],
            query: [
              "timeout"
            ]
          },
          "ml.post_calendar_events": {
            path: [
              "calendar_id"
            ],
            body: [
              "events"
            ],
            query: []
          },
          "ml.post_data": {
            path: [
              "job_id"
            ],
            body: [
              "data"
            ],
            query: [
              "reset_end",
              "reset_start"
            ]
          },
          "ml.preview_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [
              "config"
            ],
            query: []
          },
          "ml.preview_datafeed": {
            path: [
              "datafeed_id"
            ],
            body: [
              "datafeed_config",
              "job_config"
            ],
            query: [
              "start",
              "end"
            ]
          },
          "ml.put_calendar": {
            path: [
              "calendar_id"
            ],
            body: [
              "job_ids",
              "description"
            ],
            query: []
          },
          "ml.put_calendar_job": {
            path: [
              "calendar_id",
              "job_id"
            ],
            body: [],
            query: []
          },
          "ml.put_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [
              "allow_lazy_start",
              "analysis",
              "analyzed_fields",
              "description",
              "dest",
              "max_num_threads",
              "_meta",
              "model_memory_limit",
              "source",
              "headers",
              "version"
            ],
            query: []
          },
          "ml.put_datafeed": {
            path: [
              "datafeed_id"
            ],
            body: [
              "aggregations",
              "aggs",
              "chunking_config",
              "delayed_data_check_config",
              "frequency",
              "indices",
              "indexes",
              "indices_options",
              "job_id",
              "max_empty_searches",
              "query",
              "query_delay",
              "runtime_mappings",
              "script_fields",
              "scroll_size",
              "headers"
            ],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_throttled",
              "ignore_unavailable"
            ]
          },
          "ml.put_filter": {
            path: [
              "filter_id"
            ],
            body: [
              "description",
              "items"
            ],
            query: []
          },
          "ml.put_job": {
            path: [],
            body: [
              "allow_lazy_open",
              "analysis_config",
              "analysis_limits",
              "background_persist_interval",
              "custom_settings",
              "daily_model_snapshot_retention_after_days",
              "data_description",
              "datafeed_config",
              "description",
              "job_id",
              "groups",
              "model_plot_config",
              "model_snapshot_retention_days",
              "renormalization_window_days",
              "results_index_name",
              "results_retention_days"
            ],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_throttled",
              "ignore_unavailable"
            ]
          },
          "ml.put_trained_model": {
            path: [
              "model_id"
            ],
            body: [
              "compressed_definition",
              "definition",
              "description",
              "inference_config",
              "input",
              "metadata",
              "model_type",
              "model_size_bytes",
              "platform_architecture",
              "tags",
              "prefix_strings"
            ],
            query: [
              "defer_definition_decompression",
              "wait_for_completion"
            ]
          },
          "ml.put_trained_model_alias": {
            path: [
              "model_alias",
              "model_id"
            ],
            body: [],
            query: [
              "reassign"
            ]
          },
          "ml.put_trained_model_definition_part": {
            path: [
              "model_id",
              "part"
            ],
            body: [
              "definition",
              "total_definition_length",
              "total_parts"
            ],
            query: []
          },
          "ml.put_trained_model_vocabulary": {
            path: [
              "model_id"
            ],
            body: [
              "vocabulary",
              "merges",
              "scores"
            ],
            query: []
          },
          "ml.reset_job": {
            path: [
              "job_id"
            ],
            body: [],
            query: [
              "wait_for_completion",
              "delete_user_annotations"
            ]
          },
          "ml.revert_model_snapshot": {
            path: [
              "job_id",
              "snapshot_id"
            ],
            body: [
              "delete_intervening_results"
            ],
            query: [
              "delete_intervening_results"
            ]
          },
          "ml.set_upgrade_mode": {
            path: [],
            body: [],
            query: [
              "enabled",
              "timeout"
            ]
          },
          "ml.start_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "timeout"
            ]
          },
          "ml.start_datafeed": {
            path: [
              "datafeed_id"
            ],
            body: [
              "end",
              "start",
              "timeout"
            ],
            query: [
              "end",
              "start",
              "timeout"
            ]
          },
          "ml.start_trained_model_deployment": {
            path: [
              "model_id"
            ],
            body: [
              "adaptive_allocations"
            ],
            query: [
              "cache_size",
              "deployment_id",
              "number_of_allocations",
              "priority",
              "queue_capacity",
              "threads_per_allocation",
              "timeout",
              "wait_for"
            ]
          },
          "ml.stop_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "force",
              "timeout"
            ]
          },
          "ml.stop_datafeed": {
            path: [
              "datafeed_id"
            ],
            body: [
              "allow_no_match",
              "force",
              "timeout"
            ],
            query: [
              "allow_no_match",
              "force",
              "timeout"
            ]
          },
          "ml.stop_trained_model_deployment": {
            path: [
              "model_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "force"
            ]
          },
          "ml.update_data_frame_analytics": {
            path: [
              "id"
            ],
            body: [
              "description",
              "model_memory_limit",
              "max_num_threads",
              "allow_lazy_start"
            ],
            query: []
          },
          "ml.update_datafeed": {
            path: [
              "datafeed_id"
            ],
            body: [
              "aggregations",
              "chunking_config",
              "delayed_data_check_config",
              "frequency",
              "indices",
              "indexes",
              "indices_options",
              "job_id",
              "max_empty_searches",
              "query",
              "query_delay",
              "runtime_mappings",
              "script_fields",
              "scroll_size"
            ],
            query: [
              "allow_no_indices",
              "expand_wildcards",
              "ignore_throttled",
              "ignore_unavailable"
            ]
          },
          "ml.update_filter": {
            path: [
              "filter_id"
            ],
            body: [
              "add_items",
              "description",
              "remove_items"
            ],
            query: []
          },
          "ml.update_job": {
            path: [
              "job_id"
            ],
            body: [
              "allow_lazy_open",
              "analysis_limits",
              "background_persist_interval",
              "custom_settings",
              "categorization_filters",
              "description",
              "model_plot_config",
              "model_prune_window",
              "daily_model_snapshot_retention_after_days",
              "model_snapshot_retention_days",
              "renormalization_window_days",
              "results_retention_days",
              "groups",
              "detectors",
              "per_partition_categorization"
            ],
            query: []
          },
          "ml.update_model_snapshot": {
            path: [
              "job_id",
              "snapshot_id"
            ],
            body: [
              "description",
              "retain"
            ],
            query: []
          },
          "ml.update_trained_model_deployment": {
            path: [
              "model_id"
            ],
            body: [
              "number_of_allocations",
              "adaptive_allocations"
            ],
            query: [
              "number_of_allocations"
            ]
          },
          "ml.upgrade_job_snapshot": {
            path: [
              "job_id",
              "snapshot_id"
            ],
            body: [],
            query: [
              "wait_for_completion",
              "timeout"
            ]
          },
          "ml.validate": {
            path: [],
            body: [
              "job_id",
              "analysis_config",
              "analysis_limits",
              "data_description",
              "description",
              "model_plot",
              "model_snapshot_id",
              "model_snapshot_retention_days",
              "results_index_name"
            ],
            query: []
          },
          "ml.validate_detector": {
            path: [],
            body: [
              "detector"
            ],
            query: []
          }
        };
      }
      async clearTrainedModelDeploymentCache(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.clear_trained_model_deployment_cache"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/cache/_clear`;
        const meta = {
          name: "ml.clear_trained_model_deployment_cache",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async closeJob(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.close_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_close`;
        const meta = {
          name: "ml.close_job",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteCalendar(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_calendar"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;
        const meta = {
          name: "ml.delete_calendar",
          pathParts: {
            calendar_id: params.calendar_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteCalendarEvent(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_calendar_event"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events/${encodeURIComponent(params.event_id.toString())}`;
        const meta = {
          name: "ml.delete_calendar_event",
          pathParts: {
            calendar_id: params.calendar_id,
            event_id: params.event_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteCalendarJob(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_calendar_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`;
        const meta = {
          name: "ml.delete_calendar_job",
          pathParts: {
            calendar_id: params.calendar_id,
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteDataFrameAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ml.delete_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteDatafeed(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_datafeed"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;
        const meta = {
          name: "ml.delete_datafeed",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteExpiredData(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.delete_expired_data"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null) {
          method = "DELETE";
          path = `/_ml/_delete_expired_data/${encodeURIComponent(params.job_id.toString())}`;
        } else {
          method = "DELETE";
          path = "/_ml/_delete_expired_data";
        }
        const meta = {
          name: "ml.delete_expired_data",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteFilter(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_filter"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;
        const meta = {
          name: "ml.delete_filter",
          pathParts: {
            filter_id: params.filter_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteForecast(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_forecast"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null && params.forecast_id != null) {
          method = "DELETE";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast/${encodeURIComponent(params.forecast_id.toString())}`;
        } else {
          method = "DELETE";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`;
        }
        const meta = {
          name: "ml.delete_forecast",
          pathParts: {
            job_id: params.job_id,
            forecast_id: params.forecast_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteJob(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;
        const meta = {
          name: "ml.delete_job",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteModelSnapshot(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_model_snapshot"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`;
        const meta = {
          name: "ml.delete_model_snapshot",
          pathParts: {
            job_id: params.job_id,
            snapshot_id: params.snapshot_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteTrainedModel(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_trained_model"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;
        const meta = {
          name: "ml.delete_trained_model",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteTrainedModelAlias(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.delete_trained_model_alias"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`;
        const meta = {
          name: "ml.delete_trained_model_alias",
          pathParts: {
            model_alias: params.model_alias,
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async estimateModelMemory(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.estimate_model_memory"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_ml/anomaly_detectors/_estimate_model_memory";
        const meta = {
          name: "ml.estimate_model_memory"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async evaluateDataFrame(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.evaluate_data_frame"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_ml/data_frame/_evaluate";
        const meta = {
          name: "ml.evaluate_data_frame"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async explainDataFrameAnalytics(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.explain_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_explain`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_ml/data_frame/analytics/_explain";
        }
        const meta = {
          name: "ml.explain_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async flushJob(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.flush_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_flush`;
        const meta = {
          name: "ml.flush_job",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async forecast(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.forecast"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`;
        const meta = {
          name: "ml.forecast",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getBuckets(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.get_buckets"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null && params.timestamp != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets/${encodeURIComponent(params.timestamp.toString())}`;
        } else {
          method = body != null ? "POST" : "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets`;
        }
        const meta = {
          name: "ml.get_buckets",
          pathParts: {
            job_id: params.job_id,
            timestamp: params.timestamp
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getCalendarEvents(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_calendar_events"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`;
        const meta = {
          name: "ml.get_calendar_events",
          pathParts: {
            calendar_id: params.calendar_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getCalendars(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.get_calendars"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.calendar_id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_ml/calendars";
        }
        const meta = {
          name: "ml.get_calendars",
          pathParts: {
            calendar_id: params.calendar_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getCategories(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.get_categories"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null && params.category_id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories/${encodeURIComponent(params.category_id.toString())}`;
        } else {
          method = body != null ? "POST" : "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories`;
        }
        const meta = {
          name: "ml.get_categories",
          pathParts: {
            job_id: params.job_id,
            category_id: params.category_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getDataFrameAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_ml/data_frame/analytics";
        }
        const meta = {
          name: "ml.get_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getDataFrameAnalyticsStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_data_frame_analytics_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stats`;
        } else {
          method = "GET";
          path = "/_ml/data_frame/analytics/_stats";
        }
        const meta = {
          name: "ml.get_data_frame_analytics_stats",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getDatafeedStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_datafeed_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.datafeed_id != null) {
          method = "GET";
          path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stats`;
        } else {
          method = "GET";
          path = "/_ml/datafeeds/_stats";
        }
        const meta = {
          name: "ml.get_datafeed_stats",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getDatafeeds(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_datafeeds"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.datafeed_id != null) {
          method = "GET";
          path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;
        } else {
          method = "GET";
          path = "/_ml/datafeeds";
        }
        const meta = {
          name: "ml.get_datafeeds",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getFilters(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_filters"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.filter_id != null) {
          method = "GET";
          path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;
        } else {
          method = "GET";
          path = "/_ml/filters";
        }
        const meta = {
          name: "ml.get_filters",
          pathParts: {
            filter_id: params.filter_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getInfluencers(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.get_influencers"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/influencers`;
        const meta = {
          name: "ml.get_influencers",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getJobStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_job_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null) {
          method = "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_stats`;
        } else {
          method = "GET";
          path = "/_ml/anomaly_detectors/_stats";
        }
        const meta = {
          name: "ml.get_job_stats",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getJobs(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_jobs"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null) {
          method = "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;
        } else {
          method = "GET";
          path = "/_ml/anomaly_detectors";
        }
        const meta = {
          name: "ml.get_jobs",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getMemoryStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_memory_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null) {
          method = "GET";
          path = `/_ml/memory/${encodeURIComponent(params.node_id.toString())}/_stats`;
        } else {
          method = "GET";
          path = "/_ml/memory/_stats";
        }
        const meta = {
          name: "ml.get_memory_stats",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getModelSnapshotUpgradeStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_model_snapshot_upgrade_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade/_stats`;
        const meta = {
          name: "ml.get_model_snapshot_upgrade_stats",
          pathParts: {
            job_id: params.job_id,
            snapshot_id: params.snapshot_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getModelSnapshots(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.get_model_snapshots"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.job_id != null && params.snapshot_id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`;
        } else {
          method = body != null ? "POST" : "GET";
          path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots`;
        }
        const meta = {
          name: "ml.get_model_snapshots",
          pathParts: {
            job_id: params.job_id,
            snapshot_id: params.snapshot_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getOverallBuckets(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.get_overall_buckets"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/overall_buckets`;
        const meta = {
          name: "ml.get_overall_buckets",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRecords(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.get_records"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/records`;
        const meta = {
          name: "ml.get_records",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getTrainedModels(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_trained_models"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.model_id != null) {
          method = "GET";
          path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;
        } else {
          method = "GET";
          path = "/_ml/trained_models";
        }
        const meta = {
          name: "ml.get_trained_models",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getTrainedModelsStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.get_trained_models_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.model_id != null) {
          method = "GET";
          path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_stats`;
        } else {
          method = "GET";
          path = "/_ml/trained_models/_stats";
        }
        const meta = {
          name: "ml.get_trained_models_stats",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async inferTrainedModel(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.infer_trained_model"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_infer`;
        const meta = {
          name: "ml.infer_trained_model",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async info(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.info"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_ml/info";
        const meta = {
          name: "ml.info"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async openJob(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.open_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_open`;
        const meta = {
          name: "ml.open_job",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async postCalendarEvents(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.post_calendar_events"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`;
        const meta = {
          name: "ml.post_calendar_events",
          pathParts: {
            calendar_id: params.calendar_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async postData(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.post_data"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_data`;
        const meta = {
          name: "ml.post_data",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);
      }
      async previewDataFrameAnalytics(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.preview_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_preview`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_ml/data_frame/analytics/_preview";
        }
        const meta = {
          name: "ml.preview_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async previewDatafeed(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.preview_datafeed"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.datafeed_id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_preview`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_ml/datafeeds/_preview";
        }
        const meta = {
          name: "ml.preview_datafeed",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putCalendar(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_calendar"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;
        const meta = {
          name: "ml.put_calendar",
          pathParts: {
            calendar_id: params.calendar_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putCalendarJob(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.put_calendar_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`;
        const meta = {
          name: "ml.put_calendar_job",
          pathParts: {
            calendar_id: params.calendar_id,
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putDataFrameAnalytics(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "ml.put_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putDatafeed(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_datafeed"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;
        const meta = {
          name: "ml.put_datafeed",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putFilter(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_filter"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;
        const meta = {
          name: "ml.put_filter",
          pathParts: {
            filter_id: params.filter_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putJob(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;
        const meta = {
          name: "ml.put_job",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putTrainedModel(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_trained_model"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;
        const meta = {
          name: "ml.put_trained_model",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putTrainedModelAlias(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.put_trained_model_alias"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`;
        const meta = {
          name: "ml.put_trained_model_alias",
          pathParts: {
            model_alias: params.model_alias,
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putTrainedModelDefinitionPart(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_trained_model_definition_part"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/definition/${encodeURIComponent(params.part.toString())}`;
        const meta = {
          name: "ml.put_trained_model_definition_part",
          pathParts: {
            model_id: params.model_id,
            part: params.part
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putTrainedModelVocabulary(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.put_trained_model_vocabulary"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/vocabulary`;
        const meta = {
          name: "ml.put_trained_model_vocabulary",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async resetJob(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.reset_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_reset`;
        const meta = {
          name: "ml.reset_job",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async revertModelSnapshot(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.revert_model_snapshot"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_revert`;
        const meta = {
          name: "ml.revert_model_snapshot",
          pathParts: {
            job_id: params.job_id,
            snapshot_id: params.snapshot_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async setUpgradeMode(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.set_upgrade_mode"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_ml/set_upgrade_mode";
        const meta = {
          name: "ml.set_upgrade_mode"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async startDataFrameAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.start_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_start`;
        const meta = {
          name: "ml.start_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async startDatafeed(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.start_datafeed"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_start`;
        const meta = {
          name: "ml.start_datafeed",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async startTrainedModelDeployment(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.start_trained_model_deployment"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_start`;
        const meta = {
          name: "ml.start_trained_model_deployment",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stopDataFrameAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.stop_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stop`;
        const meta = {
          name: "ml.stop_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stopDatafeed(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.stop_datafeed"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stop`;
        const meta = {
          name: "ml.stop_datafeed",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stopTrainedModelDeployment(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.stop_trained_model_deployment"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_stop`;
        const meta = {
          name: "ml.stop_trained_model_deployment",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateDataFrameAnalytics(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.update_data_frame_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_update`;
        const meta = {
          name: "ml.update_data_frame_analytics",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateDatafeed(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.update_datafeed"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_update`;
        const meta = {
          name: "ml.update_datafeed",
          pathParts: {
            datafeed_id: params.datafeed_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateFilter(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.update_filter"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}/_update`;
        const meta = {
          name: "ml.update_filter",
          pathParts: {
            filter_id: params.filter_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateJob(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.update_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_update`;
        const meta = {
          name: "ml.update_job",
          pathParts: {
            job_id: params.job_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateModelSnapshot(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.update_model_snapshot"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_update`;
        const meta = {
          name: "ml.update_model_snapshot",
          pathParts: {
            job_id: params.job_id,
            snapshot_id: params.snapshot_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateTrainedModelDeployment(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.update_trained_model_deployment"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_update`;
        const meta = {
          name: "ml.update_trained_model_deployment",
          pathParts: {
            model_id: params.model_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async upgradeJobSnapshot(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ml.upgrade_job_snapshot"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade`;
        const meta = {
          name: "ml.upgrade_job_snapshot",
          pathParts: {
            job_id: params.job_id,
            snapshot_id: params.snapshot_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async validate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.validate"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_ml/anomaly_detectors/_validate";
        const meta = {
          name: "ml.validate"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async validateDetector(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["ml.validate_detector"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_ml/anomaly_detectors/_validate/detector";
        const meta = {
          name: "ml.validate_detector"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Ml;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js
var require_monitoring = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Monitoring = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "monitoring.bulk": {
            path: [
              "type"
            ],
            body: [
              "operations"
            ],
            query: [
              "system_id",
              "system_api_version",
              "interval"
            ]
          }
        };
      }
      async bulk(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["monitoring.bulk"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_monitoring/bulk";
        const meta = {
          name: "monitoring.bulk",
          pathParts: {
            type: params.type
          }
        };
        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);
      }
    };
    exports2.default = Monitoring;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/msearch.js
var require_msearch = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/msearch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = MsearchApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      msearch: {
        path: [
          "index"
        ],
        body: [
          "searches"
        ],
        query: [
          "allow_no_indices",
          "ccs_minimize_roundtrips",
          "expand_wildcards",
          "ignore_throttled",
          "ignore_unavailable",
          "include_named_queries_score",
          "max_concurrent_searches",
          "max_concurrent_shard_requests",
          "pre_filter_shard_size",
          "rest_total_hits_as_int",
          "routing",
          "search_type",
          "typed_keys"
        ]
      }
    };
    async function MsearchApi(params, options) {
      var _a;
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.msearch;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_msearch`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_msearch";
      }
      const meta = {
        name: "msearch",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js
var require_msearch_template = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = MsearchTemplateApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      msearch_template: {
        path: [
          "index"
        ],
        body: [
          "search_templates"
        ],
        query: [
          "ccs_minimize_roundtrips",
          "max_concurrent_searches",
          "search_type",
          "rest_total_hits_as_int",
          "typed_keys"
        ]
      }
    };
    async function MsearchTemplateApi(params, options) {
      var _a;
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.msearch_template;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_msearch/template`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_msearch/template";
      }
      const meta = {
        name: "msearch_template",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js
var require_mtermvectors = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = MtermvectorsApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      mtermvectors: {
        path: [
          "index"
        ],
        body: [
          "docs",
          "ids"
        ],
        query: [
          "ids",
          "fields",
          "field_statistics",
          "offsets",
          "payloads",
          "positions",
          "preference",
          "realtime",
          "routing",
          "term_statistics",
          "version",
          "version_type"
        ]
      }
    };
    async function MtermvectorsApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.mtermvectors;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_mtermvectors`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_mtermvectors";
      }
      const meta = {
        name: "mtermvectors",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/nodes.js
var require_nodes = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/nodes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Nodes = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "nodes.clear_repositories_metering_archive": {
            path: [
              "node_id",
              "max_archive_version"
            ],
            body: [],
            query: []
          },
          "nodes.get_repositories_metering_info": {
            path: [
              "node_id"
            ],
            body: [],
            query: []
          },
          "nodes.hot_threads": {
            path: [
              "node_id"
            ],
            body: [],
            query: [
              "ignore_idle_threads",
              "interval",
              "snapshots",
              "threads",
              "timeout",
              "type",
              "sort"
            ]
          },
          "nodes.info": {
            path: [
              "node_id",
              "metric"
            ],
            body: [],
            query: [
              "flat_settings",
              "timeout"
            ]
          },
          "nodes.reload_secure_settings": {
            path: [
              "node_id"
            ],
            body: [
              "secure_settings_password"
            ],
            query: [
              "timeout"
            ]
          },
          "nodes.stats": {
            path: [
              "node_id",
              "metric",
              "index_metric"
            ],
            body: [],
            query: [
              "completion_fields",
              "fielddata_fields",
              "fields",
              "groups",
              "include_segment_file_sizes",
              "level",
              "timeout",
              "types",
              "include_unloaded_segments"
            ]
          },
          "nodes.usage": {
            path: [
              "node_id",
              "metric"
            ],
            body: [],
            query: [
              "timeout"
            ]
          }
        };
      }
      async clearRepositoriesMeteringArchive(params, options) {
        const { path: acceptedPath } = this.acceptedParams["nodes.clear_repositories_metering_archive"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering/${encodeURIComponent(params.max_archive_version.toString())}`;
        const meta = {
          name: "nodes.clear_repositories_metering_archive",
          pathParts: {
            node_id: params.node_id,
            max_archive_version: params.max_archive_version
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRepositoriesMeteringInfo(params, options) {
        const { path: acceptedPath } = this.acceptedParams["nodes.get_repositories_metering_info"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering`;
        const meta = {
          name: "nodes.get_repositories_metering_info",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async hotThreads(params, options) {
        const { path: acceptedPath } = this.acceptedParams["nodes.hot_threads"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/hot_threads`;
        } else {
          method = "GET";
          path = "/_nodes/hot_threads";
        }
        const meta = {
          name: "nodes.hot_threads",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async info(params, options) {
        const { path: acceptedPath } = this.acceptedParams["nodes.info"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null && params.metric != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.node_id != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}`;
        } else if (params.metric != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.metric.toString())}`;
        } else {
          method = "GET";
          path = "/_nodes";
        }
        const meta = {
          name: "nodes.info",
          pathParts: {
            node_id: params.node_id,
            metric: params.metric
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async reloadSecureSettings(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["nodes.reload_secure_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null) {
          method = "POST";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/reload_secure_settings`;
        } else {
          method = "POST";
          path = "/_nodes/reload_secure_settings";
        }
        const meta = {
          name: "nodes.reload_secure_settings",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["nodes.stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null && params.metric != null && params.index_metric != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;
        } else if (params.node_id != null && params.metric != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.metric != null && params.index_metric != null) {
          method = "GET";
          path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;
        } else if (params.node_id != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats`;
        } else if (params.metric != null) {
          method = "GET";
          path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}`;
        } else {
          method = "GET";
          path = "/_nodes/stats";
        }
        const meta = {
          name: "nodes.stats",
          pathParts: {
            node_id: params.node_id,
            metric: params.metric,
            index_metric: params.index_metric
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async usage(params, options) {
        const { path: acceptedPath } = this.acceptedParams["nodes.usage"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null && params.metric != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage/${encodeURIComponent(params.metric.toString())}`;
        } else if (params.node_id != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage`;
        } else if (params.metric != null) {
          method = "GET";
          path = `/_nodes/usage/${encodeURIComponent(params.metric.toString())}`;
        } else {
          method = "GET";
          path = "/_nodes/usage";
        }
        const meta = {
          name: "nodes.usage",
          pathParts: {
            node_id: params.node_id,
            metric: params.metric
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Nodes;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js
var require_open_point_in_time = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = OpenPointInTimeApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      open_point_in_time: {
        path: [
          "index"
        ],
        body: [
          "index_filter"
        ],
        query: [
          "keep_alive",
          "ignore_unavailable",
          "preference",
          "routing",
          "expand_wildcards",
          "allow_partial_search_results",
          "max_concurrent_shard_requests"
        ]
      }
    };
    async function OpenPointInTimeApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.open_point_in_time;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "POST";
      const path = `/${encodeURIComponent(params.index.toString())}/_pit`;
      const meta = {
        name: "open_point_in_time",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/ping.js
var require_ping = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/ping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = PingApi;
    var acceptedParams = {
      ping: {
        path: [],
        body: [],
        query: []
      }
    };
    async function PingApi(params, options) {
      const { path: acceptedPath } = acceptedParams.ping;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "HEAD";
      const path = "/";
      const meta = {
        name: "ping"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/profiling.js
var require_profiling = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/profiling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Profiling = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "profiling.flamegraph": {
            path: [],
            body: [],
            query: []
          },
          "profiling.stacktraces": {
            path: [],
            body: [],
            query: []
          },
          "profiling.status": {
            path: [],
            body: [],
            query: []
          },
          "profiling.topn_functions": {
            path: [],
            body: [],
            query: []
          }
        };
      }
      async flamegraph(params, options) {
        const { path: acceptedPath } = this.acceptedParams["profiling.flamegraph"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_profiling/flamegraph";
        const meta = {
          name: "profiling.flamegraph"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stacktraces(params, options) {
        const { path: acceptedPath } = this.acceptedParams["profiling.stacktraces"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_profiling/stacktraces";
        const meta = {
          name: "profiling.stacktraces"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async status(params, options) {
        const { path: acceptedPath } = this.acceptedParams["profiling.status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_profiling/status";
        const meta = {
          name: "profiling.status"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async topnFunctions(params, options) {
        const { path: acceptedPath } = this.acceptedParams["profiling.topn_functions"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_profiling/topn/functions";
        const meta = {
          name: "profiling.topn_functions"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Profiling;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/put_script.js
var require_put_script = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/put_script.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = PutScriptApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      put_script: {
        path: [
          "id",
          "context"
        ],
        body: [
          "script"
        ],
        query: [
          "context",
          "master_timeout",
          "timeout"
        ]
      }
    };
    async function PutScriptApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.put_script;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.id != null && params.context != null) {
        method = "PUT";
        path = `/_scripts/${encodeURIComponent(params.id.toString())}/${encodeURIComponent(params.context.toString())}`;
      } else {
        method = "PUT";
        path = `/_scripts/${encodeURIComponent(params.id.toString())}`;
      }
      const meta = {
        name: "put_script",
        pathParts: {
          id: params.id,
          context: params.context
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/query_rules.js
var require_query_rules = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/query_rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var QueryRules = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "query_rules.delete_rule": {
            path: [
              "ruleset_id",
              "rule_id"
            ],
            body: [],
            query: []
          },
          "query_rules.delete_ruleset": {
            path: [
              "ruleset_id"
            ],
            body: [],
            query: []
          },
          "query_rules.get_rule": {
            path: [
              "ruleset_id",
              "rule_id"
            ],
            body: [],
            query: []
          },
          "query_rules.get_ruleset": {
            path: [
              "ruleset_id"
            ],
            body: [],
            query: []
          },
          "query_rules.list_rulesets": {
            path: [],
            body: [],
            query: [
              "from",
              "size"
            ]
          },
          "query_rules.put_rule": {
            path: [
              "ruleset_id",
              "rule_id"
            ],
            body: [
              "type",
              "criteria",
              "actions",
              "priority"
            ],
            query: []
          },
          "query_rules.put_ruleset": {
            path: [
              "ruleset_id"
            ],
            body: [
              "rules"
            ],
            query: []
          },
          "query_rules.test": {
            path: [
              "ruleset_id"
            ],
            body: [
              "match_criteria"
            ],
            query: []
          }
        };
      }
      async deleteRule(params, options) {
        const { path: acceptedPath } = this.acceptedParams["query_rules.delete_rule"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
          name: "query_rules.delete_rule",
          pathParts: {
            ruleset_id: params.ruleset_id,
            rule_id: params.rule_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteRuleset(params, options) {
        const { path: acceptedPath } = this.acceptedParams["query_rules.delete_ruleset"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;
        const meta = {
          name: "query_rules.delete_ruleset",
          pathParts: {
            ruleset_id: params.ruleset_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRule(params, options) {
        const { path: acceptedPath } = this.acceptedParams["query_rules.get_rule"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
          name: "query_rules.get_rule",
          pathParts: {
            ruleset_id: params.ruleset_id,
            rule_id: params.rule_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRuleset(params, options) {
        const { path: acceptedPath } = this.acceptedParams["query_rules.get_ruleset"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;
        const meta = {
          name: "query_rules.get_ruleset",
          pathParts: {
            ruleset_id: params.ruleset_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async listRulesets(params, options) {
        const { path: acceptedPath } = this.acceptedParams["query_rules.list_rulesets"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_query_rules";
        const meta = {
          name: "query_rules.list_rulesets"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putRule(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["query_rules.put_rule"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
          name: "query_rules.put_rule",
          pathParts: {
            ruleset_id: params.ruleset_id,
            rule_id: params.rule_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putRuleset(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["query_rules.put_ruleset"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;
        const meta = {
          name: "query_rules.put_ruleset",
          pathParts: {
            ruleset_id: params.ruleset_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async test(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["query_rules.test"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_test`;
        const meta = {
          name: "query_rules.test",
          pathParts: {
            ruleset_id: params.ruleset_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = QueryRules;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js
var require_rank_eval = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = RankEvalApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      rank_eval: {
        path: [
          "index"
        ],
        body: [
          "requests",
          "metric"
        ],
        query: [
          "allow_no_indices",
          "expand_wildcards",
          "ignore_unavailable",
          "search_type"
        ]
      }
    };
    async function RankEvalApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.rank_eval;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_rank_eval`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_rank_eval";
      }
      const meta = {
        name: "rank_eval",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/reindex.js
var require_reindex = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/reindex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ReindexApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      reindex: {
        path: [],
        body: [
          "conflicts",
          "dest",
          "max_docs",
          "script",
          "size",
          "source"
        ],
        query: [
          "refresh",
          "requests_per_second",
          "scroll",
          "slices",
          "timeout",
          "wait_for_active_shards",
          "wait_for_completion",
          "require_alias"
        ]
      }
    };
    async function ReindexApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.reindex;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "POST";
      const path = "/_reindex";
      const meta = {
        name: "reindex"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js
var require_reindex_rethrottle = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ReindexRethrottleApi;
    var acceptedParams = {
      reindex_rethrottle: {
        path: [
          "task_id"
        ],
        body: [],
        query: [
          "requests_per_second"
        ]
      }
    };
    async function ReindexRethrottleApi(params, options) {
      const { path: acceptedPath } = acceptedParams.reindex_rethrottle;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "POST";
      const path = `/_reindex/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;
      const meta = {
        name: "reindex_rethrottle",
        pathParts: {
          task_id: params.task_id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js
var require_render_search_template = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = RenderSearchTemplateApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      render_search_template: {
        path: [],
        body: [
          "id",
          "file",
          "params",
          "source"
        ],
        query: []
      }
    };
    async function RenderSearchTemplateApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.render_search_template;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.id != null) {
        method = body != null ? "POST" : "GET";
        path = `/_render/template/${encodeURIComponent(params.id.toString())}`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_render/template";
      }
      const meta = {
        name: "render_search_template",
        pathParts: {
          id: params.id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/rollup.js
var require_rollup = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/rollup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Rollup = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "rollup.delete_job": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "rollup.get_jobs": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "rollup.get_rollup_caps": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "rollup.get_rollup_index_caps": {
            path: [
              "index"
            ],
            body: [],
            query: []
          },
          "rollup.put_job": {
            path: [
              "id"
            ],
            body: [
              "cron",
              "groups",
              "index_pattern",
              "metrics",
              "page_size",
              "rollup_index",
              "timeout",
              "headers"
            ],
            query: []
          },
          "rollup.rollup_search": {
            path: [
              "index"
            ],
            body: [
              "aggregations",
              "aggs",
              "query",
              "size"
            ],
            query: [
              "rest_total_hits_as_int",
              "typed_keys"
            ]
          },
          "rollup.start_job": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "rollup.stop_job": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "timeout",
              "wait_for_completion"
            ]
          }
        };
      }
      async deleteJob(params, options) {
        const { path: acceptedPath } = this.acceptedParams["rollup.delete_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "rollup.delete_job",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getJobs(params, options) {
        const { path: acceptedPath } = this.acceptedParams["rollup.get_jobs"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_rollup/job";
        }
        const meta = {
          name: "rollup.get_jobs",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRollupCaps(params, options) {
        const { path: acceptedPath } = this.acceptedParams["rollup.get_rollup_caps"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "GET";
          path = `/_rollup/data/${encodeURIComponent(params.id.toString())}`;
        } else {
          method = "GET";
          path = "/_rollup/data";
        }
        const meta = {
          name: "rollup.get_rollup_caps",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRollupIndexCaps(params, options) {
        const { path: acceptedPath } = this.acceptedParams["rollup.get_rollup_index_caps"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_rollup/data`;
        const meta = {
          name: "rollup.get_rollup_index_caps",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putJob(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["rollup.put_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "rollup.put_job",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async rollupSearch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["rollup.rollup_search"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/${encodeURIComponent(params.index.toString())}/_rollup_search`;
        const meta = {
          name: "rollup.rollup_search",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async startJob(params, options) {
        const { path: acceptedPath } = this.acceptedParams["rollup.start_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_start`;
        const meta = {
          name: "rollup.start_job",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stopJob(params, options) {
        const { path: acceptedPath } = this.acceptedParams["rollup.stop_job"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_stop`;
        const meta = {
          name: "rollup.stop_job",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Rollup;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js
var require_scripts_painless_execute = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ScriptsPainlessExecuteApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      scripts_painless_execute: {
        path: [],
        body: [
          "context",
          "context_setup",
          "script"
        ],
        query: []
      }
    };
    async function ScriptsPainlessExecuteApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.scripts_painless_execute;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = body != null ? "POST" : "GET";
      const path = "/_scripts/painless/_execute";
      const meta = {
        name: "scripts_painless_execute"
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/scroll.js
var require_scroll = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/scroll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = ScrollApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      scroll: {
        path: [],
        body: [
          "scroll",
          "scroll_id"
        ],
        query: [
          "scroll",
          "scroll_id",
          "rest_total_hits_as_int"
        ]
      }
    };
    async function ScrollApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.scroll;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = body != null ? "POST" : "GET";
      const path = "/_search/scroll";
      const meta = {
        name: "scroll",
        pathParts: {
          scroll_id: params.scroll_id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/search.js
var require_search = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/search.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = SearchApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      search: {
        path: [
          "index"
        ],
        body: [
          "aggregations",
          "aggs",
          "collapse",
          "explain",
          "ext",
          "from",
          "highlight",
          "track_total_hits",
          "indices_boost",
          "docvalue_fields",
          "knn",
          "rank",
          "min_score",
          "post_filter",
          "profile",
          "query",
          "rescore",
          "retriever",
          "script_fields",
          "search_after",
          "size",
          "slice",
          "sort",
          "_source",
          "fields",
          "suggest",
          "terminate_after",
          "timeout",
          "track_scores",
          "version",
          "seq_no_primary_term",
          "stored_fields",
          "pit",
          "runtime_mappings",
          "stats"
        ],
        query: [
          "allow_no_indices",
          "allow_partial_search_results",
          "analyzer",
          "analyze_wildcard",
          "batched_reduce_size",
          "ccs_minimize_roundtrips",
          "default_operator",
          "df",
          "docvalue_fields",
          "expand_wildcards",
          "explain",
          "ignore_throttled",
          "ignore_unavailable",
          "include_named_queries_score",
          "lenient",
          "max_concurrent_shard_requests",
          "preference",
          "pre_filter_shard_size",
          "request_cache",
          "routing",
          "scroll",
          "search_type",
          "stats",
          "stored_fields",
          "suggest_field",
          "suggest_mode",
          "suggest_size",
          "suggest_text",
          "terminate_after",
          "timeout",
          "track_total_hits",
          "track_scores",
          "typed_keys",
          "rest_total_hits_as_int",
          "version",
          "_source",
          "_source_excludes",
          "_source_includes",
          "seq_no_primary_term",
          "q",
          "size",
          "from",
          "sort",
          "force_synthetic_source"
        ]
      }
    };
    async function SearchApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.search;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          if (key === "sort" && typeof params[key] === "string" && params[key].includes(":")) {
            querystring[key] = params[key];
          } else {
            body[key] = params[key];
          }
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_search`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_search";
      }
      const meta = {
        name: "search",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/search_application.js
var require_search_application = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/search_application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var SearchApplication = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "search_application.delete": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "search_application.delete_behavioral_analytics": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "search_application.get": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "search_application.get_behavioral_analytics": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "search_application.list": {
            path: [],
            body: [],
            query: [
              "q",
              "from",
              "size"
            ]
          },
          "search_application.post_behavioral_analytics_event": {
            path: [
              "collection_name",
              "event_type"
            ],
            body: [
              "payload"
            ],
            query: [
              "debug"
            ]
          },
          "search_application.put": {
            path: [
              "name"
            ],
            body: [
              "search_application"
            ],
            query: [
              "create"
            ]
          },
          "search_application.put_behavioral_analytics": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "search_application.render_query": {
            path: [
              "name"
            ],
            body: [
              "params"
            ],
            query: []
          },
          "search_application.search": {
            path: [
              "name"
            ],
            body: [
              "params"
            ],
            query: [
              "typed_keys"
            ]
          }
        };
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["search_application.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "search_application.delete",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteBehavioralAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["search_application.delete_behavioral_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "search_application.delete_behavioral_analytics",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["search_application.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "search_application.get",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getBehavioralAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["search_application.get_behavioral_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_application/analytics";
        }
        const meta = {
          name: "search_application.get_behavioral_analytics",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async list(params, options) {
        const { path: acceptedPath } = this.acceptedParams["search_application.list"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_application/search_application";
        const meta = {
          name: "search_application.list"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async postBehavioralAnalyticsEvent(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["search_application.post_behavioral_analytics_event"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_application/analytics/${encodeURIComponent(params.collection_name.toString())}/event/${encodeURIComponent(params.event_type.toString())}`;
        const meta = {
          name: "search_application.post_behavioral_analytics_event",
          pathParts: {
            collection_name: params.collection_name,
            event_type: params.event_type
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async put(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["search_application.put"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "search_application.put",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putBehavioralAnalytics(params, options) {
        const { path: acceptedPath } = this.acceptedParams["search_application.put_behavioral_analytics"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "search_application.put_behavioral_analytics",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async renderQuery(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["search_application.render_query"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}/_render_query`;
        const meta = {
          name: "search_application.render_query",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async search(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["search_application.search"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}/_search`;
        const meta = {
          name: "search_application.search",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = SearchApplication;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js
var require_search_mvt = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = SearchMvtApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      search_mvt: {
        path: [
          "index",
          "field",
          "zoom",
          "x",
          "y"
        ],
        body: [
          "aggs",
          "buffer",
          "exact_bounds",
          "extent",
          "fields",
          "grid_agg",
          "grid_precision",
          "grid_type",
          "query",
          "runtime_mappings",
          "size",
          "sort",
          "track_total_hits",
          "with_labels"
        ],
        query: [
          "exact_bounds",
          "extent",
          "grid_agg",
          "grid_precision",
          "grid_type",
          "size",
          "with_labels"
        ]
      }
    };
    async function SearchMvtApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.search_mvt;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = body != null ? "POST" : "GET";
      const path = `/${encodeURIComponent(params.index.toString())}/_mvt/${encodeURIComponent(params.field.toString())}/${encodeURIComponent(params.zoom.toString())}/${encodeURIComponent(params.x.toString())}/${encodeURIComponent(params.y.toString())}`;
      const meta = {
        name: "search_mvt",
        pathParts: {
          index: params.index,
          field: params.field,
          zoom: params.zoom,
          x: params.x,
          y: params.y
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js
var require_search_shards = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = SearchShardsApi;
    var acceptedParams = {
      search_shards: {
        path: [
          "index"
        ],
        body: [],
        query: [
          "allow_no_indices",
          "expand_wildcards",
          "ignore_unavailable",
          "local",
          "master_timeout",
          "preference",
          "routing"
        ]
      }
    };
    async function SearchShardsApi(params, options) {
      const { path: acceptedPath } = acceptedParams.search_shards;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_search_shards`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_search_shards";
      }
      const meta = {
        name: "search_shards",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/search_template.js
var require_search_template = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/search_template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = SearchTemplateApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      search_template: {
        path: [
          "index"
        ],
        body: [
          "explain",
          "id",
          "params",
          "profile",
          "source"
        ],
        query: [
          "allow_no_indices",
          "ccs_minimize_roundtrips",
          "expand_wildcards",
          "explain",
          "ignore_throttled",
          "ignore_unavailable",
          "preference",
          "profile",
          "routing",
          "scroll",
          "search_type",
          "rest_total_hits_as_int",
          "typed_keys"
        ]
      }
    };
    async function SearchTemplateApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.search_template;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      params = params !== null && params !== void 0 ? params : {};
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_search/template`;
      } else {
        method = body != null ? "POST" : "GET";
        path = "/_search/template";
      }
      const meta = {
        name: "search_template",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js
var require_searchable_snapshots = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var SearchableSnapshots = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "searchable_snapshots.cache_stats": {
            path: [
              "node_id"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "searchable_snapshots.clear_cache": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "expand_wildcards",
              "allow_no_indices",
              "ignore_unavailable"
            ]
          },
          "searchable_snapshots.mount": {
            path: [
              "repository",
              "snapshot"
            ],
            body: [
              "index",
              "renamed_index",
              "index_settings",
              "ignore_index_settings"
            ],
            query: [
              "master_timeout",
              "wait_for_completion",
              "storage"
            ]
          },
          "searchable_snapshots.stats": {
            path: [
              "index"
            ],
            body: [],
            query: [
              "level"
            ]
          }
        };
      }
      async cacheStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["searchable_snapshots.cache_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null) {
          method = "GET";
          path = `/_searchable_snapshots/${encodeURIComponent(params.node_id.toString())}/cache/stats`;
        } else {
          method = "GET";
          path = "/_searchable_snapshots/cache/stats";
        }
        const meta = {
          name: "searchable_snapshots.cache_stats",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clearCache(params, options) {
        const { path: acceptedPath } = this.acceptedParams["searchable_snapshots.clear_cache"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "POST";
          path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/cache/clear`;
        } else {
          method = "POST";
          path = "/_searchable_snapshots/cache/clear";
        }
        const meta = {
          name: "searchable_snapshots.clear_cache",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async mount(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["searchable_snapshots.mount"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_mount`;
        const meta = {
          name: "searchable_snapshots.mount",
          pathParts: {
            repository: params.repository,
            snapshot: params.snapshot
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["searchable_snapshots.stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = "GET";
          path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/stats`;
        } else {
          method = "GET";
          path = "/_searchable_snapshots/stats";
        }
        const meta = {
          name: "searchable_snapshots.stats",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = SearchableSnapshots;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/security.js
var require_security2 = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/security.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Security = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "security.activate_user_profile": {
            path: [],
            body: [
              "access_token",
              "grant_type",
              "password",
              "username"
            ],
            query: []
          },
          "security.authenticate": {
            path: [],
            body: [],
            query: []
          },
          "security.bulk_delete_role": {
            path: [],
            body: [
              "names"
            ],
            query: [
              "refresh"
            ]
          },
          "security.bulk_put_role": {
            path: [],
            body: [
              "roles"
            ],
            query: [
              "refresh"
            ]
          },
          "security.bulk_update_api_keys": {
            path: [],
            body: [
              "expiration",
              "ids",
              "metadata",
              "role_descriptors"
            ],
            query: []
          },
          "security.change_password": {
            path: [
              "username"
            ],
            body: [
              "password",
              "password_hash"
            ],
            query: [
              "refresh"
            ]
          },
          "security.clear_api_key_cache": {
            path: [
              "ids"
            ],
            body: [],
            query: []
          },
          "security.clear_cached_privileges": {
            path: [
              "application"
            ],
            body: [],
            query: []
          },
          "security.clear_cached_realms": {
            path: [
              "realms"
            ],
            body: [],
            query: [
              "usernames"
            ]
          },
          "security.clear_cached_roles": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "security.clear_cached_service_tokens": {
            path: [
              "namespace",
              "service",
              "name"
            ],
            body: [],
            query: []
          },
          "security.create_api_key": {
            path: [],
            body: [
              "expiration",
              "name",
              "role_descriptors",
              "metadata"
            ],
            query: [
              "refresh"
            ]
          },
          "security.create_cross_cluster_api_key": {
            path: [],
            body: [
              "access",
              "expiration",
              "metadata",
              "name"
            ],
            query: []
          },
          "security.create_service_token": {
            path: [
              "namespace",
              "service",
              "name"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.delegate_pki": {
            path: [],
            body: [
              "x509_certificate_chain"
            ],
            query: []
          },
          "security.delete_privileges": {
            path: [
              "application",
              "name"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.delete_role": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.delete_role_mapping": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.delete_service_token": {
            path: [
              "namespace",
              "service",
              "name"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.delete_user": {
            path: [
              "username"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.disable_user": {
            path: [
              "username"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.disable_user_profile": {
            path: [
              "uid"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.enable_user": {
            path: [
              "username"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.enable_user_profile": {
            path: [
              "uid"
            ],
            body: [],
            query: [
              "refresh"
            ]
          },
          "security.enroll_kibana": {
            path: [],
            body: [],
            query: []
          },
          "security.enroll_node": {
            path: [],
            body: [],
            query: []
          },
          "security.get_api_key": {
            path: [],
            body: [],
            query: [
              "id",
              "name",
              "owner",
              "realm_name",
              "username",
              "with_limited_by",
              "active_only",
              "with_profile_uid"
            ]
          },
          "security.get_builtin_privileges": {
            path: [],
            body: [],
            query: []
          },
          "security.get_privileges": {
            path: [
              "application",
              "name"
            ],
            body: [],
            query: []
          },
          "security.get_role": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "security.get_role_mapping": {
            path: [
              "name"
            ],
            body: [],
            query: []
          },
          "security.get_service_accounts": {
            path: [
              "namespace",
              "service"
            ],
            body: [],
            query: []
          },
          "security.get_service_credentials": {
            path: [
              "namespace",
              "service"
            ],
            body: [],
            query: []
          },
          "security.get_settings": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "security.get_token": {
            path: [],
            body: [
              "grant_type",
              "scope",
              "password",
              "kerberos_ticket",
              "refresh_token",
              "username"
            ],
            query: []
          },
          "security.get_user": {
            path: [
              "username"
            ],
            body: [],
            query: [
              "with_profile_uid"
            ]
          },
          "security.get_user_privileges": {
            path: [],
            body: [],
            query: [
              "application",
              "priviledge",
              "username"
            ]
          },
          "security.get_user_profile": {
            path: [
              "uid"
            ],
            body: [],
            query: [
              "data"
            ]
          },
          "security.grant_api_key": {
            path: [],
            body: [
              "api_key",
              "grant_type",
              "access_token",
              "username",
              "password",
              "run_as"
            ],
            query: []
          },
          "security.has_privileges": {
            path: [
              "user"
            ],
            body: [
              "application",
              "cluster",
              "index"
            ],
            query: []
          },
          "security.has_privileges_user_profile": {
            path: [],
            body: [
              "uids",
              "privileges"
            ],
            query: []
          },
          "security.invalidate_api_key": {
            path: [],
            body: [
              "id",
              "ids",
              "name",
              "owner",
              "realm_name",
              "username"
            ],
            query: []
          },
          "security.invalidate_token": {
            path: [],
            body: [
              "token",
              "refresh_token",
              "realm_name",
              "username"
            ],
            query: []
          },
          "security.oidc_authenticate": {
            path: [],
            body: [
              "nonce",
              "realm",
              "redirect_uri",
              "state"
            ],
            query: []
          },
          "security.oidc_logout": {
            path: [],
            body: [
              "token",
              "refresh_token"
            ],
            query: []
          },
          "security.oidc_prepare_authentication": {
            path: [],
            body: [
              "iss",
              "login_hint",
              "nonce",
              "realm",
              "state"
            ],
            query: []
          },
          "security.put_privileges": {
            path: [],
            body: [
              "privileges"
            ],
            query: [
              "refresh"
            ]
          },
          "security.put_role": {
            path: [
              "name"
            ],
            body: [
              "applications",
              "cluster",
              "global",
              "indices",
              "remote_indices",
              "remote_cluster",
              "metadata",
              "run_as",
              "description",
              "transient_metadata"
            ],
            query: [
              "refresh"
            ]
          },
          "security.put_role_mapping": {
            path: [
              "name"
            ],
            body: [
              "enabled",
              "metadata",
              "roles",
              "role_templates",
              "rules",
              "run_as"
            ],
            query: [
              "refresh"
            ]
          },
          "security.put_user": {
            path: [],
            body: [
              "username",
              "email",
              "full_name",
              "metadata",
              "password",
              "password_hash",
              "roles",
              "enabled"
            ],
            query: [
              "refresh"
            ]
          },
          "security.query_api_keys": {
            path: [],
            body: [
              "aggregations",
              "aggs",
              "query",
              "from",
              "sort",
              "size",
              "search_after"
            ],
            query: [
              "with_limited_by",
              "with_profile_uid",
              "typed_keys"
            ]
          },
          "security.query_role": {
            path: [],
            body: [
              "query",
              "from",
              "sort",
              "size",
              "search_after"
            ],
            query: []
          },
          "security.query_user": {
            path: [],
            body: [
              "query",
              "from",
              "sort",
              "size",
              "search_after"
            ],
            query: [
              "with_profile_uid"
            ]
          },
          "security.saml_authenticate": {
            path: [],
            body: [
              "content",
              "ids",
              "realm"
            ],
            query: []
          },
          "security.saml_complete_logout": {
            path: [],
            body: [
              "realm",
              "ids",
              "query_string",
              "content"
            ],
            query: []
          },
          "security.saml_invalidate": {
            path: [],
            body: [
              "acs",
              "query_string",
              "realm"
            ],
            query: []
          },
          "security.saml_logout": {
            path: [],
            body: [
              "token",
              "refresh_token"
            ],
            query: []
          },
          "security.saml_prepare_authentication": {
            path: [],
            body: [
              "acs",
              "realm",
              "relay_state"
            ],
            query: []
          },
          "security.saml_service_provider_metadata": {
            path: [
              "realm_name"
            ],
            body: [],
            query: []
          },
          "security.suggest_user_profiles": {
            path: [],
            body: [
              "name",
              "size",
              "data",
              "hint"
            ],
            query: [
              "data"
            ]
          },
          "security.update_api_key": {
            path: [
              "id"
            ],
            body: [
              "role_descriptors",
              "metadata",
              "expiration"
            ],
            query: []
          },
          "security.update_cross_cluster_api_key": {
            path: [
              "id"
            ],
            body: [
              "access",
              "expiration",
              "metadata"
            ],
            query: []
          },
          "security.update_settings": {
            path: [],
            body: [
              "security",
              "security-profile",
              "security-tokens"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "security.update_user_profile_data": {
            path: [
              "uid"
            ],
            body: [
              "labels",
              "data"
            ],
            query: [
              "if_seq_no",
              "if_primary_term",
              "refresh"
            ]
          }
        };
      }
      async activateUserProfile(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.activate_user_profile"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/profile/_activate";
        const meta = {
          name: "security.activate_user_profile"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async authenticate(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.authenticate"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_security/_authenticate";
        const meta = {
          name: "security.authenticate"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async bulkDeleteRole(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.bulk_delete_role"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "DELETE";
        const path = "/_security/role";
        const meta = {
          name: "security.bulk_delete_role"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async bulkPutRole(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.bulk_put_role"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/role";
        const meta = {
          name: "security.bulk_put_role"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async bulkUpdateApiKeys(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.bulk_update_api_keys"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/api_key/_bulk_update";
        const meta = {
          name: "security.bulk_update_api_keys"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async changePassword(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.change_password"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.username != null) {
          method = "PUT";
          path = `/_security/user/${encodeURIComponent(params.username.toString())}/_password`;
        } else {
          method = "PUT";
          path = "/_security/user/_password";
        }
        const meta = {
          name: "security.change_password",
          pathParts: {
            username: params.username
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clearApiKeyCache(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.clear_api_key_cache"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_security/api_key/${encodeURIComponent(params.ids.toString())}/_clear_cache`;
        const meta = {
          name: "security.clear_api_key_cache",
          pathParts: {
            ids: params.ids
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clearCachedPrivileges(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.clear_cached_privileges"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/_clear_cache`;
        const meta = {
          name: "security.clear_cached_privileges",
          pathParts: {
            application: params.application
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clearCachedRealms(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.clear_cached_realms"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_security/realm/${encodeURIComponent(params.realms.toString())}/_clear_cache`;
        const meta = {
          name: "security.clear_cached_realms",
          pathParts: {
            realms: params.realms
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clearCachedRoles(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.clear_cached_roles"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_security/role/${encodeURIComponent(params.name.toString())}/_clear_cache`;
        const meta = {
          name: "security.clear_cached_roles",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clearCachedServiceTokens(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.clear_cached_service_tokens"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}/_clear_cache`;
        const meta = {
          name: "security.clear_cached_service_tokens",
          pathParts: {
            namespace: params.namespace,
            service: params.service,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async createApiKey(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.create_api_key"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = "/_security/api_key";
        const meta = {
          name: "security.create_api_key"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async createCrossClusterApiKey(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.create_cross_cluster_api_key"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/cross_cluster/api_key";
        const meta = {
          name: "security.create_cross_cluster_api_key"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async createServiceToken(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.create_service_token"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.namespace != null && params.service != null && params.name != null) {
          method = "PUT";
          path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "POST";
          path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token`;
        }
        const meta = {
          name: "security.create_service_token",
          pathParts: {
            namespace: params.namespace,
            service: params.service,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async delegatePki(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.delegate_pki"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/delegate_pki";
        const meta = {
          name: "security.delegate_pki"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deletePrivileges(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.delete_privileges"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "security.delete_privileges",
          pathParts: {
            application: params.application,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteRole(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.delete_role"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_security/role/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "security.delete_role",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteRoleMapping(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.delete_role_mapping"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "security.delete_role_mapping",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteServiceToken(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.delete_service_token"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "security.delete_service_token",
          pathParts: {
            namespace: params.namespace,
            service: params.service,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteUser(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.delete_user"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_security/user/${encodeURIComponent(params.username.toString())}`;
        const meta = {
          name: "security.delete_user",
          pathParts: {
            username: params.username
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async disableUser(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.disable_user"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_security/user/${encodeURIComponent(params.username.toString())}/_disable`;
        const meta = {
          name: "security.disable_user",
          pathParts: {
            username: params.username
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async disableUserProfile(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.disable_user_profile"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}/_disable`;
        const meta = {
          name: "security.disable_user_profile",
          pathParts: {
            uid: params.uid
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async enableUser(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.enable_user"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_security/user/${encodeURIComponent(params.username.toString())}/_enable`;
        const meta = {
          name: "security.enable_user",
          pathParts: {
            username: params.username
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async enableUserProfile(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.enable_user_profile"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}/_enable`;
        const meta = {
          name: "security.enable_user_profile",
          pathParts: {
            uid: params.uid
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async enrollKibana(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.enroll_kibana"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_security/enroll/kibana";
        const meta = {
          name: "security.enroll_kibana"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async enrollNode(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.enroll_node"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_security/enroll/node";
        const meta = {
          name: "security.enroll_node"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getApiKey(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_api_key"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_security/api_key";
        const meta = {
          name: "security.get_api_key"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getBuiltinPrivileges(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_builtin_privileges"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_security/privilege/_builtin";
        const meta = {
          name: "security.get_builtin_privileges"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getPrivileges(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_privileges"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.application != null && params.name != null) {
          method = "GET";
          path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/${encodeURIComponent(params.name.toString())}`;
        } else if (params.application != null) {
          method = "GET";
          path = `/_security/privilege/${encodeURIComponent(params.application.toString())}`;
        } else {
          method = "GET";
          path = "/_security/privilege";
        }
        const meta = {
          name: "security.get_privileges",
          pathParts: {
            application: params.application,
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRole(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_role"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_security/role/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_security/role";
        }
        const meta = {
          name: "security.get_role",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRoleMapping(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_role_mapping"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_security/role_mapping";
        }
        const meta = {
          name: "security.get_role_mapping",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getServiceAccounts(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_service_accounts"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.namespace != null && params.service != null) {
          method = "GET";
          path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}`;
        } else if (params.namespace != null) {
          method = "GET";
          path = `/_security/service/${encodeURIComponent(params.namespace.toString())}`;
        } else {
          method = "GET";
          path = "/_security/service";
        }
        const meta = {
          name: "security.get_service_accounts",
          pathParts: {
            namespace: params.namespace,
            service: params.service
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getServiceCredentials(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_service_credentials"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential`;
        const meta = {
          name: "security.get_service_credentials",
          pathParts: {
            namespace: params.namespace,
            service: params.service
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSettings(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_security/settings";
        const meta = {
          name: "security.get_settings"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getToken(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.get_token"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/oauth2/token";
        const meta = {
          name: "security.get_token"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getUser(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_user"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.username != null) {
          method = "GET";
          path = `/_security/user/${encodeURIComponent(params.username.toString())}`;
        } else {
          method = "GET";
          path = "/_security/user";
        }
        const meta = {
          name: "security.get_user",
          pathParts: {
            username: params.username
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getUserPrivileges(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_user_privileges"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_security/user/_privileges";
        const meta = {
          name: "security.get_user_privileges"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getUserProfile(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.get_user_profile"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}`;
        const meta = {
          name: "security.get_user_profile",
          pathParts: {
            uid: params.uid
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async grantApiKey(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.grant_api_key"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/api_key/grant";
        const meta = {
          name: "security.grant_api_key"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async hasPrivileges(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.has_privileges"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.user != null) {
          method = body != null ? "POST" : "GET";
          path = `/_security/user/${encodeURIComponent(params.user.toString())}/_has_privileges`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_security/user/_has_privileges";
        }
        const meta = {
          name: "security.has_privileges",
          pathParts: {
            user: params.user
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async hasPrivilegesUserProfile(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.has_privileges_user_profile"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_security/profile/_has_privileges";
        const meta = {
          name: "security.has_privileges_user_profile"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async invalidateApiKey(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.invalidate_api_key"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "DELETE";
        const path = "/_security/api_key";
        const meta = {
          name: "security.invalidate_api_key"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async invalidateToken(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.invalidate_token"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "DELETE";
        const path = "/_security/oauth2/token";
        const meta = {
          name: "security.invalidate_token"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async oidcAuthenticate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.oidc_authenticate"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/oidc/authenticate";
        const meta = {
          name: "security.oidc_authenticate"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async oidcLogout(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.oidc_logout"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/oidc/logout";
        const meta = {
          name: "security.oidc_logout"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async oidcPrepareAuthentication(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.oidc_prepare_authentication"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/oidc/prepare";
        const meta = {
          name: "security.oidc_prepare_authentication"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putPrivileges(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.put_privileges"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = "/_security/privilege";
        const meta = {
          name: "security.put_privileges"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putRole(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.put_role"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_security/role/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "security.put_role",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putRoleMapping(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.put_role_mapping"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "security.put_role_mapping",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putUser(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.put_user"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_security/user/${encodeURIComponent(params.username.toString())}`;
        const meta = {
          name: "security.put_user",
          pathParts: {
            username: params.username
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async queryApiKeys(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.query_api_keys"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_security/_query/api_key";
        const meta = {
          name: "security.query_api_keys"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async queryRole(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.query_role"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_security/_query/role";
        const meta = {
          name: "security.query_role"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async queryUser(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.query_user"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_security/_query/user";
        const meta = {
          name: "security.query_user"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async samlAuthenticate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.saml_authenticate"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/saml/authenticate";
        const meta = {
          name: "security.saml_authenticate"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async samlCompleteLogout(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.saml_complete_logout"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/saml/complete_logout";
        const meta = {
          name: "security.saml_complete_logout"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async samlInvalidate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.saml_invalidate"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/saml/invalidate";
        const meta = {
          name: "security.saml_invalidate"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async samlLogout(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.saml_logout"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/saml/logout";
        const meta = {
          name: "security.saml_logout"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async samlPrepareAuthentication(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.saml_prepare_authentication"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_security/saml/prepare";
        const meta = {
          name: "security.saml_prepare_authentication"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async samlServiceProviderMetadata(params, options) {
        const { path: acceptedPath } = this.acceptedParams["security.saml_service_provider_metadata"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_security/saml/metadata/${encodeURIComponent(params.realm_name.toString())}`;
        const meta = {
          name: "security.saml_service_provider_metadata",
          pathParts: {
            realm_name: params.realm_name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async suggestUserProfiles(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.suggest_user_profiles"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_security/profile/_suggest";
        const meta = {
          name: "security.suggest_user_profiles"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateApiKey(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.update_api_key"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_security/api_key/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "security.update_api_key",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateCrossClusterApiKey(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.update_cross_cluster_api_key"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_security/cross_cluster/api_key/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "security.update_cross_cluster_api_key",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateSettings(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.update_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = "/_security/settings";
        const meta = {
          name: "security.update_settings"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateUserProfileData(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["security.update_user_profile_data"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}/_data`;
        const meta = {
          name: "security.update_user_profile_data",
          pathParts: {
            uid: params.uid
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Security;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js
var require_shutdown = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Shutdown = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "shutdown.delete_node": {
            path: [
              "node_id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "shutdown.get_node": {
            path: [
              "node_id"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "shutdown.put_node": {
            path: [
              "node_id"
            ],
            body: [
              "type",
              "reason",
              "allocation_delay",
              "target_node_name"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          }
        };
      }
      async deleteNode(params, options) {
        const { path: acceptedPath } = this.acceptedParams["shutdown.delete_node"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;
        const meta = {
          name: "shutdown.delete_node",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getNode(params, options) {
        const { path: acceptedPath } = this.acceptedParams["shutdown.get_node"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.node_id != null) {
          method = "GET";
          path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;
        } else {
          method = "GET";
          path = "/_nodes/shutdown";
        }
        const meta = {
          name: "shutdown.get_node",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putNode(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["shutdown.put_node"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;
        const meta = {
          name: "shutdown.put_node",
          pathParts: {
            node_id: params.node_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Shutdown;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/simulate.js
var require_simulate = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/simulate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Simulate = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "simulate.ingest": {
            path: [
              "index"
            ],
            body: [
              "docs",
              "component_template_substitutions",
              "index_template_substitutions",
              "mapping_addition",
              "pipeline_substitutions"
            ],
            query: [
              "pipeline"
            ]
          }
        };
      }
      async ingest(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["simulate.ingest"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.index != null) {
          method = body != null ? "POST" : "GET";
          path = `/_ingest/${encodeURIComponent(params.index.toString())}/_simulate`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_ingest/_simulate";
        }
        const meta = {
          name: "simulate.ingest",
          pathParts: {
            index: params.index
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Simulate;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/slm.js
var require_slm = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/slm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Slm = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "slm.delete_lifecycle": {
            path: [
              "policy_id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.execute_lifecycle": {
            path: [
              "policy_id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.execute_retention": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.get_lifecycle": {
            path: [
              "policy_id"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.get_stats": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.get_status": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.put_lifecycle": {
            path: [
              "policy_id"
            ],
            body: [
              "config",
              "name",
              "repository",
              "retention",
              "schedule"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.start": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "slm.stop": {
            path: [],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          }
        };
      }
      async deleteLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.delete_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;
        const meta = {
          name: "slm.delete_lifecycle",
          pathParts: {
            policy_id: params.policy_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async executeLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.execute_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}/_execute`;
        const meta = {
          name: "slm.execute_lifecycle",
          pathParts: {
            policy_id: params.policy_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async executeRetention(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.execute_retention"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_slm/_execute_retention";
        const meta = {
          name: "slm.execute_retention"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getLifecycle(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.get_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.policy_id != null) {
          method = "GET";
          path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;
        } else {
          method = "GET";
          path = "/_slm/policy";
        }
        const meta = {
          name: "slm.get_lifecycle",
          pathParts: {
            policy_id: params.policy_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.get_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_slm/stats";
        const meta = {
          name: "slm.get_stats"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.get_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_slm/status";
        const meta = {
          name: "slm.get_status"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putLifecycle(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["slm.put_lifecycle"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;
        const meta = {
          name: "slm.put_lifecycle",
          pathParts: {
            policy_id: params.policy_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async start(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.start"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_slm/start";
        const meta = {
          name: "slm.start"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stop(params, options) {
        const { path: acceptedPath } = this.acceptedParams["slm.stop"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_slm/stop";
        const meta = {
          name: "slm.stop"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Slm;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js
var require_snapshot = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Snapshot = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "snapshot.cleanup_repository": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "snapshot.clone": {
            path: [
              "repository",
              "snapshot",
              "target_snapshot"
            ],
            body: [
              "indices"
            ],
            query: [
              "master_timeout"
            ]
          },
          "snapshot.create": {
            path: [
              "repository",
              "snapshot"
            ],
            body: [
              "expand_wildcards",
              "feature_states",
              "ignore_unavailable",
              "include_global_state",
              "indices",
              "metadata",
              "partial"
            ],
            query: [
              "master_timeout",
              "wait_for_completion"
            ]
          },
          "snapshot.create_repository": {
            path: [
              "name"
            ],
            body: [
              "repository"
            ],
            query: [
              "master_timeout",
              "timeout",
              "verify"
            ]
          },
          "snapshot.delete": {
            path: [
              "repository",
              "snapshot"
            ],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "snapshot.delete_repository": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          },
          "snapshot.get": {
            path: [
              "repository",
              "snapshot"
            ],
            body: [],
            query: [
              "after",
              "from_sort_value",
              "ignore_unavailable",
              "index_details",
              "index_names",
              "include_repository",
              "master_timeout",
              "order",
              "offset",
              "size",
              "slm_policy_filter",
              "sort",
              "verbose"
            ]
          },
          "snapshot.get_repository": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "local",
              "master_timeout"
            ]
          },
          "snapshot.repository_analyze": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "blob_count",
              "concurrency",
              "detailed",
              "early_read_node_count",
              "max_blob_size",
              "max_total_data_size",
              "rare_action_probability",
              "rarely_abort_writes",
              "read_node_count",
              "register_operation_count",
              "seed",
              "timeout"
            ]
          },
          "snapshot.repository_verify_integrity": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "blob_thread_pool_concurrency",
              "index_snapshot_verification_concurrency",
              "index_verification_concurrency",
              "max_bytes_per_sec",
              "max_failed_shard_snapshots",
              "meta_thread_pool_concurrency",
              "snapshot_verification_concurrency",
              "verify_blob_contents"
            ]
          },
          "snapshot.restore": {
            path: [
              "repository",
              "snapshot"
            ],
            body: [
              "feature_states",
              "ignore_index_settings",
              "ignore_unavailable",
              "include_aliases",
              "include_global_state",
              "index_settings",
              "indices",
              "partial",
              "rename_pattern",
              "rename_replacement"
            ],
            query: [
              "master_timeout",
              "wait_for_completion"
            ]
          },
          "snapshot.status": {
            path: [
              "repository",
              "snapshot"
            ],
            body: [],
            query: [
              "ignore_unavailable",
              "master_timeout"
            ]
          },
          "snapshot.verify_repository": {
            path: [
              "name"
            ],
            body: [],
            query: [
              "master_timeout",
              "timeout"
            ]
          }
        };
      }
      async cleanupRepository(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.cleanup_repository"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_cleanup`;
        const meta = {
          name: "snapshot.cleanup_repository",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async clone(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["snapshot.clone"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_clone/${encodeURIComponent(params.target_snapshot.toString())}`;
        const meta = {
          name: "snapshot.clone",
          pathParts: {
            repository: params.repository,
            snapshot: params.snapshot,
            target_snapshot: params.target_snapshot
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async create(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["snapshot.create"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;
        const meta = {
          name: "snapshot.create",
          pathParts: {
            repository: params.repository,
            snapshot: params.snapshot
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async createRepository(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["snapshot.create_repository"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "snapshot.create_repository",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async delete(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.delete"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;
        const meta = {
          name: "snapshot.delete",
          pathParts: {
            repository: params.repository,
            snapshot: params.snapshot
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteRepository(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.delete_repository"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;
        const meta = {
          name: "snapshot.delete_repository",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;
        const meta = {
          name: "snapshot.get",
          pathParts: {
            repository: params.repository,
            snapshot: params.snapshot
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getRepository(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.get_repository"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.name != null) {
          method = "GET";
          path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;
        } else {
          method = "GET";
          path = "/_snapshot";
        }
        const meta = {
          name: "snapshot.get_repository",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async repositoryAnalyze(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.repository_analyze"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_analyze`;
        const meta = {
          name: "snapshot.repository_analyze",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async repositoryVerifyIntegrity(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.repository_verify_integrity"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_verify_integrity`;
        const meta = {
          name: "snapshot.repository_verify_integrity",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async restore(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["snapshot.restore"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_restore`;
        const meta = {
          name: "snapshot.restore",
          pathParts: {
            repository: params.repository,
            snapshot: params.snapshot
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async status(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.repository != null && params.snapshot != null) {
          method = "GET";
          path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_status`;
        } else if (params.repository != null) {
          method = "GET";
          path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/_status`;
        } else {
          method = "GET";
          path = "/_snapshot/_status";
        }
        const meta = {
          name: "snapshot.status",
          pathParts: {
            repository: params.repository,
            snapshot: params.snapshot
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async verifyRepository(params, options) {
        const { path: acceptedPath } = this.acceptedParams["snapshot.verify_repository"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_verify`;
        const meta = {
          name: "snapshot.verify_repository",
          pathParts: {
            name: params.name
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Snapshot;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/sql.js
var require_sql = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/sql.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Sql = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "sql.clear_cursor": {
            path: [],
            body: [
              "cursor"
            ],
            query: []
          },
          "sql.delete_async": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "sql.get_async": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "delimiter",
              "format",
              "keep_alive",
              "wait_for_completion_timeout"
            ]
          },
          "sql.get_async_status": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "sql.query": {
            path: [],
            body: [
              "allow_partial_search_results",
              "catalog",
              "columnar",
              "cursor",
              "fetch_size",
              "field_multi_value_leniency",
              "filter",
              "index_using_frozen",
              "keep_alive",
              "keep_on_completion",
              "page_timeout",
              "params",
              "query",
              "request_timeout",
              "runtime_mappings",
              "time_zone",
              "wait_for_completion_timeout"
            ],
            query: [
              "format"
            ]
          },
          "sql.translate": {
            path: [],
            body: [
              "fetch_size",
              "filter",
              "query",
              "time_zone"
            ],
            query: []
          }
        };
      }
      async clearCursor(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["sql.clear_cursor"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_sql/close";
        const meta = {
          name: "sql.clear_cursor"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteAsync(params, options) {
        const { path: acceptedPath } = this.acceptedParams["sql.delete_async"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_sql/async/delete/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "sql.delete_async",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getAsync(params, options) {
        const { path: acceptedPath } = this.acceptedParams["sql.get_async"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_sql/async/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "sql.get_async",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getAsyncStatus(params, options) {
        const { path: acceptedPath } = this.acceptedParams["sql.get_async_status"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_sql/async/status/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "sql.get_async_status",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async query(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["sql.query"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_sql";
        const meta = {
          name: "sql.query"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async translate(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["sql.translate"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_sql/translate";
        const meta = {
          name: "sql.translate"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Sql;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/ssl.js
var require_ssl = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/ssl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Ssl = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "ssl.certificates": {
            path: [],
            body: [],
            query: []
          }
        };
      }
      async certificates(params, options) {
        const { path: acceptedPath } = this.acceptedParams["ssl.certificates"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_ssl/certificates";
        const meta = {
          name: "ssl.certificates"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Ssl;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/synonyms.js
var require_synonyms = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/synonyms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Synonyms = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "synonyms.delete_synonym": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "synonyms.delete_synonym_rule": {
            path: [
              "set_id",
              "rule_id"
            ],
            body: [],
            query: []
          },
          "synonyms.get_synonym": {
            path: [
              "id"
            ],
            body: [],
            query: [
              "from",
              "size"
            ]
          },
          "synonyms.get_synonym_rule": {
            path: [
              "set_id",
              "rule_id"
            ],
            body: [],
            query: []
          },
          "synonyms.get_synonyms_sets": {
            path: [],
            body: [],
            query: [
              "from",
              "size"
            ]
          },
          "synonyms.put_synonym": {
            path: [
              "id"
            ],
            body: [
              "synonyms_set"
            ],
            query: []
          },
          "synonyms.put_synonym_rule": {
            path: [
              "set_id",
              "rule_id"
            ],
            body: [
              "synonyms"
            ],
            query: []
          }
        };
      }
      async deleteSynonym(params, options) {
        const { path: acceptedPath } = this.acceptedParams["synonyms.delete_synonym"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "synonyms.delete_synonym",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteSynonymRule(params, options) {
        const { path: acceptedPath } = this.acceptedParams["synonyms.delete_synonym_rule"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
          name: "synonyms.delete_synonym_rule",
          pathParts: {
            set_id: params.set_id,
            rule_id: params.rule_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSynonym(params, options) {
        const { path: acceptedPath } = this.acceptedParams["synonyms.get_synonym"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "synonyms.get_synonym",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSynonymRule(params, options) {
        const { path: acceptedPath } = this.acceptedParams["synonyms.get_synonym_rule"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
          name: "synonyms.get_synonym_rule",
          pathParts: {
            set_id: params.set_id,
            rule_id: params.rule_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSynonymsSets(params, options) {
        const { path: acceptedPath } = this.acceptedParams["synonyms.get_synonyms_sets"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_synonyms";
        const meta = {
          name: "synonyms.get_synonyms_sets"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putSynonym(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["synonyms.put_synonym"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "synonyms.put_synonym",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putSynonymRule(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["synonyms.put_synonym_rule"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;
        const meta = {
          name: "synonyms.put_synonym_rule",
          pathParts: {
            set_id: params.set_id,
            rule_id: params.rule_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Synonyms;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/tasks.js
var require_tasks = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Tasks = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "tasks.cancel": {
            path: [
              "task_id"
            ],
            body: [],
            query: [
              "actions",
              "nodes",
              "parent_task_id",
              "wait_for_completion"
            ]
          },
          "tasks.get": {
            path: [
              "task_id"
            ],
            body: [],
            query: [
              "timeout",
              "wait_for_completion"
            ]
          },
          "tasks.list": {
            path: [],
            body: [],
            query: [
              "actions",
              "detailed",
              "group_by",
              "nodes",
              "parent_task_id",
              "timeout",
              "wait_for_completion"
            ]
          }
        };
      }
      async cancel(params, options) {
        const { path: acceptedPath } = this.acceptedParams["tasks.cancel"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.task_id != null) {
          method = "POST";
          path = `/_tasks/${encodeURIComponent(params.task_id.toString())}/_cancel`;
        } else {
          method = "POST";
          path = "/_tasks/_cancel";
        }
        const meta = {
          name: "tasks.cancel",
          pathParts: {
            task_id: params.task_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async get(params, options) {
        const { path: acceptedPath } = this.acceptedParams["tasks.get"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_tasks/${encodeURIComponent(params.task_id.toString())}`;
        const meta = {
          name: "tasks.get",
          pathParts: {
            task_id: params.task_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async list(params, options) {
        const { path: acceptedPath } = this.acceptedParams["tasks.list"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_tasks";
        const meta = {
          name: "tasks.list"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Tasks;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js
var require_terms_enum = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = TermsEnumApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      terms_enum: {
        path: [
          "index"
        ],
        body: [
          "field",
          "size",
          "timeout",
          "case_insensitive",
          "index_filter",
          "string",
          "search_after"
        ],
        query: []
      }
    };
    async function TermsEnumApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.terms_enum;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = body != null ? "POST" : "GET";
      const path = `/${encodeURIComponent(params.index.toString())}/_terms_enum`;
      const meta = {
        name: "terms_enum",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js
var require_termvectors = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = TermvectorsApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      termvectors: {
        path: [
          "index",
          "id"
        ],
        body: [
          "doc",
          "filter",
          "per_field_analyzer",
          "fields",
          "field_statistics",
          "offsets",
          "payloads",
          "positions",
          "term_statistics",
          "routing",
          "version",
          "version_type"
        ],
        query: [
          "fields",
          "field_statistics",
          "offsets",
          "payloads",
          "positions",
          "preference",
          "realtime",
          "routing",
          "term_statistics",
          "version",
          "version_type"
        ]
      }
    };
    async function TermvectorsApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.termvectors;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      let method = "";
      let path = "";
      if (params.index != null && params.id != null) {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_termvectors/${encodeURIComponent(params.id.toString())}`;
      } else {
        method = body != null ? "POST" : "GET";
        path = `/${encodeURIComponent(params.index.toString())}/_termvectors`;
      }
      const meta = {
        name: "termvectors",
        pathParts: {
          index: params.index,
          id: params.id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js
var require_text_structure = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var TextStructure = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "text_structure.find_field_structure": {
            path: [],
            body: [],
            query: [
              "column_names",
              "delimiter",
              "documents_to_sample",
              "ecs_compatibility",
              "explain",
              "field",
              "format",
              "grok_pattern",
              "index",
              "quote",
              "should_trim_fields",
              "timeout",
              "timestamp_field",
              "timestamp_format"
            ]
          },
          "text_structure.find_message_structure": {
            path: [],
            body: [
              "messages"
            ],
            query: [
              "column_names",
              "delimiter",
              "ecs_compatibility",
              "explain",
              "format",
              "grok_pattern",
              "quote",
              "should_trim_fields",
              "timeout",
              "timestamp_field",
              "timestamp_format"
            ]
          },
          "text_structure.find_structure": {
            path: [],
            body: [
              "text_files"
            ],
            query: [
              "charset",
              "column_names",
              "delimiter",
              "ecs_compatibility",
              "explain",
              "format",
              "grok_pattern",
              "has_header_row",
              "line_merge_size_limit",
              "lines_to_sample",
              "quote",
              "should_trim_fields",
              "timeout",
              "timestamp_field",
              "timestamp_format"
            ]
          },
          "text_structure.test_grok_pattern": {
            path: [],
            body: [
              "grok_pattern",
              "text"
            ],
            query: [
              "ecs_compatibility"
            ]
          }
        };
      }
      async findFieldStructure(params, options) {
        const { path: acceptedPath } = this.acceptedParams["text_structure.find_field_structure"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_text_structure/find_field_structure";
        const meta = {
          name: "text_structure.find_field_structure"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async findMessageStructure(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["text_structure.find_message_structure"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_text_structure/find_message_structure";
        const meta = {
          name: "text_structure.find_message_structure"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async findStructure(params, options) {
        var _a;
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["text_structure.find_structure"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body = (_a = params.body) !== null && _a !== void 0 ? _a : void 0;
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = "/_text_structure/find_structure";
        const meta = {
          name: "text_structure.find_structure"
        };
        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);
      }
      async testGrokPattern(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["text_structure.test_grok_pattern"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_text_structure/test_grok_pattern";
        const meta = {
          name: "text_structure.test_grok_pattern"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = TextStructure;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/transform.js
var require_transform = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/transform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Transform = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "transform.delete_transform": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "force",
              "delete_dest_index",
              "timeout"
            ]
          },
          "transform.get_node_stats": {
            path: [],
            body: [],
            query: []
          },
          "transform.get_transform": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "from",
              "size",
              "exclude_generated"
            ]
          },
          "transform.get_transform_stats": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "from",
              "size",
              "timeout"
            ]
          },
          "transform.preview_transform": {
            path: [
              "transform_id"
            ],
            body: [
              "dest",
              "description",
              "frequency",
              "pivot",
              "source",
              "settings",
              "sync",
              "retention_policy",
              "latest"
            ],
            query: [
              "timeout"
            ]
          },
          "transform.put_transform": {
            path: [
              "transform_id"
            ],
            body: [
              "dest",
              "description",
              "frequency",
              "latest",
              "_meta",
              "pivot",
              "retention_policy",
              "settings",
              "source",
              "sync"
            ],
            query: [
              "defer_validation",
              "timeout"
            ]
          },
          "transform.reset_transform": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "force",
              "timeout"
            ]
          },
          "transform.schedule_now_transform": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "timeout"
            ]
          },
          "transform.start_transform": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "timeout",
              "from"
            ]
          },
          "transform.stop_transform": {
            path: [
              "transform_id"
            ],
            body: [],
            query: [
              "allow_no_match",
              "force",
              "timeout",
              "wait_for_checkpoint",
              "wait_for_completion"
            ]
          },
          "transform.update_transform": {
            path: [
              "transform_id"
            ],
            body: [
              "dest",
              "description",
              "frequency",
              "_meta",
              "source",
              "settings",
              "sync",
              "retention_policy"
            ],
            query: [
              "defer_validation",
              "timeout"
            ]
          },
          "transform.upgrade_transforms": {
            path: [],
            body: [],
            query: [
              "dry_run",
              "timeout"
            ]
          }
        };
      }
      async deleteTransform(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.delete_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;
        const meta = {
          name: "transform.delete_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getNodeStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.get_node_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_transform/_node_stats";
        const meta = {
          name: "transform.get_node_stats"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getTransform(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.get_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.transform_id != null) {
          method = "GET";
          path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;
        } else {
          method = "GET";
          path = "/_transform";
        }
        const meta = {
          name: "transform.get_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getTransformStats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.get_transform_stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stats`;
        const meta = {
          name: "transform.get_transform_stats",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async previewTransform(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["transform.preview_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.transform_id != null) {
          method = body != null ? "POST" : "GET";
          path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_preview`;
        } else {
          method = body != null ? "POST" : "GET";
          path = "/_transform/_preview";
        }
        const meta = {
          name: "transform.preview_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putTransform(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["transform.put_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;
        const meta = {
          name: "transform.put_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async resetTransform(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.reset_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_reset`;
        const meta = {
          name: "transform.reset_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async scheduleNowTransform(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.schedule_now_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_schedule_now`;
        const meta = {
          name: "transform.schedule_now_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async startTransform(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.start_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_start`;
        const meta = {
          name: "transform.start_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stopTransform(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.stop_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stop`;
        const meta = {
          name: "transform.stop_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateTransform(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["transform.update_transform"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "POST";
        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_update`;
        const meta = {
          name: "transform.update_transform",
          pathParts: {
            transform_id: params.transform_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async upgradeTransforms(params, options) {
        const { path: acceptedPath } = this.acceptedParams["transform.upgrade_transforms"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_transform/_upgrade";
        const meta = {
          name: "transform.upgrade_transforms"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Transform;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/update.js
var require_update = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/update.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = UpdateApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      update: {
        path: [
          "id",
          "index"
        ],
        body: [
          "detect_noop",
          "doc",
          "doc_as_upsert",
          "script",
          "scripted_upsert",
          "_source",
          "upsert"
        ],
        query: [
          "if_primary_term",
          "if_seq_no",
          "include_source_on_error",
          "lang",
          "refresh",
          "require_alias",
          "retry_on_conflict",
          "routing",
          "timeout",
          "wait_for_active_shards",
          "_source",
          "_source_excludes",
          "_source_includes"
        ]
      }
    };
    async function UpdateApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.update;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "POST";
      const path = `/${encodeURIComponent(params.index.toString())}/_update/${encodeURIComponent(params.id.toString())}`;
      const meta = {
        name: "update",
        pathParts: {
          id: params.id,
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js
var require_update_by_query = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = UpdateByQueryApi;
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var acceptedParams = {
      update_by_query: {
        path: [
          "index"
        ],
        body: [
          "max_docs",
          "query",
          "script",
          "slice",
          "conflicts"
        ],
        query: [
          "allow_no_indices",
          "analyzer",
          "analyze_wildcard",
          "conflicts",
          "default_operator",
          "df",
          "expand_wildcards",
          "from",
          "ignore_unavailable",
          "lenient",
          "max_docs",
          "pipeline",
          "preference",
          "q",
          "refresh",
          "request_cache",
          "requests_per_second",
          "routing",
          "scroll",
          "scroll_size",
          "search_timeout",
          "search_type",
          "slices",
          "sort",
          "stats",
          "terminate_after",
          "timeout",
          "version",
          "version_type",
          "wait_for_active_shards",
          "wait_for_completion"
        ]
      }
    };
    async function UpdateByQueryApi(params, options) {
      const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = acceptedParams.update_by_query;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedBody.includes(key)) {
          body = body !== null && body !== void 0 ? body : {};
          body[key] = params[key];
        } else if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
            querystring[key] = params[key];
          } else {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          }
        }
      }
      const method = "POST";
      const path = `/${encodeURIComponent(params.index.toString())}/_update_by_query`;
      const meta = {
        name: "update_by_query",
        pathParts: {
          index: params.index
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js
var require_update_by_query_rethrottle = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = UpdateByQueryRethrottleApi;
    var acceptedParams = {
      update_by_query_rethrottle: {
        path: [
          "task_id"
        ],
        body: [],
        query: [
          "requests_per_second"
        ]
      }
    };
    async function UpdateByQueryRethrottleApi(params, options) {
      const { path: acceptedPath } = acceptedParams.update_by_query_rethrottle;
      const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
      const querystring = userQuery != null ? { ...userQuery } : {};
      let body;
      const userBody = params === null || params === void 0 ? void 0 : params.body;
      if (userBody != null) {
        if (typeof userBody === "string") {
          body = userBody;
        } else {
          body = { ...userBody };
        }
      }
      for (const key in params) {
        if (acceptedPath.includes(key)) {
          continue;
        } else if (key !== "body" && key !== "querystring") {
          querystring[key] = params[key];
        }
      }
      const method = "POST";
      const path = `/_update_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;
      const meta = {
        name: "update_by_query_rethrottle",
        pathParts: {
          task_id: params.task_id
        }
      };
      return await this.transport.request({ path, method, querystring, body, meta }, options);
    }
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/watcher.js
var require_watcher = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/watcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commonQueryParams = ["error_trace", "filter_path", "human", "pretty"];
    var Watcher = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "watcher.ack_watch": {
            path: [
              "watch_id",
              "action_id"
            ],
            body: [],
            query: []
          },
          "watcher.activate_watch": {
            path: [
              "watch_id"
            ],
            body: [],
            query: []
          },
          "watcher.deactivate_watch": {
            path: [
              "watch_id"
            ],
            body: [],
            query: []
          },
          "watcher.delete_watch": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "watcher.execute_watch": {
            path: [
              "id"
            ],
            body: [
              "action_modes",
              "alternative_input",
              "ignore_condition",
              "record_execution",
              "simulated_actions",
              "trigger_data",
              "watch"
            ],
            query: [
              "debug"
            ]
          },
          "watcher.get_settings": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "watcher.get_watch": {
            path: [
              "id"
            ],
            body: [],
            query: []
          },
          "watcher.put_watch": {
            path: [
              "id"
            ],
            body: [
              "actions",
              "condition",
              "input",
              "metadata",
              "throttle_period",
              "throttle_period_in_millis",
              "transform",
              "trigger"
            ],
            query: [
              "active",
              "if_primary_term",
              "if_seq_no",
              "version"
            ]
          },
          "watcher.query_watches": {
            path: [],
            body: [
              "from",
              "size",
              "query",
              "sort",
              "search_after"
            ],
            query: []
          },
          "watcher.start": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "watcher.stats": {
            path: [
              "metric"
            ],
            body: [],
            query: [
              "emit_stacktraces",
              "metric"
            ]
          },
          "watcher.stop": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          },
          "watcher.update_settings": {
            path: [],
            body: [
              "index.auto_expand_replicas",
              "index.number_of_replicas"
            ],
            query: [
              "master_timeout",
              "timeout"
            ]
          }
        };
      }
      async ackWatch(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.ack_watch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.watch_id != null && params.action_id != null) {
          method = "PUT";
          path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack/${encodeURIComponent(params.action_id.toString())}`;
        } else {
          method = "PUT";
          path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack`;
        }
        const meta = {
          name: "watcher.ack_watch",
          pathParts: {
            watch_id: params.watch_id,
            action_id: params.action_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async activateWatch(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.activate_watch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_activate`;
        const meta = {
          name: "watcher.activate_watch",
          pathParts: {
            watch_id: params.watch_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deactivateWatch(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.deactivate_watch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "PUT";
        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_deactivate`;
        const meta = {
          name: "watcher.deactivate_watch",
          pathParts: {
            watch_id: params.watch_id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async deleteWatch(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.delete_watch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "DELETE";
        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "watcher.delete_watch",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async executeWatch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["watcher.execute_watch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        let method = "";
        let path = "";
        if (params.id != null) {
          method = "PUT";
          path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}/_execute`;
        } else {
          method = "PUT";
          path = "/_watcher/watch/_execute";
        }
        const meta = {
          name: "watcher.execute_watch",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getSettings(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.get_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_watcher/settings";
        const meta = {
          name: "watcher.get_settings"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async getWatch(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.get_watch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "watcher.get_watch",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async putWatch(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["watcher.put_watch"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;
        const meta = {
          name: "watcher.put_watch",
          pathParts: {
            id: params.id
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async queryWatches(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["watcher.query_watches"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = body != null ? "POST" : "GET";
        const path = "/_watcher/_query/watches";
        const meta = {
          name: "watcher.query_watches"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async start(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.start"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_watcher/_start";
        const meta = {
          name: "watcher.start"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stats(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.stats"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        let method = "";
        let path = "";
        if (params.metric != null) {
          method = "GET";
          path = `/_watcher/stats/${encodeURIComponent(params.metric.toString())}`;
        } else {
          method = "GET";
          path = "/_watcher/stats";
        }
        const meta = {
          name: "watcher.stats",
          pathParts: {
            metric: params.metric
          }
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async stop(params, options) {
        const { path: acceptedPath } = this.acceptedParams["watcher.stop"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "POST";
        const path = "/_watcher/_stop";
        const meta = {
          name: "watcher.stop"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async updateSettings(params, options) {
        const { path: acceptedPath, body: acceptedBody, query: acceptedQuery } = this.acceptedParams["watcher.update_settings"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedBody.includes(key)) {
            body = body !== null && body !== void 0 ? body : {};
            body[key] = params[key];
          } else if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            if (acceptedQuery.includes(key) || commonQueryParams.includes(key)) {
              querystring[key] = params[key];
            } else {
              body = body !== null && body !== void 0 ? body : {};
              body[key] = params[key];
            }
          }
        }
        const method = "PUT";
        const path = "/_watcher/settings";
        const meta = {
          name: "watcher.update_settings"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Watcher;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/api/xpack.js
var require_xpack = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/api/xpack.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Xpack = class {
      constructor(transport) {
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "acceptedParams", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.transport = transport;
        this.acceptedParams = {
          "xpack.info": {
            path: [],
            body: [],
            query: [
              "categories",
              "accept_enterprise",
              "human"
            ]
          },
          "xpack.usage": {
            path: [],
            body: [],
            query: [
              "master_timeout"
            ]
          }
        };
      }
      async info(params, options) {
        const { path: acceptedPath } = this.acceptedParams["xpack.info"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_xpack";
        const meta = {
          name: "xpack.info"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
      async usage(params, options) {
        const { path: acceptedPath } = this.acceptedParams["xpack.usage"];
        const userQuery = params === null || params === void 0 ? void 0 : params.querystring;
        const querystring = userQuery != null ? { ...userQuery } : {};
        let body;
        const userBody = params === null || params === void 0 ? void 0 : params.body;
        if (userBody != null) {
          if (typeof userBody === "string") {
            body = userBody;
          } else {
            body = { ...userBody };
          }
        }
        params = params !== null && params !== void 0 ? params : {};
        for (const key in params) {
          if (acceptedPath.includes(key)) {
            continue;
          } else if (key !== "body" && key !== "querystring") {
            querystring[key] = params[key];
          }
        }
        const method = "GET";
        const path = "/_xpack/usage";
        const meta = {
          name: "xpack.usage"
        };
        return await this.transport.request({ path, method, querystring, body, meta }, options);
      }
    };
    exports2.default = Xpack;
  }
});

// node_modules/@elastic/elasticsearch/lib/api/index.js
var require_api3 = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/api/index.js"(exports2) {
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    var _e;
    var _f;
    var _g;
    var _h;
    var _j;
    var _k;
    var _l;
    var _m;
    var _o;
    var _p;
    var _q;
    var _r;
    var _s;
    var _t;
    var _u;
    var _v;
    var _w;
    var _x;
    var _y;
    var _z;
    var _0;
    var _1;
    var _2;
    var _3;
    var _4;
    var _5;
    var _6;
    var _7;
    var _8;
    var _9;
    var _10;
    var _11;
    var _12;
    var _13;
    var _14;
    var _15;
    var _16;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var async_search_1 = tslib_1.__importDefault(require_async_search());
    var autoscaling_1 = tslib_1.__importDefault(require_autoscaling());
    var bulk_1 = tslib_1.__importDefault(require_bulk());
    var capabilities_1 = tslib_1.__importDefault(require_capabilities());
    var cat_1 = tslib_1.__importDefault(require_cat());
    var ccr_1 = tslib_1.__importDefault(require_ccr());
    var clear_scroll_1 = tslib_1.__importDefault(require_clear_scroll());
    var close_point_in_time_1 = tslib_1.__importDefault(require_close_point_in_time());
    var cluster_1 = tslib_1.__importDefault(require_cluster());
    var connector_1 = tslib_1.__importDefault(require_connector());
    var count_1 = tslib_1.__importDefault(require_count());
    var create_1 = tslib_1.__importDefault(require_create());
    var dangling_indices_1 = tslib_1.__importDefault(require_dangling_indices());
    var delete_1 = tslib_1.__importDefault(require_delete());
    var delete_by_query_1 = tslib_1.__importDefault(require_delete_by_query());
    var delete_by_query_rethrottle_1 = tslib_1.__importDefault(require_delete_by_query_rethrottle());
    var delete_script_1 = tslib_1.__importDefault(require_delete_script());
    var enrich_1 = tslib_1.__importDefault(require_enrich());
    var eql_1 = tslib_1.__importDefault(require_eql());
    var esql_1 = tslib_1.__importDefault(require_esql());
    var exists_1 = tslib_1.__importDefault(require_exists());
    var exists_source_1 = tslib_1.__importDefault(require_exists_source());
    var explain_1 = tslib_1.__importDefault(require_explain());
    var features_1 = tslib_1.__importDefault(require_features());
    var field_caps_1 = tslib_1.__importDefault(require_field_caps());
    var fleet_1 = tslib_1.__importDefault(require_fleet());
    var get_1 = tslib_1.__importDefault(require_get2());
    var get_script_1 = tslib_1.__importDefault(require_get_script());
    var get_script_context_1 = tslib_1.__importDefault(require_get_script_context());
    var get_script_languages_1 = tslib_1.__importDefault(require_get_script_languages());
    var get_source_1 = tslib_1.__importDefault(require_get_source());
    var graph_1 = tslib_1.__importDefault(require_graph());
    var health_report_1 = tslib_1.__importDefault(require_health_report());
    var ilm_1 = tslib_1.__importDefault(require_ilm());
    var index_1 = tslib_1.__importDefault(require_api2());
    var indices_1 = tslib_1.__importDefault(require_indices());
    var inference_1 = tslib_1.__importDefault(require_inference());
    var info_1 = tslib_1.__importDefault(require_info());
    var ingest_1 = tslib_1.__importDefault(require_ingest());
    var knn_search_1 = tslib_1.__importDefault(require_knn_search());
    var license_1 = tslib_1.__importDefault(require_license());
    var logstash_1 = tslib_1.__importDefault(require_logstash());
    var mget_1 = tslib_1.__importDefault(require_mget());
    var migration_1 = tslib_1.__importDefault(require_migration());
    var ml_1 = tslib_1.__importDefault(require_ml());
    var monitoring_1 = tslib_1.__importDefault(require_monitoring());
    var msearch_1 = tslib_1.__importDefault(require_msearch());
    var msearch_template_1 = tslib_1.__importDefault(require_msearch_template());
    var mtermvectors_1 = tslib_1.__importDefault(require_mtermvectors());
    var nodes_1 = tslib_1.__importDefault(require_nodes());
    var open_point_in_time_1 = tslib_1.__importDefault(require_open_point_in_time());
    var ping_1 = tslib_1.__importDefault(require_ping());
    var profiling_1 = tslib_1.__importDefault(require_profiling());
    var put_script_1 = tslib_1.__importDefault(require_put_script());
    var query_rules_1 = tslib_1.__importDefault(require_query_rules());
    var rank_eval_1 = tslib_1.__importDefault(require_rank_eval());
    var reindex_1 = tslib_1.__importDefault(require_reindex());
    var reindex_rethrottle_1 = tslib_1.__importDefault(require_reindex_rethrottle());
    var render_search_template_1 = tslib_1.__importDefault(require_render_search_template());
    var rollup_1 = tslib_1.__importDefault(require_rollup());
    var scripts_painless_execute_1 = tslib_1.__importDefault(require_scripts_painless_execute());
    var scroll_1 = tslib_1.__importDefault(require_scroll());
    var search_1 = tslib_1.__importDefault(require_search());
    var search_application_1 = tslib_1.__importDefault(require_search_application());
    var search_mvt_1 = tslib_1.__importDefault(require_search_mvt());
    var search_shards_1 = tslib_1.__importDefault(require_search_shards());
    var search_template_1 = tslib_1.__importDefault(require_search_template());
    var searchable_snapshots_1 = tslib_1.__importDefault(require_searchable_snapshots());
    var security_1 = tslib_1.__importDefault(require_security2());
    var shutdown_1 = tslib_1.__importDefault(require_shutdown());
    var simulate_1 = tslib_1.__importDefault(require_simulate());
    var slm_1 = tslib_1.__importDefault(require_slm());
    var snapshot_1 = tslib_1.__importDefault(require_snapshot());
    var sql_1 = tslib_1.__importDefault(require_sql());
    var ssl_1 = tslib_1.__importDefault(require_ssl());
    var synonyms_1 = tslib_1.__importDefault(require_synonyms());
    var tasks_1 = tslib_1.__importDefault(require_tasks());
    var terms_enum_1 = tslib_1.__importDefault(require_terms_enum());
    var termvectors_1 = tslib_1.__importDefault(require_termvectors());
    var text_structure_1 = tslib_1.__importDefault(require_text_structure());
    var transform_1 = tslib_1.__importDefault(require_transform());
    var update_1 = tslib_1.__importDefault(require_update());
    var update_by_query_1 = tslib_1.__importDefault(require_update_by_query());
    var update_by_query_rethrottle_1 = tslib_1.__importDefault(require_update_by_query_rethrottle());
    var watcher_1 = tslib_1.__importDefault(require_watcher());
    var xpack_1 = tslib_1.__importDefault(require_xpack());
    var kAsyncSearch = Symbol("AsyncSearch");
    var kAutoscaling = Symbol("Autoscaling");
    var kCat = Symbol("Cat");
    var kCcr = Symbol("Ccr");
    var kCluster = Symbol("Cluster");
    var kConnector = Symbol("Connector");
    var kDanglingIndices = Symbol("DanglingIndices");
    var kEnrich = Symbol("Enrich");
    var kEql = Symbol("Eql");
    var kEsql = Symbol("Esql");
    var kFeatures = Symbol("Features");
    var kFleet = Symbol("Fleet");
    var kGraph = Symbol("Graph");
    var kIlm = Symbol("Ilm");
    var kIndices = Symbol("Indices");
    var kInference = Symbol("Inference");
    var kIngest = Symbol("Ingest");
    var kLicense = Symbol("License");
    var kLogstash = Symbol("Logstash");
    var kMigration = Symbol("Migration");
    var kMl = Symbol("Ml");
    var kMonitoring = Symbol("Monitoring");
    var kNodes = Symbol("Nodes");
    var kProfiling = Symbol("Profiling");
    var kQueryRules = Symbol("QueryRules");
    var kRollup = Symbol("Rollup");
    var kSearchApplication = Symbol("SearchApplication");
    var kSearchableSnapshots = Symbol("SearchableSnapshots");
    var kSecurity = Symbol("Security");
    var kShutdown = Symbol("Shutdown");
    var kSimulate = Symbol("Simulate");
    var kSlm = Symbol("Slm");
    var kSnapshot = Symbol("Snapshot");
    var kSql = Symbol("Sql");
    var kSsl = Symbol("Ssl");
    var kSynonyms = Symbol("Synonyms");
    var kTasks = Symbol("Tasks");
    var kTextStructure = Symbol("TextStructure");
    var kTransform = Symbol("Transform");
    var kWatcher = Symbol("Watcher");
    var kXpack = Symbol("Xpack");
    var API = class {
      constructor() {
        Object.defineProperty(this, _a, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _b, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _c, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _d, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _e, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _f, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _g, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _h, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _j, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _k, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _l, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _m, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _o, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _p, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _q, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _r, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _s, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _t, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _u, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _v, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _w, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _x, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _y, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _z, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _0, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _1, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _2, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _3, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _4, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _5, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _6, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _7, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _8, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _9, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _10, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _11, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _12, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _13, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _14, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _15, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, _16, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this[kAsyncSearch] = null;
        this[kAutoscaling] = null;
        this[kCat] = null;
        this[kCcr] = null;
        this[kCluster] = null;
        this[kConnector] = null;
        this[kDanglingIndices] = null;
        this[kEnrich] = null;
        this[kEql] = null;
        this[kEsql] = null;
        this[kFeatures] = null;
        this[kFleet] = null;
        this[kGraph] = null;
        this[kIlm] = null;
        this[kIndices] = null;
        this[kInference] = null;
        this[kIngest] = null;
        this[kLicense] = null;
        this[kLogstash] = null;
        this[kMigration] = null;
        this[kMl] = null;
        this[kMonitoring] = null;
        this[kNodes] = null;
        this[kProfiling] = null;
        this[kQueryRules] = null;
        this[kRollup] = null;
        this[kSearchApplication] = null;
        this[kSearchableSnapshots] = null;
        this[kSecurity] = null;
        this[kShutdown] = null;
        this[kSimulate] = null;
        this[kSlm] = null;
        this[kSnapshot] = null;
        this[kSql] = null;
        this[kSsl] = null;
        this[kSynonyms] = null;
        this[kTasks] = null;
        this[kTextStructure] = null;
        this[kTransform] = null;
        this[kWatcher] = null;
        this[kXpack] = null;
      }
    };
    _a = kAsyncSearch, _b = kAutoscaling, _c = kCat, _d = kCcr, _e = kCluster, _f = kConnector, _g = kDanglingIndices, _h = kEnrich, _j = kEql, _k = kEsql, _l = kFeatures, _m = kFleet, _o = kGraph, _p = kIlm, _q = kIndices, _r = kInference, _s = kIngest, _t = kLicense, _u = kLogstash, _v = kMigration, _w = kMl, _x = kMonitoring, _y = kNodes, _z = kProfiling, _0 = kQueryRules, _1 = kRollup, _2 = kSearchApplication, _3 = kSearchableSnapshots, _4 = kSecurity, _5 = kShutdown, _6 = kSimulate, _7 = kSlm, _8 = kSnapshot, _9 = kSql, _10 = kSsl, _11 = kSynonyms, _12 = kTasks, _13 = kTextStructure, _14 = kTransform, _15 = kWatcher, _16 = kXpack;
    exports2.default = API;
    API.prototype.bulk = bulk_1.default;
    API.prototype.capabilities = capabilities_1.default;
    API.prototype.clearScroll = clear_scroll_1.default;
    API.prototype.closePointInTime = close_point_in_time_1.default;
    API.prototype.count = count_1.default;
    API.prototype.create = create_1.default;
    API.prototype.delete = delete_1.default;
    API.prototype.deleteByQuery = delete_by_query_1.default;
    API.prototype.deleteByQueryRethrottle = delete_by_query_rethrottle_1.default;
    API.prototype.deleteScript = delete_script_1.default;
    API.prototype.exists = exists_1.default;
    API.prototype.existsSource = exists_source_1.default;
    API.prototype.explain = explain_1.default;
    API.prototype.fieldCaps = field_caps_1.default;
    API.prototype.get = get_1.default;
    API.prototype.getScript = get_script_1.default;
    API.prototype.getScriptContext = get_script_context_1.default;
    API.prototype.getScriptLanguages = get_script_languages_1.default;
    API.prototype.getSource = get_source_1.default;
    API.prototype.healthReport = health_report_1.default;
    API.prototype.index = index_1.default;
    API.prototype.info = info_1.default;
    API.prototype.knnSearch = knn_search_1.default;
    API.prototype.mget = mget_1.default;
    API.prototype.msearch = msearch_1.default;
    API.prototype.msearchTemplate = msearch_template_1.default;
    API.prototype.mtermvectors = mtermvectors_1.default;
    API.prototype.openPointInTime = open_point_in_time_1.default;
    API.prototype.ping = ping_1.default;
    API.prototype.putScript = put_script_1.default;
    API.prototype.rankEval = rank_eval_1.default;
    API.prototype.reindex = reindex_1.default;
    API.prototype.reindexRethrottle = reindex_rethrottle_1.default;
    API.prototype.renderSearchTemplate = render_search_template_1.default;
    API.prototype.scriptsPainlessExecute = scripts_painless_execute_1.default;
    API.prototype.scroll = scroll_1.default;
    API.prototype.search = search_1.default;
    API.prototype.searchMvt = search_mvt_1.default;
    API.prototype.searchShards = search_shards_1.default;
    API.prototype.searchTemplate = search_template_1.default;
    API.prototype.termsEnum = terms_enum_1.default;
    API.prototype.termvectors = termvectors_1.default;
    API.prototype.update = update_1.default;
    API.prototype.updateByQuery = update_by_query_1.default;
    API.prototype.updateByQueryRethrottle = update_by_query_rethrottle_1.default;
    Object.defineProperties(API.prototype, {
      asyncSearch: {
        get() {
          return this[kAsyncSearch] === null ? this[kAsyncSearch] = new async_search_1.default(this.transport) : this[kAsyncSearch];
        }
      },
      autoscaling: {
        get() {
          return this[kAutoscaling] === null ? this[kAutoscaling] = new autoscaling_1.default(this.transport) : this[kAutoscaling];
        }
      },
      cat: {
        get() {
          return this[kCat] === null ? this[kCat] = new cat_1.default(this.transport) : this[kCat];
        }
      },
      ccr: {
        get() {
          return this[kCcr] === null ? this[kCcr] = new ccr_1.default(this.transport) : this[kCcr];
        }
      },
      cluster: {
        get() {
          return this[kCluster] === null ? this[kCluster] = new cluster_1.default(this.transport) : this[kCluster];
        }
      },
      connector: {
        get() {
          return this[kConnector] === null ? this[kConnector] = new connector_1.default(this.transport) : this[kConnector];
        }
      },
      danglingIndices: {
        get() {
          return this[kDanglingIndices] === null ? this[kDanglingIndices] = new dangling_indices_1.default(this.transport) : this[kDanglingIndices];
        }
      },
      enrich: {
        get() {
          return this[kEnrich] === null ? this[kEnrich] = new enrich_1.default(this.transport) : this[kEnrich];
        }
      },
      eql: {
        get() {
          return this[kEql] === null ? this[kEql] = new eql_1.default(this.transport) : this[kEql];
        }
      },
      esql: {
        get() {
          return this[kEsql] === null ? this[kEsql] = new esql_1.default(this.transport) : this[kEsql];
        }
      },
      features: {
        get() {
          return this[kFeatures] === null ? this[kFeatures] = new features_1.default(this.transport) : this[kFeatures];
        }
      },
      fleet: {
        get() {
          return this[kFleet] === null ? this[kFleet] = new fleet_1.default(this.transport) : this[kFleet];
        }
      },
      graph: {
        get() {
          return this[kGraph] === null ? this[kGraph] = new graph_1.default(this.transport) : this[kGraph];
        }
      },
      ilm: {
        get() {
          return this[kIlm] === null ? this[kIlm] = new ilm_1.default(this.transport) : this[kIlm];
        }
      },
      indices: {
        get() {
          return this[kIndices] === null ? this[kIndices] = new indices_1.default(this.transport) : this[kIndices];
        }
      },
      inference: {
        get() {
          return this[kInference] === null ? this[kInference] = new inference_1.default(this.transport) : this[kInference];
        }
      },
      ingest: {
        get() {
          return this[kIngest] === null ? this[kIngest] = new ingest_1.default(this.transport) : this[kIngest];
        }
      },
      license: {
        get() {
          return this[kLicense] === null ? this[kLicense] = new license_1.default(this.transport) : this[kLicense];
        }
      },
      logstash: {
        get() {
          return this[kLogstash] === null ? this[kLogstash] = new logstash_1.default(this.transport) : this[kLogstash];
        }
      },
      migration: {
        get() {
          return this[kMigration] === null ? this[kMigration] = new migration_1.default(this.transport) : this[kMigration];
        }
      },
      ml: {
        get() {
          return this[kMl] === null ? this[kMl] = new ml_1.default(this.transport) : this[kMl];
        }
      },
      monitoring: {
        get() {
          return this[kMonitoring] === null ? this[kMonitoring] = new monitoring_1.default(this.transport) : this[kMonitoring];
        }
      },
      nodes: {
        get() {
          return this[kNodes] === null ? this[kNodes] = new nodes_1.default(this.transport) : this[kNodes];
        }
      },
      profiling: {
        get() {
          return this[kProfiling] === null ? this[kProfiling] = new profiling_1.default(this.transport) : this[kProfiling];
        }
      },
      queryRules: {
        get() {
          return this[kQueryRules] === null ? this[kQueryRules] = new query_rules_1.default(this.transport) : this[kQueryRules];
        }
      },
      rollup: {
        get() {
          return this[kRollup] === null ? this[kRollup] = new rollup_1.default(this.transport) : this[kRollup];
        }
      },
      searchApplication: {
        get() {
          return this[kSearchApplication] === null ? this[kSearchApplication] = new search_application_1.default(this.transport) : this[kSearchApplication];
        }
      },
      searchableSnapshots: {
        get() {
          return this[kSearchableSnapshots] === null ? this[kSearchableSnapshots] = new searchable_snapshots_1.default(this.transport) : this[kSearchableSnapshots];
        }
      },
      security: {
        get() {
          return this[kSecurity] === null ? this[kSecurity] = new security_1.default(this.transport) : this[kSecurity];
        }
      },
      shutdown: {
        get() {
          return this[kShutdown] === null ? this[kShutdown] = new shutdown_1.default(this.transport) : this[kShutdown];
        }
      },
      simulate: {
        get() {
          return this[kSimulate] === null ? this[kSimulate] = new simulate_1.default(this.transport) : this[kSimulate];
        }
      },
      slm: {
        get() {
          return this[kSlm] === null ? this[kSlm] = new slm_1.default(this.transport) : this[kSlm];
        }
      },
      snapshot: {
        get() {
          return this[kSnapshot] === null ? this[kSnapshot] = new snapshot_1.default(this.transport) : this[kSnapshot];
        }
      },
      sql: {
        get() {
          return this[kSql] === null ? this[kSql] = new sql_1.default(this.transport) : this[kSql];
        }
      },
      ssl: {
        get() {
          return this[kSsl] === null ? this[kSsl] = new ssl_1.default(this.transport) : this[kSsl];
        }
      },
      synonyms: {
        get() {
          return this[kSynonyms] === null ? this[kSynonyms] = new synonyms_1.default(this.transport) : this[kSynonyms];
        }
      },
      tasks: {
        get() {
          return this[kTasks] === null ? this[kTasks] = new tasks_1.default(this.transport) : this[kTasks];
        }
      },
      textStructure: {
        get() {
          return this[kTextStructure] === null ? this[kTextStructure] = new text_structure_1.default(this.transport) : this[kTextStructure];
        }
      },
      transform: {
        get() {
          return this[kTransform] === null ? this[kTransform] = new transform_1.default(this.transport) : this[kTransform];
        }
      },
      watcher: {
        get() {
          return this[kWatcher] === null ? this[kWatcher] = new watcher_1.default(this.transport) : this[kWatcher];
        }
      },
      xpack: {
        get() {
          return this[kXpack] === null ? this[kXpack] = new xpack_1.default(this.transport) : this[kXpack];
        }
      }
    });
  }
});

// node_modules/@elastic/elasticsearch/package.json
var require_package2 = __commonJS({
  "node_modules/@elastic/elasticsearch/package.json"(exports2, module2) {
    module2.exports = {
      name: "@elastic/elasticsearch",
      version: "9.0.2",
      versionCanary: "9.0.2-canary.0",
      description: "The official Elasticsearch client for Node.js",
      main: "./index.js",
      types: "index.d.ts",
      exports: {
        require: "./index.js",
        import: "./index.js",
        types: "./index.d.ts"
      },
      scripts: {
        test: "npm run build && npm run lint && tap",
        "test:unit": "npm run build && tap",
        "test:unit-bun": "bun run build && bunx tap",
        "test:esm": "npm run build && cd test/esm/ && npm install && node test-import.mjs",
        "test:coverage-100": "npm run build && tap --coverage --100",
        "test:coverage-report": "npm run build && tap --coverage && nyc report --reporter=text-lcov > coverage.lcov",
        "test:coverage-ui": "npm run build && tap --coverage --coverage-report=html",
        "test:integration-build": "npm run build && node test/integration/index.js",
        "test:integration": "npm run test:integration-build && env tap run --jobs=1 --reporter=junit --reporter-file=report-junit.xml generated-tests/",
        lint: "ts-standard src",
        "lint:fix": "ts-standard --fix src",
        "license-checker": "license-checker --production --onlyAllow='MIT;Apache-2.0;Apache1.1;ISC;BSD-3-Clause;BSD-2-Clause;0BSD'",
        "license-header": "./scripts/check-spdx",
        prebuild: "npm run clean-build && npm run lint",
        build: "tsc && rm lib/package.json && mv lib/src/* lib/ && rm -rf lib/src",
        "clean-build": "rimraf ./lib && mkdir lib",
        prepublishOnly: "npm run build"
      },
      keywords: [
        "elasticsearch",
        "elastic",
        "kibana",
        "mapping",
        "REST",
        "search",
        "client",
        "index"
      ],
      contributors: [
        {
          name: "Elastic Client Library Maintainers",
          company: "Elastic BV"
        }
      ],
      license: "Apache-2.0",
      repository: {
        type: "git",
        url: "https://github.com/elastic/elasticsearch-js.git"
      },
      bugs: {
        url: "https://github.com/elastic/elasticsearch-js/issues"
      },
      homepage: "http://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html",
      engines: {
        node: ">=18"
      },
      devDependencies: {
        "@elastic/request-converter": "8.17.0",
        "@sinonjs/fake-timers": "14.0.0",
        "@types/debug": "4.1.12",
        "@types/ms": "0.7.34",
        "@types/node": "22.13.5",
        "@types/sinonjs__fake-timers": "8.1.5",
        "@types/split2": "4.2.3",
        "@types/stoppable": "1.1.3",
        chai: "5.2.0",
        "cross-zip": "4.0.1",
        desm: "1.3.1",
        "into-stream": "8.0.1",
        "js-yaml": "4.1.0",
        "license-checker": "25.0.1",
        minimist: "1.2.8",
        ms: "2.1.3",
        "node-abort-controller": "3.1.1",
        "node-fetch": "2.7.0",
        ora: "5.4.1",
        proxy: "1.0.2",
        rimraf: "5.0.10",
        semver: "7.7.1",
        split2: "4.2.0",
        stoppable: "1.1.0",
        tap: "21.0.2",
        "ts-node": "10.9.2",
        "ts-standard": "12.0.2",
        typescript: "5.7.3",
        workq: "3.0.0",
        xmlbuilder2: "3.1.1",
        zx: "7.2.3"
      },
      dependencies: {
        "@elastic/transport": "^9.0.1",
        "apache-arrow": "18.x - 19.x",
        tslib: "^2.4.0"
      },
      tap: {
        "disable-coverage": true,
        files: [
          "test/unit/{*,**/*}.test.ts"
        ]
      }
    };
  }
});

// node_modules/@elastic/elasticsearch/lib/client.js
var require_client2 = __commonJS({
  "node_modules/@elastic/elasticsearch/lib/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_process_1 = tslib_1.__importDefault(require("node:process"));
    var node_url_1 = require("node:url");
    var node_buffer_1 = tslib_1.__importDefault(require("node:buffer"));
    var node_os_1 = tslib_1.__importDefault(require("node:os"));
    var transport_1 = require_transport();
    var BaseConnection_1 = require_BaseConnection();
    var sniffingTransport_1 = tslib_1.__importDefault(require_sniffingTransport());
    var helpers_1 = tslib_1.__importDefault(require_helpers());
    var api_1 = tslib_1.__importDefault(require_api3());
    var package_json_1 = tslib_1.__importDefault(require_package2());
    var package_json_2 = tslib_1.__importDefault(require_package());
    var kChild = Symbol("elasticsearchjs-child");
    var kInitialOptions = Symbol("elasticsearchjs-initial-options");
    var clientVersion = package_json_1.default.version;
    if (clientVersion.includes("-")) {
      clientVersion = clientVersion.slice(0, clientVersion.indexOf("-")) + "p";
    }
    var transportVersion = package_json_2.default.version;
    if (transportVersion.includes("-")) {
      transportVersion = transportVersion.slice(0, transportVersion.indexOf("-")) + "p";
    }
    var nodeVersion = node_process_1.default.versions.node;
    var serverlessApiVersion = "2023-10-31";
    var Client3 = class _Client extends api_1.default {
      constructor(opts) {
        var _a, _b, _c, _d;
        super();
        Object.defineProperty(this, "diagnostic", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "connectionPool", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "transport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "serializer", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "helpers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        if ((opts.cloud != null || opts.serverMode === "serverless") && opts[kChild] === void 0) {
          if (opts.cloud != null) {
            const { id } = opts.cloud;
            if (typeof id !== "string") {
              throw new transport_1.errors.ConfigurationError("Cloud ID must be a string.");
            }
            const parts = id.split(":");
            if (parts.length !== 2 || parts[1] === "") {
              throw new transport_1.errors.ConfigurationError('Cloud ID must be in the format "name:base64string".');
            }
            let cloudUrls;
            try {
              cloudUrls = Buffer.from(parts[1], "base64").toString().split("$");
            } catch (err) {
              throw new transport_1.errors.ConfigurationError("Cloud ID base64 decoding failed.");
            }
            if (cloudUrls.length < 2 || cloudUrls[0] === "" || cloudUrls[1] === "") {
              throw new transport_1.errors.ConfigurationError('Cloud ID base64 must contain at least two "$" separated parts: "<cloudUrl>$<esId>[$<kibanaId>]".');
            }
            opts.node = `https://${cloudUrls[1]}.${cloudUrls[0]}`;
          }
          if (opts.compression == null)
            opts.compression = true;
          if (opts.tls == null || opts.tls != null && opts.tls.secureProtocol == null) {
            opts.tls = (_a = opts.tls) !== null && _a !== void 0 ? _a : {};
            opts.tls.secureProtocol = "TLSv1_2_method";
          }
        }
        if (opts.node == null && opts.nodes == null) {
          throw new transport_1.errors.ConfigurationError("Missing node(s) option");
        }
        if (opts[kChild] === void 0) {
          const checkAuth = getAuth((_b = opts.node) !== null && _b !== void 0 ? _b : opts.nodes);
          if (checkAuth != null && checkAuth.username !== "" && checkAuth.password !== "") {
            opts.auth = Object.assign({}, opts.auth, { username: checkAuth.username, password: checkAuth.password });
          }
        }
        const headers = {
          "user-agent": `elasticsearch-js/${clientVersion} (${node_os_1.default.platform()} ${node_os_1.default.release()}-${node_os_1.default.arch()}; Node.js ${nodeVersion}; Transport ${transportVersion})`
        };
        if (opts.serverMode === "serverless")
          headers["elastic-api-version"] = serverlessApiVersion;
        const options = Object.assign({}, {
          Connection: transport_1.UndiciConnection,
          Transport: opts.serverMode === "serverless" ? transport_1.Transport : sniffingTransport_1.default,
          Serializer: transport_1.Serializer,
          ConnectionPool: opts.cloud != null || opts.serverMode === "serverless" ? transport_1.CloudConnectionPool : transport_1.WeightedConnectionPool,
          maxRetries: 3,
          pingTimeout: 3e3,
          sniffInterval: false,
          sniffOnStart: false,
          sniffEndpoint: "_nodes/_all/http",
          sniffOnConnectionFault: false,
          resurrectStrategy: "ping",
          compression: false,
          tls: null,
          caFingerprint: null,
          agent: null,
          headers,
          nodeFilter: null,
          generateRequestId: null,
          name: "elasticsearch-js",
          auth: null,
          opaqueIdPrefix: null,
          context: null,
          proxy: null,
          enableMetaHeader: true,
          maxResponseSize: null,
          maxCompressedResponseSize: null,
          redaction: {
            type: "replace",
            additionalKeys: []
          },
          serverMode: "stack"
        }, opts);
        if (options.caFingerprint != null && isHttpConnection((_c = opts.node) !== null && _c !== void 0 ? _c : opts.nodes)) {
          throw new transport_1.errors.ConfigurationError("You can't configure the caFingerprint with a http connection");
        }
        if (options.maxResponseSize != null && options.maxResponseSize > node_buffer_1.default.constants.MAX_STRING_LENGTH) {
          throw new transport_1.errors.ConfigurationError(`The maxResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_STRING_LENGTH}`);
        }
        if (options.maxCompressedResponseSize != null && options.maxCompressedResponseSize > node_buffer_1.default.constants.MAX_LENGTH) {
          throw new transport_1.errors.ConfigurationError(`The maxCompressedResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_LENGTH}`);
        }
        if (options.enableMetaHeader) {
          let clientMeta = `es=${clientVersion},js=${nodeVersion},t=${transportVersion}`;
          if (options.Connection === transport_1.UndiciConnection) {
            clientMeta += `,un=${nodeVersion}`;
          } else {
            clientMeta += `,hc=${nodeVersion}`;
          }
          options.headers["x-elastic-client-meta"] = clientMeta;
        }
        this.name = options.name;
        this[kInitialOptions] = options;
        if (opts[kChild] !== void 0) {
          this.serializer = opts[kChild].serializer;
          this.connectionPool = opts[kChild].connectionPool;
          this.diagnostic = opts[kChild].diagnostic;
        } else {
          this.diagnostic = new transport_1.Diagnostic();
          let serializerOptions;
          if (opts.disablePrototypePoisoningProtection != null) {
            if (typeof opts.disablePrototypePoisoningProtection === "boolean") {
              serializerOptions = {
                enablePrototypePoisoningProtection: !opts.disablePrototypePoisoningProtection
              };
            } else {
              serializerOptions = {
                enablePrototypePoisoningProtection: opts.disablePrototypePoisoningProtection
              };
            }
          }
          this.serializer = new options.Serializer(serializerOptions);
          this.connectionPool = new options.ConnectionPool({
            pingTimeout: options.pingTimeout,
            resurrectStrategy: options.resurrectStrategy,
            tls: options.tls,
            agent: options.agent,
            proxy: options.proxy,
            Connection: options.Connection,
            auth: options.auth,
            diagnostic: this.diagnostic,
            caFingerprint: options.caFingerprint
          });
          let nodes = (_d = options.node) !== null && _d !== void 0 ? _d : options.nodes;
          if (options.serverMode === "serverless" && Array.isArray(nodes)) {
            nodes = nodes[0];
          }
          let nodeOptions = Array.isArray(nodes) ? nodes : [nodes];
          nodeOptions = nodeOptions.map((opt) => {
            const { tls, headers: headers2, auth, requestTimeout: timeout, agent, proxy, caFingerprint } = options;
            let defaults = { tls, headers: headers2, auth, timeout, agent, proxy, caFingerprint };
            defaults = Object.keys(defaults).reduce((acc, key) => {
              const val = defaults[key];
              if (val !== void 0)
                acc[key] = val;
              return acc;
            }, {});
            let newOpts;
            if (typeof opt === "string") {
              newOpts = {
                url: new node_url_1.URL(opt)
              };
            } else {
              newOpts = opt;
            }
            return { ...defaults, ...newOpts };
          });
          this.connectionPool.addConnection(nodeOptions);
        }
        let transportOptions = {
          diagnostic: this.diagnostic,
          connectionPool: this.connectionPool,
          serializer: this.serializer,
          maxRetries: options.maxRetries,
          requestTimeout: options.requestTimeout,
          compression: options.compression,
          headers: options.headers,
          generateRequestId: options.generateRequestId,
          name: options.name,
          opaqueIdPrefix: options.opaqueIdPrefix,
          context: options.context,
          productCheck: "Elasticsearch",
          maxResponseSize: options.maxResponseSize,
          maxCompressedResponseSize: options.maxCompressedResponseSize,
          redaction: options.redaction
        };
        if (options.serverMode !== "serverless") {
          transportOptions = Object.assign({}, transportOptions, {
            sniffInterval: options.sniffInterval,
            sniffOnStart: options.sniffOnStart,
            sniffOnConnectionFault: options.sniffOnConnectionFault,
            sniffEndpoint: options.sniffEndpoint,
            nodeFilter: options.nodeFilter,
            nodeSelector: options.nodeSelector,
            vendoredHeaders: {
              jsonContentType: "application/vnd.elasticsearch+json; compatible-with=9",
              ndjsonContentType: "application/vnd.elasticsearch+x-ndjson; compatible-with=9",
              accept: "application/vnd.elasticsearch+json; compatible-with=9,text/plain"
            }
          });
        }
        this.transport = new options.Transport(transportOptions);
        this.helpers = new helpers_1.default({
          client: this,
          metaHeader: options.enableMetaHeader ? `es=${clientVersion},js=${nodeVersion},t=${transportVersion},hc=${nodeVersion}` : null,
          maxRetries: options.maxRetries
        });
      }
      /**
       * Creates a child client instance that shared its connection pool with the parent client
       * @see {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/child.html}
       */
      child(opts) {
        const options = Object.assign({}, this[kInitialOptions], opts);
        options[kChild] = {
          connectionPool: this.connectionPool,
          serializer: this.serializer,
          diagnostic: this.diagnostic,
          initialOptions: options
        };
        if (options.auth !== void 0) {
          options.headers = (0, BaseConnection_1.prepareHeaders)(options.headers, options.auth);
        }
        return new _Client(options);
      }
      /**
       * Closes all connections in the connection pool. Connections shared with any parent or child instances will also be closed.
       */
      async close() {
        return await this.connectionPool.empty();
      }
    };
    exports2.default = Client3;
    function isHttpConnection(node) {
      if (Array.isArray(node)) {
        return node.some((n) => (typeof n === "string" ? new node_url_1.URL(n).protocol : n.url.protocol) === "http:");
      } else {
        if (node == null)
          return false;
        return (typeof node === "string" ? new node_url_1.URL(node).protocol : node.url.protocol) === "http:";
      }
    }
    function getAuth(node) {
      if (Array.isArray(node)) {
        for (const url of node) {
          const auth = getUsernameAndPassword(url);
          if (auth != null && auth.username !== "" && auth.password !== "") {
            return auth;
          }
        }
        return null;
      } else {
        const auth = getUsernameAndPassword(node);
        if (auth != null && auth.username !== "" && auth.password !== "") {
          return auth;
        }
        return null;
      }
      function getUsernameAndPassword(node2) {
        if (typeof node2 === "string") {
          const { username, password } = new node_url_1.URL(node2);
          return {
            username: decodeURIComponent(username),
            password: decodeURIComponent(password)
          };
        } else if (node2 != null && node2.url instanceof node_url_1.URL) {
          return {
            username: decodeURIComponent(node2.url.username),
            password: decodeURIComponent(node2.url.password)
          };
        } else {
          return null;
        }
      }
    }
  }
});

// node_modules/@elastic/elasticsearch/index.js
var require_elasticsearch = __commonJS({
  "node_modules/@elastic/elasticsearch/index.js"(exports2, module2) {
    "use strict";
    var {
      Diagnostic,
      Transport,
      WeightedConnectionPool,
      ClusterConnectionPool,
      BaseConnectionPool,
      CloudConnectionPool,
      BaseConnection,
      HttpConnection,
      UndiciConnection,
      Serializer,
      errors,
      events
    } = require_transport();
    var { default: Client3 } = require_client2();
    var { default: SniffingTransport } = require_sniffingTransport();
    module2.exports = {
      Client: Client3,
      SniffingTransport,
      Diagnostic,
      Transport,
      WeightedConnectionPool,
      ClusterConnectionPool,
      BaseConnectionPool,
      CloudConnectionPool,
      BaseConnection,
      HttpConnection,
      UndiciConnection,
      Serializer,
      errors,
      events
    };
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(extension_exports);
var vscode2 = __toESM(require("vscode"));
var import_elasticsearch2 = __toESM(require_elasticsearch());

// src/tree/ESExplorerProvider.ts
var vscode = __toESM(require("vscode"));
var import_elasticsearch = __toESM(require_elasticsearch());
var ESExplorerProvider = class {
  constructor(context2) {
    this._onDidChangeTreeData = new vscode.EventEmitter();
    this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    this.clusters = /* @__PURE__ */ new Map();
    this.clients = /* @__PURE__ */ new Map();
    this.clusterHealth = /* @__PURE__ */ new Map();
    this.autoRefreshEnabled = false;
    this.dataStreamStatsSums = /* @__PURE__ */ new Map();
    this.dataStreamParentItems = /* @__PURE__ */ new Map();
    this.context = context2;
    this.loadClusters();
    this.autoRefreshEnabled = context2.globalState.get("esExt.autoRefreshEnabled", false);
    if (this.autoRefreshEnabled) {
      this.startAutoRefresh();
    }
  }
  getActiveClient() {
    return this.activeClusterId ? this.clients.get(this.activeClusterId) : void 0;
  }
  // Public method to get a client by clusterId
  getClient(clusterId) {
    if (clusterId) return this.clients.get(clusterId);
    return this.getActiveClient();
  }
  getActiveCluster() {
    return this.activeClusterId ? this.clusters.get(this.activeClusterId) : void 0;
  }
  getCluster(clusterId) {
    return this.clusters.get(clusterId);
  }
  setActiveCluster(clusterId) {
    this.activeClusterId = clusterId;
    this.refresh();
  }
  async loadClustersOnStartup() {
    await this.loadClusters();
    await this.autoReconnectClusters();
    this.refresh();
  }
  async addCluster(config) {
    this.clusters.set(config.id, config);
    await this.saveClusterConfig(config);
    if (!this.activeClusterId) {
      this.activeClusterId = config.id;
    }
    this.refresh();
  }
  async removeCluster(clusterId) {
    this.clusters.delete(clusterId);
    this.clients.delete(clusterId);
    await this.removeConnectedCluster(clusterId);
    await this.context.secrets.delete(`esExt.cluster.${clusterId}.config`);
    await this.context.secrets.delete(`esExt.cluster.${clusterId}.username`);
    await this.context.secrets.delete(`esExt.cluster.${clusterId}.password`);
    await this.context.secrets.delete(`esExt.cluster.${clusterId}.apiKey`);
    if (this.activeClusterId === clusterId) {
      this.activeClusterId = this.clusters.size > 0 ? Array.from(this.clusters.keys())[0] : void 0;
    }
    this.refresh();
  }
  toggleAutoRefresh() {
    this.autoRefreshEnabled = !this.autoRefreshEnabled;
    this.context.globalState.update("esExt.autoRefreshEnabled", this.autoRefreshEnabled);
    if (this.autoRefreshEnabled) {
      vscode.window.showInformationMessage("Auto-refresh enabled: Health status will update every 60 seconds");
      this.startAutoRefresh();
    } else {
      vscode.window.showInformationMessage("Auto-refresh disabled");
      this.stopAutoRefresh();
    }
  }
  startAutoRefresh() {
    this.stopAutoRefresh();
    this.refreshTimer = setInterval(() => {
      this.refreshClusterHealth();
    }, 6e4);
    this.refreshClusterHealth();
  }
  stopAutoRefresh() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
      this.refreshTimer = void 0;
    }
  }
  async refreshClusterHealth() {
    for (const [clusterId, client] of this.clients) {
      try {
        const healthResponse = await client.cluster.health();
        const health = healthResponse.body || healthResponse;
        this.clusterHealth.set(clusterId, {
          status: health.status || "unknown",
          clusterName: health.cluster_name || "Unknown",
          numberOfNodes: health.number_of_nodes || 0,
          numberOfDataNodes: health.number_of_data_nodes || 0,
          activePrimaryShards: health.active_primary_shards || 0,
          activeShards: health.active_shards || 0,
          lastChecked: /* @__PURE__ */ new Date()
        });
      } catch (error) {
        this.clusterHealth.set(clusterId, {
          status: "unknown",
          clusterName: "Unknown",
          numberOfNodes: 0,
          numberOfDataNodes: 0,
          activePrimaryShards: 0,
          activeShards: 0,
          lastChecked: /* @__PURE__ */ new Date()
        });
      }
    }
    this.refresh();
  }
  getAutoRefreshStatus() {
    return this.autoRefreshEnabled;
  }
  dispose() {
    this.stopAutoRefresh();
  }
  async connectToCluster(clusterId) {
    const config = this.clusters.get(clusterId);
    if (!config) {
      vscode.window.showErrorMessage(`Cluster ${clusterId} not found`);
      return false;
    }
    let credentials = {};
    if (config.authMethod === "Basic: Username/Password") {
      let username = await this.context.secrets.get(`esExt.cluster.${clusterId}.username`);
      let password = await this.context.secrets.get(`esExt.cluster.${clusterId}.password`);
      if (!username || !password) {
        username = await vscode.window.showInputBox({ prompt: "Username for " + config.name });
        password = username ? await vscode.window.showInputBox({ prompt: "Password", password: true }) : void 0;
        if (!username || !password) {
          vscode.window.showWarningMessage("Username and password are required to connect.");
          return false;
        }
        credentials = { username, password };
        await this.context.secrets.store(`esExt.cluster.${clusterId}.username`, username);
        await this.context.secrets.store(`esExt.cluster.${clusterId}.password`, password);
      }
    } else if (config.authMethod === "API Key") {
      let apiKey = await this.context.secrets.get(`esExt.cluster.${clusterId}.apiKey`);
      if (!apiKey) {
        apiKey = await vscode.window.showInputBox({ prompt: "API Key for " + config.name });
        if (!apiKey) {
          vscode.window.showWarningMessage("API Key is required to connect.");
          return false;
        }
        credentials = { apiKey };
        await this.context.secrets.store(`esExt.cluster.${clusterId}.apiKey`, apiKey);
      }
    }
    return vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: `Connecting to ${config.name}...`,
      cancellable: false
    }, async (progress) => {
      progress.report({ increment: 50, message: "Establishing connection..." });
      try {
        const clientOptions = {};
        if (config.deploymentType === "Elastic Cloud") {
          clientOptions.cloud = { id: config.cloudId };
        } else {
          clientOptions.node = config.nodeUrl;
        }
        if (config.authMethod === "Basic: Username/Password") {
          const username = await this.context.secrets.get(`esExt.cluster.${clusterId}.username`);
          const password = await this.context.secrets.get(`esExt.cluster.${clusterId}.password`);
          if (username && password) {
            clientOptions.auth = { username, password };
          }
        } else if (config.authMethod === "API Key") {
          const apiKey = await this.context.secrets.get(`esExt.cluster.${clusterId}.apiKey`);
          if (apiKey) {
            clientOptions.auth = { apiKey };
          }
        }
        if (config.disableSSL) {
          clientOptions.ssl = { rejectUnauthorized: false };
          process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
        }
        const caCert = await this.context.globalState.get("esExt.caCertificate");
        if (caCert) {
          clientOptions.tls = clientOptions.tls || {};
          clientOptions.tls.ca = Buffer.from(caCert, "utf8");
        }
        progress.report({ increment: 30, message: "Testing connection..." });
        const client = new import_elasticsearch.Client(clientOptions);
        await client.ping();
        this.clients.set(clusterId, client);
        this.activeClusterId = clusterId;
        await this.saveConnectedCluster(clusterId);
        progress.report({ increment: 20, message: "Connected successfully!" });
        try {
          const healthResponse = await client.cluster.health();
          const health = healthResponse.body || healthResponse;
          this.clusterHealth.set(clusterId, {
            status: health.status || "unknown",
            clusterName: health.cluster_name || "Unknown",
            numberOfNodes: health.number_of_nodes || 0,
            numberOfDataNodes: health.number_of_data_nodes || 0,
            activePrimaryShards: health.active_primary_shards || 0,
            activeShards: health.active_shards || 0,
            lastChecked: /* @__PURE__ */ new Date()
          });
        } catch (healthError) {
          this.clusterHealth.set(clusterId, {
            status: "unknown",
            clusterName: "Unknown",
            numberOfNodes: 0,
            numberOfDataNodes: 0,
            activePrimaryShards: 0,
            activeShards: 0,
            lastChecked: /* @__PURE__ */ new Date()
          });
        }
        return true;
      } catch (err) {
        console.error(`[ESExt] Failed to connect to cluster ${clusterId}:`, err);
        vscode.window.showErrorMessage(`Failed to connect to ${config.name}: ${err.message}`);
        return false;
      }
    });
  }
  refresh() {
    this._onDidChangeTreeData.fire();
  }
  getTreeItem(element) {
    return element;
  }
  async getChildren(element) {
    if (!element) {
      const items = [];
      if (this.clusters.size === 0) {
        const addClusterItem = new ExplorerItem("Add Elasticsearch Cluster", "addCluster", vscode.TreeItemCollapsibleState.None);
        addClusterItem.command = { command: "esExt.addCluster", title: "Add Cluster" };
        addClusterItem.iconPath = new vscode.ThemeIcon("add");
        return [addClusterItem];
      }
      for (const [id, config] of this.clusters) {
        const isActive = id === this.activeClusterId;
        const isConnected = this.clients.has(id);
        const health = this.clusterHealth.get(id);
        let statusText = "";
        let healthText = "";
        let healthIcon = new vscode.ThemeIcon("circle-outline", new vscode.ThemeColor("disabledForeground"));
        if (isConnected) {
          statusText = " (Connected)";
          if (health) {
            switch (health.status) {
              case "green":
                healthText = " (Healthy)";
                healthIcon = new vscode.ThemeIcon("circle-filled", new vscode.ThemeColor("testing.iconPassed"));
                break;
              case "yellow":
                healthText = " (Warning)";
                healthIcon = new vscode.ThemeIcon("warning", new vscode.ThemeColor("editorWarning.foreground"));
                break;
              case "red":
                healthText = " (Critical)";
                healthIcon = new vscode.ThemeIcon("error", new vscode.ThemeColor("editorError.foreground"));
                break;
              case "unknown":
                healthText = " (Unknown)";
                healthIcon = new vscode.ThemeIcon("question", new vscode.ThemeColor("disabledForeground"));
                break;
            }
          }
        } else {
          healthIcon = new vscode.ThemeIcon("circle-outline", new vscode.ThemeColor("disabledForeground"));
        }
        let nodeInfoText = "";
        if (isConnected && health) {
          nodeInfoText = ` [${health.numberOfNodes} nodes, ${health.numberOfDataNodes} data]`;
        }
        const label = `${config.name}${statusText}${healthText}${nodeInfoText}`;
        const clusterItem = new ExplorerItem(label, `cluster:${id}`, vscode.TreeItemCollapsibleState.Collapsed);
        clusterItem.iconPath = healthIcon;
        clusterItem.tooltip = `${config.deploymentType} - ${config.nodeUrl || config.cloudId}${health ? `
Status: ${health.status}
Nodes: ${health.numberOfNodes}
Last checked: ${health.lastChecked.toLocaleTimeString()}` : ""}`;
        items.push(clusterItem);
      }
      const addItem = new ExplorerItem("Add Cluster", "addCluster", vscode.TreeItemCollapsibleState.None);
      addItem.command = { command: "esExt.addCluster", title: "Add Cluster" };
      addItem.iconPath = new vscode.ThemeIcon("add");
      addItem.tooltip = "Add a new Elasticsearch cluster";
      items.push(addItem);
      return items;
    }
    if (element.contextValue?.startsWith("cluster:")) {
      const clusterId = element.contextValue.split(":")[1];
      const config = this.clusters.get(clusterId);
      const isConnected = this.clients.has(clusterId);
      const items = [];
      if (!isConnected) {
        const connectItem = new ExplorerItem(`Connect to ${config?.name}`, "connect", vscode.TreeItemCollapsibleState.None);
        connectItem.command = {
          command: "esExt.connectToCluster",
          title: "Connect",
          arguments: [clusterId]
        };
        connectItem.iconPath = new vscode.ThemeIcon("plug");
        items.push(connectItem);
        const removeItem2 = new ExplorerItem("Remove Cluster", "remove", vscode.TreeItemCollapsibleState.None);
        removeItem2.command = {
          command: "esExt.removeCluster",
          title: "Remove",
          arguments: [clusterId]
        };
        removeItem2.iconPath = new vscode.ThemeIcon("trash");
        items.push(removeItem2);
        return items;
      }
      const health = this.clusterHealth.get(clusterId);
      if (health) {
        const healthStatusText = `Health Status: ${health.status.toUpperCase()}`;
        const healthDetailsText = `${health.numberOfNodes} nodes, ${health.activeShards} shards`;
        const healthItem = new ExplorerItem(healthStatusText, `healthStatus:${clusterId}`, vscode.TreeItemCollapsibleState.None);
        const healthDetailsItem = new ExplorerItem(healthDetailsText, `healthDetails:${clusterId}`, vscode.TreeItemCollapsibleState.None);
        let healthIconName = "pulse";
        let healthColor;
        switch (health.status) {
          case "green":
            healthIconName = "pass";
            healthColor = new vscode.ThemeColor("testing.iconPassed");
            break;
          case "yellow":
            healthIconName = "warning";
            healthColor = new vscode.ThemeColor("editorWarning.foreground");
            break;
          case "red":
            healthIconName = "error";
            healthColor = new vscode.ThemeColor("editorError.foreground");
            break;
          case "unknown":
            healthIconName = "question";
            healthColor = new vscode.ThemeColor("disabledForeground");
            break;
        }
        healthItem.iconPath = new vscode.ThemeIcon(healthIconName, healthColor);
        healthDetailsItem.iconPath = new vscode.ThemeIcon("info");
        healthItem.tooltip = `Cluster: ${health.clusterName}
Status: ${health.status}
Nodes: ${health.numberOfNodes}
Data Nodes: ${health.numberOfDataNodes}
Active Primary Shards: ${health.activePrimaryShards}
Active Shards: ${health.activeShards}
Last Checked: ${health.lastChecked.toLocaleString()}`;
        healthDetailsItem.tooltip = healthItem.tooltip;
        items.push(healthItem);
        items.push(healthDetailsItem);
      }
      items.push(
        new ExplorerItem("Cluster Info", `clusterInfo:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("info")),
        new ExplorerItem("Nodes", `nodes:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("server-environment")),
        new ExplorerItem("Important Links", `links:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("link-external")),
        new ExplorerItem("Data Streams", `dataStreams:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("database")),
        new ExplorerItem("Roles", `roles:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("person")),
        new ExplorerItem("Role Mappings", `roleMappings:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("organization")),
        new ExplorerItem("Index Templates", `indexTemplates:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("file-code"))
      );
      const divider = new ExplorerItem("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500", "divider", vscode.TreeItemCollapsibleState.None);
      divider.iconPath = new vscode.ThemeIcon("blank");
      items.push(divider);
      if (clusterId !== this.activeClusterId) {
        const selectItem = new ExplorerItem("Set as Active", "select", vscode.TreeItemCollapsibleState.None);
        selectItem.command = {
          command: "esExt.selectCluster",
          title: "Select",
          arguments: [clusterId]
        };
        selectItem.iconPath = new vscode.ThemeIcon("star");
        items.push(selectItem);
      }
      const disconnectItem = new ExplorerItem("Disconnect", "disconnect", vscode.TreeItemCollapsibleState.None);
      disconnectItem.command = {
        command: "esExt.disconnectFromCluster",
        title: "Disconnect",
        arguments: [clusterId]
      };
      disconnectItem.iconPath = new vscode.ThemeIcon("debug-disconnect");
      items.push(disconnectItem);
      const removeItem = new ExplorerItem("Remove Cluster", "remove", vscode.TreeItemCollapsibleState.None);
      removeItem.command = {
        command: "esExt.removeCluster",
        title: "Remove",
        arguments: [clusterId]
      };
      removeItem.iconPath = new vscode.ThemeIcon("trash");
      items.push(removeItem);
      return items;
    }
    if (element.contextValue?.includes(":")) {
      const [category, ...rest] = element.contextValue.split(":");
      const clusterId = rest[rest.length - 1];
      const client2 = this.clients.get(clusterId);
      if (!client2) {
        return [new ExplorerItem("Not connected", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
      }
      switch (category) {
        case "clusterInfo":
          return this.fetchClusterInfo(client2, clusterId);
        case "nodes":
          return this.fetchClusterNodes(client2);
        case "links":
          return this.fetchImportantLinks(clusterId);
        case "elasticsearch":
          return this.fetchElasticsearchLinks(clusterId);
        case "kibana":
          return this.fetchKibanaLinks(clusterId);
        case "haproxy":
          return this.fetchHAProxyLinks(clusterId);
        case "dataStreams":
          return this.fetchDataStreams(client2, clusterId);
        case "dataStream": {
          const dataStreamName = rest.slice(0, -1).join(":");
          return this.fetchDataStreamIndices(client2, dataStreamName, clusterId);
        }
        case "roles":
          return this.fetchRoles(client2);
        case "roleMappings":
          return this.fetchRoleMappings(client2);
        case "indexTemplates":
          return this.fetchIndexTemplates(client2);
        default:
          return [];
      }
    }
    const client = this.getActiveClient();
    if (!client) return [];
    switch (element.contextValue) {
      case "dataStreams":
        return this.fetchDataStreams(client);
      case "roles":
        return this.fetchRoles(client);
      case "roleMappings":
        return this.fetchRoleMappings(client);
      case "indexTemplates":
        return this.fetchIndexTemplates(client);
      case "cluster":
        return this.fetchClusterInfo(client);
      default:
        return [];
    }
  }
  async loadClusters() {
    const clusterIds = await this.context.globalState.get("esExt.clusterIds", []);
    for (const id of clusterIds) {
      const configJson = await this.context.secrets.get(`esExt.cluster.${id}.config`);
      if (configJson) {
        try {
          const config = JSON.parse(configJson);
          this.clusters.set(id, config);
        } catch (err) {
          console.error(`[ESExt] Failed to parse cluster config for ${id}:`, err);
        }
      }
    }
    if (this.clusters.size > 0 && !this.activeClusterId) {
      this.activeClusterId = Array.from(this.clusters.keys())[0];
    }
  }
  async saveClusterConfig(config) {
    await this.context.secrets.store(`esExt.cluster.${config.id}.config`, JSON.stringify(config));
    const clusterIds = await this.context.globalState.get("esExt.clusterIds", []);
    if (!clusterIds.includes(config.id)) {
      clusterIds.push(config.id);
      await this.context.globalState.update("esExt.clusterIds", clusterIds);
    }
  }
  async storeClusterCredentials(clusterId, authMethod, credentials) {
    if (authMethod === "Basic: Username/Password") {
      await this.context.secrets.store(`esExt.cluster.${clusterId}.username`, credentials.username);
      await this.context.secrets.store(`esExt.cluster.${clusterId}.password`, credentials.password);
    } else if (authMethod === "API Key") {
      await this.context.secrets.store(`esExt.cluster.${clusterId}.apiKey`, credentials.apiKey);
    }
  }
  // Connection state management for auto-reconnect
  async saveConnectedCluster(clusterId) {
    const connectedClusters = await this.context.globalState.get("esExt.connectedClusters", []);
    if (!connectedClusters.includes(clusterId)) {
      connectedClusters.push(clusterId);
      await this.context.globalState.update("esExt.connectedClusters", connectedClusters);
    }
  }
  async removeConnectedCluster(clusterId) {
    const connectedClusters = await this.context.globalState.get("esExt.connectedClusters", []);
    const updatedClusters = connectedClusters.filter((id) => id !== clusterId);
    await this.context.globalState.update("esExt.connectedClusters", updatedClusters);
  }
  async autoReconnectClusters() {
    const connectedClusters = await this.context.globalState.get("esExt.connectedClusters", []);
    if (connectedClusters.length === 0) {
      return;
    }
    await vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: "Auto-reconnecting clusters...",
      cancellable: false
    }, async (progress) => {
      let reconnectedCount = 0;
      let failedCount = 0;
      for (let i = 0; i < connectedClusters.length; i++) {
        const clusterId = connectedClusters[i];
        const config = this.clusters.get(clusterId);
        if (!config) {
          await this.removeConnectedCluster(clusterId);
          failedCount++;
          continue;
        }
        progress.report({
          increment: i / connectedClusters.length * 100,
          message: `Reconnecting to ${config.name}...`
        });
        try {
          const success = await this.connectToClusterSilently(clusterId);
          if (success) {
            reconnectedCount++;
          } else {
            failedCount++;
            await this.removeConnectedCluster(clusterId);
          }
        } catch (error) {
          console.error(`[ESExt] Auto-reconnect failed for ${config.name}:`, error);
          failedCount++;
          await this.removeConnectedCluster(clusterId);
        }
      }
      if (reconnectedCount > 0 || failedCount > 0) {
        let message = "";
        if (reconnectedCount > 0) {
          message += `Auto-reconnected ${reconnectedCount} cluster(s).`;
        }
        if (failedCount > 0) {
          if (message) message += " ";
          message += `${failedCount} cluster(s) failed to reconnect.`;
        }
        if (failedCount > 0) {
          vscode.window.showWarningMessage(message);
        } else {
          vscode.window.showInformationMessage(message);
        }
      }
    });
  }
  async connectToClusterSilently(clusterId) {
    const config = this.clusters.get(clusterId);
    if (!config) {
      return false;
    }
    try {
      const clientOptions = {};
      if (config.deploymentType === "Elastic Cloud") {
        clientOptions.cloud = { id: config.cloudId };
      } else {
        clientOptions.node = config.nodeUrl;
      }
      if (config.authMethod === "Basic: Username/Password") {
        const username = await this.context.secrets.get(`esExt.cluster.${clusterId}.username`);
        const password = await this.context.secrets.get(`esExt.cluster.${clusterId}.password`);
        if (username && password) {
          clientOptions.auth = { username, password };
        }
      } else if (config.authMethod === "API Key") {
        const apiKey = await this.context.secrets.get(`esExt.cluster.${clusterId}.apiKey`);
        if (apiKey) {
          clientOptions.auth = { apiKey };
        }
      }
      if (config.disableSSL) {
        clientOptions.ssl = { rejectUnauthorized: false };
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
      }
      const caCert = await this.context.globalState.get("esExt.caCertificate");
      if (caCert) {
        clientOptions.tls = clientOptions.tls || {};
        clientOptions.tls.ca = Buffer.from(caCert, "utf8");
      }
      const client = new import_elasticsearch.Client(clientOptions);
      await client.ping();
      this.clients.set(clusterId, client);
      if (!this.activeClusterId) {
        this.activeClusterId = clusterId;
      }
      try {
        const healthResponse = await client.cluster.health();
        const health = healthResponse.body || healthResponse;
        this.clusterHealth.set(clusterId, {
          status: health.status || "unknown",
          clusterName: health.cluster_name || "Unknown",
          numberOfNodes: health.number_of_nodes || 0,
          numberOfDataNodes: health.number_of_data_nodes || 0,
          activePrimaryShards: health.active_primary_shards || 0,
          activeShards: health.active_shards || 0,
          lastChecked: /* @__PURE__ */ new Date()
        });
      } catch (healthError) {
        this.clusterHealth.set(clusterId, {
          status: "unknown",
          clusterName: "Unknown",
          numberOfNodes: 0,
          numberOfDataNodes: 0,
          activePrimaryShards: 0,
          activeShards: 0,
          lastChecked: /* @__PURE__ */ new Date()
        });
      }
      return true;
    } catch (err) {
      console.error(`[ESExt] Silent reconnect failed for cluster ${clusterId}:`, err);
      return false;
    }
  }
  async disconnectFromCluster(clusterId) {
    this.clients.delete(clusterId);
    await this.removeConnectedCluster(clusterId);
    this.clusterHealth.delete(clusterId);
    if (this.activeClusterId === clusterId) {
      this.activeClusterId = void 0;
    }
    this.refresh();
    const cluster = this.clusters.get(clusterId);
    const clusterName = cluster ? cluster.name : "Unknown";
    vscode.window.showInformationMessage(`Disconnected from ${clusterName}`);
  }
  async fetchClusterInfo(client, clusterId) {
    try {
      const [info, healthResponse, nodesResponse] = await Promise.all([
        client.info(),
        client.cluster.health(),
        client.nodes.info()
      ]);
      const config = clusterId ? this.clusters.get(clusterId) : this.getActiveCluster();
      const health = healthResponse;
      const nodes = nodesResponse;
      const totalNodes = health.number_of_nodes || 0;
      const dataNodes = health.number_of_data_nodes || 0;
      const currentShards = health.active_shards || 0;
      const shardLimit = dataNodes * 1e3;
      const shardPercentage = shardLimit > 0 ? currentShards / shardLimit * 100 : 0;
      let shardStatusIcon;
      if (shardPercentage <= 80) {
        shardStatusIcon = new vscode.ThemeIcon("check", new vscode.ThemeColor("charts.green"));
      } else if (shardPercentage <= 90) {
        shardStatusIcon = new vscode.ThemeIcon("warning", new vscode.ThemeColor("charts.yellow"));
      } else {
        shardStatusIcon = new vscode.ThemeIcon("error", new vscode.ThemeColor("charts.red"));
      }
      const items = [
        new ExplorerItem(`Name: ${info.name}`, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("tag")),
        new ExplorerItem(`Version: ${info.version.number}`, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("versions")),
        new ExplorerItem(`Cluster UUID: ${info.cluster_uuid}`, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("key"))
      ];
      if (config) {
        items.push(
          new ExplorerItem(`Type: ${config.deploymentType}`, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("server")),
          new ExplorerItem(`Endpoint: ${config.nodeUrl || config.cloudId}`, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("link")),
          new ExplorerItem(`Auth: ${config.authMethod}`, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("shield"))
        );
      }
      return items;
    } catch (err) {
      vscode.window.showErrorMessage(`Failed to fetch cluster info: ${err}`);
      return [new ExplorerItem("Failed to load cluster info", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
  }
  async fetchClusterNodes(client) {
    try {
      const statsResponse = await client.nodes.stats({
        filter_path: [
          "nodes.*.name",
          "nodes.*.ip",
          "nodes.*.roles",
          "nodes.*.os.cpu.percent",
          "nodes.*.jvm.mem.heap_used_percent",
          "nodes.*.fs.total.total_in_bytes",
          "nodes.*.fs.total.free_in_bytes"
        ]
      });
      const nodes = statsResponse.nodes || statsResponse.body?.nodes || {};
      const nodeItems = [];
      for (const [nodeId, nodeInfoRaw] of Object.entries(nodes)) {
        const nodeInfo = nodeInfoRaw;
        const name = nodeInfo.name || nodeId;
        const ip = nodeInfo.ip || "N/A";
        const roles = Array.isArray(nodeInfo.roles) ? nodeInfo.roles.join(", ") : "N/A";
        const cpu = typeof nodeInfo.os?.cpu?.percent === "number" ? `${nodeInfo.os.cpu.percent}%` : "N/A";
        const jvm = typeof nodeInfo.jvm?.mem?.heap_used_percent === "number" ? `${nodeInfo.jvm.mem.heap_used_percent}%` : "N/A";
        const totalBytes = nodeInfo.fs?.total?.total_in_bytes;
        const freeBytes = nodeInfo.fs?.total?.free_in_bytes;
        const totalDisk = totalBytes !== void 0 ? this.formatBytes(totalBytes) : "N/A";
        const freeDisk = freeBytes !== void 0 ? this.formatBytes(freeBytes) : "N/A";
        const label = `${name} (${ip})`;
        const tooltip = `Node ID: ${nodeId}
Roles: ${roles}
CPU: ${cpu}
JVM Heap Used: ${jvm}
Disk: ${freeDisk} free / ${totalDisk} total`;
        let icon = new vscode.ThemeIcon("server");
        if (Array.isArray(nodeInfo.roles)) {
          if (nodeInfo.roles.includes("master")) icon = new vscode.ThemeIcon("star");
          else if (nodeInfo.roles.includes("data")) icon = new vscode.ThemeIcon("database");
          else if (nodeInfo.roles.includes("ingest")) icon = new vscode.ThemeIcon("cloud-upload");
        }
        const item = new ExplorerItem(label, void 0, vscode.TreeItemCollapsibleState.None, icon);
        item.tooltip = tooltip;
        nodeItems.push(item);
      }
      if (nodeItems.length === 0) {
        return [new ExplorerItem("No nodes found", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
      }
      return nodeItems;
    } catch (err) {
      vscode.window.showErrorMessage(`Failed to fetch nodes: ${err}`);
      return [new ExplorerItem("Failed to load nodes", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
  }
  // Utility to format bytes as human-readable string
  formatBytes(bytes) {
    if (bytes === 0) return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB", "TB", "PB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  async fetchDataStreams(client, clusterId) {
    try {
      const dsResp = await client.indices.getDataStream();
      const dataStreams = dsResp.data_streams || [];
      const statsResp = await client.transport.request({
        method: "GET",
        path: "/_data_stream/_stats",
        querystring: {
          filter_path: "_all.total.docs.count,_all.total.docs.total_size_in_bytes,_all.total.shard_stats.total_count,data_streams.indices,status,health"
        }
      });
      const statsAny = statsResp;
      const stats = statsAny.data_streams || statsAny.body?.data_streams || [];
      const statsByName = {};
      for (const s of stats) {
        if (s.data_stream) statsByName[s.data_stream] = s;
      }
      return dataStreams.sort((a, b) => a.name.localeCompare(b.name)).map((ds) => {
        const dsStats = statsByName[ds.name] || {};
        const key = `${ds.name}:${clusterId}`;
        let docCount = 0;
        let sizeBytes = 0;
        if (this.dataStreamStatsSums.has(key)) {
          const sum = this.dataStreamStatsSums.get(key);
          docCount = sum.docCount;
          sizeBytes = sum.sizeBytes;
        } else {
          if (Array.isArray(dsStats.backing_indices)) {
            for (const idx of dsStats.backing_indices) {
              let docs = idx?.stats?.primaries?.docs?.count;
              let bytes = idx?.stats?.primaries?.store?.size_in_bytes;
              if (docs === void 0) docs = idx?.doc_count;
              if (bytes === void 0) bytes = idx?.store_size_bytes;
              if (docs === void 0) docs = 0;
              if (bytes === void 0) bytes = 0;
              docCount += docs;
              sizeBytes += bytes;
            }
          }
        }
        const label = `${ds.name} (${docCount} docs, ${this.formatBytes(sizeBytes)})`;
        const item = new ExplorerItem(label, `dataStream:${ds.name}:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("database"));
        item.command = {
          command: "esExt.showDataStreamStats",
          title: "Show Data Stream Stats",
          arguments: [ds.name, clusterId]
        };
        return item;
      });
    } catch (err) {
      vscode.window.showErrorMessage(`Failed to fetch Data Streams: ${err}`);
      return [new ExplorerItem("Failed to load data streams", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
  }
  async fetchDataStreamIndices(client, dataStreamName, clusterId) {
    try {
      const dsResp = await client.indices.getDataStream({ name: dataStreamName });
      const ds = dsResp.data_streams?.[0];
      if (!ds) return [new ExplorerItem("No indices found", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
      const statsResp = await client.transport.request({
        method: "GET",
        path: `/_data_stream/${encodeURIComponent(dataStreamName)}/_stats`,
        querystring: {
          filter_path: "data_streams.indices,status,health"
        }
      });
      const statsAny = statsResp;
      const dsStats = (statsAny.data_streams || statsAny.body?.data_streams || [])[0] || {};
      const indices = dsStats.indices || ds.indices || [];
      const items = [];
      let totalDocs = 0;
      let totalBytes = 0;
      for (const idx of indices) {
        const idxName = idx.index_name || idx.name || idx;
        let docCount = idx?.stats?.primaries?.docs?.count;
        let sizeBytes = idx?.stats?.primaries?.store?.size_in_bytes;
        if (docCount === void 0) docCount = idx?.doc_count;
        if (sizeBytes === void 0) sizeBytes = idx?.store_size_bytes;
        if (!docCount && !sizeBytes) {
          try {
            const statsResp2 = await client.indices.stats({ index: idxName });
            const stats = statsResp2.body || statsResp2;
            const primaries = stats.indices?.[idxName]?.primaries;
            docCount = primaries?.docs?.count ?? 0;
            sizeBytes = primaries?.store?.size_in_bytes ?? 0;
          } catch {
            docCount = 0;
            sizeBytes = 0;
          }
        }
        totalDocs += typeof docCount === "number" ? docCount : 0;
        totalBytes += typeof sizeBytes === "number" ? sizeBytes : 0;
        let icon = new vscode.ThemeIcon("database");
        const health = idx?.health || "unknown";
        if (health === "green") icon = new vscode.ThemeIcon("check", new vscode.ThemeColor("charts.green"));
        else if (health === "yellow") icon = new vscode.ThemeIcon("warning", new vscode.ThemeColor("charts.yellow"));
        else if (health === "red") icon = new vscode.ThemeIcon("error", new vscode.ThemeColor("charts.red"));
        const label = `${idxName} (${docCount} docs, ${typeof sizeBytes === "number" ? this.formatBytes(sizeBytes) : sizeBytes})`;
        const item = new ExplorerItem(label, `dataStreamIndex:${dataStreamName}:${idxName}:${clusterId}`, vscode.TreeItemCollapsibleState.None, icon);
        item.command = {
          command: "esExt.showDataStreamIndexStats",
          title: "Show Data Stream Index Stats",
          arguments: [dataStreamName, idxName, clusterId]
        };
        items.push(item);
      }
      const key = `${dataStreamName}:${clusterId}`;
      this.dataStreamStatsSums.set(key, { docCount: totalDocs, sizeBytes: totalBytes });
      const parentItem = new ExplorerItem(
        `${dataStreamName} (${totalDocs} docs, ${this.formatBytes(totalBytes)})`,
        `dataStream:${dataStreamName}:${clusterId}`,
        vscode.TreeItemCollapsibleState.Collapsed,
        new vscode.ThemeIcon("database")
      );
      this._onDidChangeTreeData.fire(parentItem);
      return items;
    } catch (err) {
      vscode.window.showErrorMessage(`Failed to fetch indices for data stream ${dataStreamName}: ${err}`);
      return [new ExplorerItem("Failed to load indices", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
  }
  fetchImportantLinks(clusterId) {
    const config = this.clusters.get(clusterId);
    if (!config) {
      return [new ExplorerItem("Cluster not found", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
    const isProd = config.name.toUpperCase().includes("PROD");
    const domain = isProd ? "wtg.zone" : "sand.wtg.zone";
    const clusterName = config.name.toLowerCase();
    let elasticUrl = "";
    if (config.nodeUrl) {
      try {
        const url = new URL(config.nodeUrl);
        elasticUrl = `${url.protocol}//${url.host}`;
      } catch {
        elasticUrl = config.nodeUrl;
      }
    }
    const items = [];
    const elasticsearchSection = new ExplorerItem("Elasticsearch", `elasticsearch:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("database"));
    items.push(elasticsearchSection);
    const kibanaSection = new ExplorerItem("Kibana", `kibana:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("graph"));
    items.push(kibanaSection);
    const haproxySection = new ExplorerItem("HAProxy", `haproxy:${clusterId}`, vscode.TreeItemCollapsibleState.Collapsed, new vscode.ThemeIcon("server-process"));
    items.push(haproxySection);
    return items;
  }
  fetchElasticsearchLinks(clusterId) {
    const config = this.clusters.get(clusterId);
    if (!config) {
      return [new ExplorerItem("Cluster not found", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
    let elasticUrl = "";
    if (config.nodeUrl) {
      try {
        const url = new URL(config.nodeUrl);
        elasticUrl = `${url.protocol}//${url.host}`;
      } catch {
        elasticUrl = config.nodeUrl;
      }
    }
    const items = [];
    const healthLink = new ExplorerItem("GET _cluster/health", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("heart"));
    healthLink.command = {
      command: "vscode.open",
      title: "Open Cluster Health",
      arguments: [vscode.Uri.parse(`${elasticUrl}/_cluster/health`)]
    };
    healthLink.tooltip = `${elasticUrl}/_cluster/health`;
    items.push(healthLink);
    const settingsLink = new ExplorerItem("GET _cluster/settings", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("settings-gear"));
    settingsLink.command = {
      command: "vscode.open",
      title: "Open Cluster Settings",
      arguments: [vscode.Uri.parse(`${elasticUrl}/_cluster/settings`)]
    };
    settingsLink.tooltip = `${elasticUrl}/_cluster/settings`;
    items.push(settingsLink);
    return items;
  }
  fetchKibanaLinks(clusterId) {
    const config = this.clusters.get(clusterId);
    if (!config) {
      return [new ExplorerItem("Cluster not found", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
    const isProd = config.name.toUpperCase().includes("PROD");
    const domain = isProd ? "wtg.zone" : "sand.wtg.zone";
    const clusterName = config.name.toLowerCase();
    const items = [];
    const statusLink = new ExplorerItem("GET /api/status", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("pulse"));
    statusLink.command = {
      command: "vscode.open",
      title: "Open Kibana Status",
      arguments: [vscode.Uri.parse(`https://kibana.${clusterName}.${domain}/api/status`)]
    };
    statusLink.tooltip = `kibana.${clusterName}.${domain}/api/status`;
    items.push(statusLink);
    const devConsoleLink = new ExplorerItem("Dev Console", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("terminal"));
    devConsoleLink.command = {
      command: "vscode.open",
      title: "Open Dev Console",
      arguments: [vscode.Uri.parse(`https://kibana.${clusterName}.${domain}/app/dev_tools#/console`)]
    };
    devConsoleLink.tooltip = `kibana.${clusterName}.${domain}/app/dev_tools#/console`;
    items.push(devConsoleLink);
    const monitoringLink = new ExplorerItem("Stack Monitoring", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("graph-line"));
    monitoringLink.command = {
      command: "vscode.open",
      title: "Open Stack Monitoring",
      arguments: [vscode.Uri.parse(`https://kibana.${clusterName}.${domain}/app/monitoring#/overview`)]
    };
    monitoringLink.tooltip = `kibana.${clusterName}.${domain}/app/monitoring#/overview`;
    items.push(monitoringLink);
    return items;
  }
  fetchHAProxyLinks(clusterId) {
    const config = this.clusters.get(clusterId);
    if (!config) {
      return [new ExplorerItem("Cluster not found", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
    const isProd = config.name.toUpperCase().includes("PROD");
    const domain = isProd ? "wtg.zone" : "sand.wtg.zone";
    const clusterName = config.name.toLowerCase();
    const items = [];
    const statsLink = new ExplorerItem("Stats Page", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("graph"));
    statsLink.command = {
      command: "vscode.open",
      title: "Open HAProxy Stats",
      arguments: [vscode.Uri.parse(`https://haproxy.${clusterName}.${domain}`)]
    };
    statsLink.tooltip = `haproxy.${clusterName}.${domain}`;
    items.push(statsLink);
    return items;
  }
  async fetchRoles(client) {
    try {
      const roles = await client.security.getRole();
      return Object.keys(roles).sort((a, b) => a.localeCompare(b)).map((name) => {
        const item = new ExplorerItem(name, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("person"));
        item.command = {
          command: "esExt.showRole",
          title: "View Role",
          arguments: [name]
        };
        return item;
      });
    } catch (err) {
      vscode.window.showErrorMessage(`Failed to fetch Roles: ${err}`);
      return [new ExplorerItem("Failed to load roles", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
  }
  async fetchRoleMappings(client) {
    try {
      const roleMappings = await client.security.getRoleMapping();
      return Object.keys(roleMappings).sort((a, b) => a.localeCompare(b)).map((name) => {
        const item = new ExplorerItem(name, void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("organization"));
        item.command = {
          command: "esExt.showRoleMapping",
          title: "View Role Mapping",
          arguments: [name]
        };
        return item;
      });
    } catch (err) {
      vscode.window.showErrorMessage(`Failed to fetch Role Mappings: ${err}`);
      return [new ExplorerItem("Failed to load role mappings", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
  }
  async fetchIndexTemplates(client) {
    try {
      const response = await client.indices.getIndexTemplate();
      const body = response.body || response;
      if (body && Array.isArray(body.index_templates)) {
        return body.index_templates.map((templateInfo) => {
          const treeItem = new ExplorerItem(templateInfo.name, `indexTemplateItem:${templateInfo.name}`, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("file-code"));
          treeItem.command = {
            command: "esExt.showIndexTemplate",
            title: "View Index Template",
            arguments: [templateInfo.name]
          };
          return treeItem;
        }).sort((a, b) => a.label.localeCompare(b.label));
      } else {
        console.warn("[ESExt] No index templates found or unexpected response format from client.indices.getIndexTemplate()");
        vscode.window.showInformationMessage("No index templates found.");
        return [];
      }
    } catch (err) {
      console.error("[ESExt] Error fetching index templates:", err);
      vscode.window.showErrorMessage(`Failed to fetch Index Templates: ${err.message}`);
      return [new ExplorerItem("Failed to load index templates", void 0, vscode.TreeItemCollapsibleState.None, new vscode.ThemeIcon("error"))];
    }
  }
  async exportClusters() {
    if (this.clusters.size === 0) {
      vscode.window.showInformationMessage("No clusters to export.");
      return;
    }
    try {
      const exportData = {
        version: "1.0.0",
        exportDate: (/* @__PURE__ */ new Date()).toISOString(),
        clusters: Array.from(this.clusters.values()).map((cluster) => ({
          name: cluster.name,
          deploymentType: cluster.deploymentType,
          nodeUrl: cluster.nodeUrl,
          cloudId: cluster.cloudId,
          authMethod: cluster.authMethod,
          disableSSL: cluster.disableSSL
        }))
      };
      const saveUri = await vscode.window.showSaveDialog({
        defaultUri: vscode.Uri.file(`elasticsearch-clusters-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`),
        filters: {
          "JSON Files": ["json"],
          "All Files": ["*"]
        },
        saveLabel: "Export Clusters"
      });
      if (saveUri) {
        await vscode.workspace.fs.writeFile(saveUri, Buffer.from(JSON.stringify(exportData, null, 2)));
        vscode.window.showInformationMessage(`Successfully exported ${exportData.clusters.length} cluster configuration(s) to ${saveUri.fsPath}`);
      }
    } catch (error) {
      console.error("[ESExt] Failed to export clusters:", error);
      vscode.window.showErrorMessage(`Failed to export clusters: ${error}`);
    }
  }
  async importClusters() {
    try {
      const openUri = await vscode.window.showOpenDialog({
        canSelectFiles: true,
        canSelectFolders: false,
        canSelectMany: false,
        filters: {
          "JSON Files": ["json"],
          "All Files": ["*"]
        },
        openLabel: "Import Clusters"
      });
      if (!openUri || openUri.length === 0) {
        return;
      }
      const fileContent = await vscode.workspace.fs.readFile(openUri[0]);
      const importData = JSON.parse(fileContent.toString());
      if (!importData.clusters || !Array.isArray(importData.clusters)) {
        vscode.window.showErrorMessage("Invalid cluster configuration file format.");
        return;
      }
      let importedCount = 0;
      let skippedCount = 0;
      for (const clusterData of importData.clusters) {
        if (!clusterData.name || !clusterData.deploymentType || !clusterData.authMethod) {
          console.warn("[ESExt] Skipping invalid cluster:", clusterData);
          skippedCount++;
          continue;
        }
        const existingCluster = Array.from(this.clusters.values()).find((c) => c.name === clusterData.name);
        if (existingCluster) {
          const overwrite = await vscode.window.showWarningMessage(
            `Cluster "${clusterData.name}" already exists. Do you want to overwrite it?`,
            "Yes",
            "No",
            "Cancel"
          );
          if (overwrite === "Cancel") {
            break;
          } else if (overwrite === "No") {
            skippedCount++;
            continue;
          } else {
            await this.removeCluster(existingCluster.id);
          }
        }
        const newClusterConfig = {
          id: this.generateClusterId(),
          name: clusterData.name,
          deploymentType: clusterData.deploymentType,
          nodeUrl: clusterData.nodeUrl,
          cloudId: clusterData.cloudId,
          authMethod: clusterData.authMethod,
          disableSSL: clusterData.disableSSL
        };
        await this.addCluster(newClusterConfig);
        importedCount++;
      }
      let message = `Successfully imported ${importedCount} cluster(s).`;
      if (skippedCount > 0) {
        message += ` ${skippedCount} cluster(s) were skipped.`;
      }
      if (importedCount > 0) {
        message += "\n\nNote: You will need to configure authentication credentials for the imported clusters.";
      }
      vscode.window.showInformationMessage(message);
    } catch (error) {
      console.error("[ESExt] Failed to import clusters:", error);
      vscode.window.showErrorMessage(`Failed to import clusters: ${error}`);
    }
  }
  generateClusterId() {
    return `cluster_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
};
var ExplorerItem = class extends vscode.TreeItem {
  constructor(label, contextValue, collapsibleState = vscode.TreeItemCollapsibleState.Collapsed, iconPath) {
    super(label, collapsibleState);
    this.label = label;
    this.contextValue = contextValue;
    this.collapsibleState = collapsibleState;
    if (contextValue) {
      this.contextValue = contextValue;
    }
    if (iconPath) {
      this.iconPath = iconPath;
    }
  }
};

// src/extension.ts
function activate(context2) {
  const explorerProvider = new ESExplorerProvider(context2);
  vscode2.window.registerTreeDataProvider("esExtExplorer", explorerProvider);
  explorerProvider.loadClustersOnStartup();
  context2.subscriptions.push(
    vscode2.commands.registerCommand("esExt.addCluster", async () => {
      const clusterId = `cluster-${Date.now()}`;
      const name = await vscode2.window.showInputBox({
        prompt: "Cluster Name",
        placeHolder: "e.g. Production Cluster"
      });
      if (!name) return;
      const deploymentType = await vscode2.window.showQuickPick(
        ["Self-managed Cluster", "Elastic Cloud"],
        { placeHolder: "Select Elasticsearch deployment type" }
      );
      if (!deploymentType) return;
      let clientOptions = {};
      let nodeUrl;
      let cloudId;
      if (deploymentType === "Elastic Cloud") {
        cloudId = await vscode2.window.showInputBox({
          prompt: "Elastic Cloud ID",
          placeHolder: "e.g. myDeployment:abcdef.."
        });
        if (!cloudId) return;
        clientOptions.cloud = { id: cloudId };
      } else {
        nodeUrl = await vscode2.window.showInputBox({
          prompt: "Full Elasticsearch URL (include protocol and port)",
          placeHolder: "e.g. http://elasticsearch.apac-test-1.sand.wtg.zone:9200 or https://host:9243"
        });
        if (!nodeUrl) return;
        clientOptions.node = nodeUrl;
      }
      const authMethod = await vscode2.window.showQuickPick(
        ["None", "Basic: Username/Password", "API Key"],
        { placeHolder: "Select auth method" }
      );
      if (!authMethod) return;
      let credentials = {};
      if (authMethod === "Basic: Username/Password") {
        const username = await vscode2.window.showInputBox({ prompt: "Username" });
        const password = username ? await vscode2.window.showInputBox({ prompt: "Password", password: true }) : void 0;
        if (username && password) {
          clientOptions.auth = { username, password };
          credentials = { username, password };
        }
      } else if (authMethod === "API Key") {
        const apiKey = await vscode2.window.showInputBox({ prompt: "API Key" });
        if (apiKey) {
          clientOptions.auth = { apiKey };
          credentials = { apiKey };
        }
      }
      const disableSSL = await vscode2.window.showQuickPick(
        ["Yes", "No"],
        { placeHolder: "Disable SSL certificate verification? (insecure)" }
      );
      if (disableSSL === "Yes") {
        clientOptions.ssl = { rejectUnauthorized: false };
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
      }
      try {
        const tempClient = new import_elasticsearch2.Client(clientOptions);
        await tempClient.ping();
        const config = {
          id: clusterId,
          name,
          deploymentType,
          nodeUrl,
          cloudId,
          authMethod,
          disableSSL: disableSSL === "Yes"
        };
        await explorerProvider.addCluster(config);
        await explorerProvider.storeClusterCredentials(clusterId, authMethod, credentials);
        await explorerProvider.connectToCluster(clusterId);
        vscode2.window.showInformationMessage(`Successfully added and connected to cluster: ${name}`);
        explorerProvider.refresh();
      } catch (err) {
        vscode2.window.showErrorMessage(`Failed to connect to cluster: ${err.message}`);
      }
    }),
    vscode2.commands.registerCommand("esExt.selectCluster", async (clusterId) => {
      explorerProvider.setActiveCluster(clusterId);
      const success = await explorerProvider.connectToCluster(clusterId);
      if (success) {
        const cluster = explorerProvider.getActiveCluster();
        vscode2.window.showInformationMessage(`Connected to ${cluster?.name}`);
      } else {
        vscode2.window.showErrorMessage("Failed to connect to cluster");
      }
    }),
    vscode2.commands.registerCommand("esExt.connectToCluster", async (clusterId) => {
      const success = await explorerProvider.connectToCluster(clusterId);
      if (success) {
        const cluster = explorerProvider.getActiveCluster();
        vscode2.window.showInformationMessage(`Connected to ${cluster?.name}`);
        explorerProvider.refresh();
      } else {
        vscode2.window.showErrorMessage("Failed to connect to cluster");
      }
    }),
    vscode2.commands.registerCommand("esExt.removeCluster", async (clusterId) => {
      const cluster = explorerProvider.getCluster(clusterId);
      if (!cluster) return;
      const confirm = await vscode2.window.showWarningMessage(
        `Remove cluster "${cluster.name}"?`,
        { modal: true },
        "Remove"
      );
      if (confirm === "Remove") {
        await explorerProvider.removeCluster(clusterId);
        vscode2.window.showInformationMessage(`Removed cluster: ${cluster.name}`);
      }
    }),
    vscode2.commands.registerCommand("esExt.search", async () => {
      const client = explorerProvider.getActiveClient();
      if (!client) {
        vscode2.window.showErrorMessage("Please connect to an Elasticsearch cluster first.");
        return;
      }
      const index = await vscode2.window.showInputBox({ prompt: "Index to search", placeHolder: "_all" });
      const query = await vscode2.window.showInputBox({ prompt: "Query as JSON", value: '{"query":{"match_all":{}}}' });
      if (!query) return;
      try {
        const searchResult = await client.search({
          index: index && index.length > 0 ? index : void 0,
          body: JSON.parse(query)
        });
        const doc = await vscode2.workspace.openTextDocument({ content: JSON.stringify(searchResult, null, 2), language: "json" });
        await vscode2.window.showTextDocument(doc, { preview: false });
      } catch (err) {
        vscode2.window.showErrorMessage(`Search error: ${err.message}`);
      }
    }),
    vscode2.commands.registerCommand("esExt.openKibana", () => {
      const kibanaUrl = context2.globalState.get("esExt.kibanaUrl");
      if (kibanaUrl) {
        vscode2.env.openExternal(vscode2.Uri.parse(kibanaUrl));
      } else {
        vscode2.window.showErrorMessage("Kibana URL not set. Add it when creating a cluster.");
      }
    }),
    vscode2.commands.registerCommand("esExt.clusterHealth", async () => {
      const client = explorerProvider.getActiveClient();
      if (!client) {
        vscode2.window.showErrorMessage("Please connect to an Elasticsearch cluster first.");
        return;
      }
      try {
        const healthResult = await client.cluster.health();
        const doc = await vscode2.workspace.openTextDocument({
          content: JSON.stringify(healthResult, null, 2),
          language: "json"
        });
        await vscode2.window.showTextDocument(doc, { preview: false });
      } catch (err) {
        vscode2.window.showErrorMessage(`Cluster health error: ${err.message}`);
      }
    }),
    vscode2.commands.registerCommand("esExt.toggleAutoRefresh", () => {
      explorerProvider.toggleAutoRefresh();
    }),
    vscode2.commands.registerCommand("esExt.refresh", () => explorerProvider.refresh()),
    vscode2.commands.registerCommand("esExt.exportClusters", async () => {
      try {
        await explorerProvider.exportClusters();
      } catch (err) {
        vscode2.window.showErrorMessage(`Export failed: ${err.message}`);
      }
    }),
    vscode2.commands.registerCommand("esExt.importClusters", async () => {
      try {
        await explorerProvider.importClusters();
      } catch (err) {
        vscode2.window.showErrorMessage(`Import failed: ${err.message}`);
      }
    }),
    vscode2.commands.registerCommand("esExt.showIndexTemplate", async (templateName) => {
      if (!templateName) {
        const inputName = await vscode2.window.showInputBox({
          prompt: "Enter Index Template Name",
          placeHolder: "e.g. my_template"
        });
        if (!inputName) {
          vscode2.window.showInformationMessage("No index template name provided.");
          return;
        }
        templateName = inputName;
      }
      let client = explorerProvider.getActiveClient();
      if (!client) {
        console.warn("[esExt.showIndexTemplate] No active Elasticsearch client found.");
        vscode2.window.showErrorMessage("Please connect to an Elasticsearch cluster first.");
        return;
      }
      try {
        const response = await client.indices.getIndexTemplate({ name: templateName });
        const templates = response.body?.index_templates || response.index_templates;
        const templateInfo = templates?.find((t) => t.name === templateName);
        const templateDefinition = templateInfo?.index_template;
        if (templateDefinition) {
          const prettyJson = JSON.stringify(templateDefinition, null, 2);
          const doc = await vscode2.workspace.openTextDocument({
            content: prettyJson,
            language: "json"
          });
          await vscode2.window.showTextDocument(doc, { preview: false });
        } else {
          vscode2.window.showErrorMessage(`Index template "${templateName}" definition not found. It might not exist, the name is incorrect, or it's not a composable template.`);
        }
      } catch (err) {
        if (err.meta && err.meta.statusCode === 404) {
          vscode2.window.showErrorMessage(`Index template "${templateName}" not found (404).`);
        } else {
          vscode2.window.showErrorMessage(`Failed to fetch index template "${templateName}": ${err.message}`);
        }
      }
    }),
    vscode2.commands.registerCommand("esExt.disconnectFromCluster", async (clusterId) => {
      const cluster = explorerProvider.getCluster(clusterId);
      if (!cluster) return;
      await explorerProvider.disconnectFromCluster(clusterId);
    }),
    vscode2.commands.registerCommand("esExt.clearAllClusterData", async () => {
      const confirm = await vscode2.window.showWarningMessage(
        "This will remove ALL saved clusters and credentials from VS Code. Are you sure?",
        { modal: true },
        "Yes, clear all"
      );
      if (confirm !== "Yes, clear all") return;
      const clusterIds = await context2.globalState.get("esExt.clusterIds", []);
      await context2.globalState.update("esExt.clusterIds", []);
      await context2.globalState.update("esExt.connectedClusters", []);
      await context2.globalState.update("esExt.autoRefreshEnabled", false);
      for (const id of clusterIds) {
        await context2.secrets.delete(`esExt.cluster.${id}.config`);
        await context2.secrets.delete(`esExt.cluster.${id}.username`);
        await context2.secrets.delete(`esExt.cluster.${id}.password`);
        await context2.secrets.delete(`esExt.cluster.${id}.apiKey`);
      }
      vscode2.window.showInformationMessage("All cluster data and credentials have been cleared.");
      explorerProvider.refresh();
    }),
    vscode2.commands.registerCommand("esExt.setCACertificate", async () => {
      const fileUris = await vscode2.window.showOpenDialog({
        canSelectFiles: true,
        canSelectFolders: false,
        canSelectMany: false,
        filters: { "PEM Files": ["pem"], "All Files": ["*"] },
        openLabel: "Select CA Certificate (PEM)"
      });
      if (!fileUris || fileUris.length === 0) {
        vscode2.window.showInformationMessage("No CA certificate selected.");
        return;
      }
      try {
        const fileUri = fileUris[0];
        const fileContent = await vscode2.workspace.fs.readFile(fileUri);
        await context2.globalState.update("esExt.caCertificate", Buffer.from(fileContent).toString("utf8"));
        vscode2.window.showInformationMessage("CA certificate set. All new cluster connections will use this certificate.");
      } catch (err) {
        vscode2.window.showErrorMessage("Failed to read CA certificate: " + err.message);
      }
    }),
    vscode2.commands.registerCommand("esExt.clearCACertificate", async () => {
      await context2.globalState.update("esExt.caCertificate", void 0);
      vscode2.window.showInformationMessage("CA certificate cleared. New connections will not use a custom CA.");
    }),
    vscode2.commands.registerCommand("esExt.showRole", async (roleName) => {
      const client = explorerProvider.getActiveClient();
      if (!client) {
        vscode2.window.showErrorMessage("Please connect to an Elasticsearch cluster first.");
        return;
      }
      try {
        const roles = await client.security.getRole({ name: roleName });
        const roleDef = roles[roleName];
        if (roleDef) {
          const prettyJson = JSON.stringify(roleDef, null, 2);
          const doc = await vscode2.workspace.openTextDocument({ content: prettyJson, language: "json" });
          await vscode2.window.showTextDocument(doc, { preview: false });
        } else {
          vscode2.window.showErrorMessage(`Role '${roleName}' not found.`);
        }
      } catch (err) {
        vscode2.window.showErrorMessage(`Failed to fetch role '${roleName}': ${err.message}`);
      }
    }),
    vscode2.commands.registerCommand("esExt.showRoleMapping", async (mappingName) => {
      const client = explorerProvider.getActiveClient();
      if (!client) {
        vscode2.window.showErrorMessage("Please connect to an Elasticsearch cluster first.");
        return;
      }
      try {
        const mappings = await client.security.getRoleMapping({ name: mappingName });
        const mappingDef = mappings[mappingName];
        if (mappingDef) {
          const prettyJson = JSON.stringify(mappingDef, null, 2);
          const doc = await vscode2.workspace.openTextDocument({ content: prettyJson, language: "json" });
          await vscode2.window.showTextDocument(doc, { preview: false });
        } else {
          vscode2.window.showErrorMessage(`Role mapping '${mappingName}' not found.`);
        }
      } catch (err) {
        vscode2.window.showErrorMessage(`Failed to fetch role mapping '${mappingName}': ${err.message}`);
      }
    }),
    // Show Data Stream Stats
    vscode2.commands.registerCommand("esExt.showDataStreamStats", async (dataStreamName, clusterId) => {
      const client = explorerProvider.getClient(clusterId);
      if (!client) {
        vscode2.window.showErrorMessage("Please connect to an Elasticsearch cluster first.");
        return;
      }
      try {
        const resp = await client.transport.request({
          method: "GET",
          path: `/_data_stream/${encodeURIComponent(dataStreamName)}/_stats`
        });
        const stats = resp.body || resp;
        const doc = await vscode2.workspace.openTextDocument({
          content: JSON.stringify(stats, null, 2),
          language: "json"
        });
        await vscode2.window.showTextDocument(doc, { preview: false });
      } catch (err) {
        vscode2.window.showErrorMessage(`Failed to fetch stats for data stream ${dataStreamName}: ${err.message}`);
      }
    }),
    // Show Data Stream Index Stats
    vscode2.commands.registerCommand("esExt.showDataStreamIndexStats", async (dataStreamName, indexName, clusterId) => {
      const client = explorerProvider.getClient(clusterId);
      if (!client) {
        vscode2.window.showErrorMessage("Please connect to an Elasticsearch cluster first.");
        return;
      }
      try {
        const resp = await client.indices.stats({ index: indexName });
        const stats = resp.body || resp;
        const doc = await vscode2.workspace.openTextDocument({
          content: JSON.stringify(stats, null, 2),
          language: "json"
        });
        await vscode2.window.showTextDocument(doc, { preview: false });
      } catch (err) {
        vscode2.window.showErrorMessage(`Failed to fetch stats for index ${indexName}: ${err.message}`);
      }
    }),
    // Register context menu commands for cluster items
    vscode2.commands.registerCommand("esExt.clusterContextMenu", async (item) => {
      if (item.contextValue?.startsWith("clusterItem:")) {
        const clusterId = item.contextValue.split(":")[1];
        const action = await vscode2.window.showQuickPick(
          ["Connect", "Remove", "Edit"],
          { placeHolder: "Select action" }
        );
        switch (action) {
          case "Connect":
            vscode2.commands.executeCommand("esExt.connectToCluster", clusterId);
            break;
          case "Remove":
            vscode2.commands.executeCommand("esExt.removeCluster", clusterId);
            break;
          case "Edit":
            vscode2.window.showInformationMessage("Edit cluster functionality coming soon!");
            break;
        }
      }
    })
  );
}
function deactivate() {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
/*! Bundled license information:

undici/lib/web/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/web/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
*/
//# sourceMappingURL=extension.js.map
